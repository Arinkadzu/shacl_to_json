{"mappings":"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","sources":["<anon>","node_modules/readable-stream/lib/ours/primordials.js","node_modules/readable-stream/lib/ours/util.js","node_modules/buffer/index.js","node_modules/base64-js/index.js","node_modules/ieee754/index.js","node_modules/readable-stream/lib/ours/util/inspect.js","node_modules/readable-stream/lib/ours/errors.js","node_modules/abort-controller/browser.js","node_modules/events/events.js","node_modules/readable-stream/lib/internal/streams/duplex.js","node_modules/readable-stream/lib/internal/streams/readable.js","node_modules/process/browser.js","node_modules/readable-stream/lib/internal/streams/legacy.js","node_modules/readable-stream/lib/internal/streams/add-abort-signal.js","node_modules/readable-stream/lib/internal/streams/utils.js","node_modules/readable-stream/lib/internal/streams/end-of-stream.js","node_modules/readable-stream/lib/internal/validators.js","node_modules/readable-stream/lib/internal/streams/buffer_list.js","node_modules/readable-stream/lib/internal/streams/destroy.js","node_modules/readable-stream/lib/internal/streams/state.js","node_modules/string_decoder/lib/string_decoder.js","node_modules/safe-buffer/index.js","node_modules/readable-stream/lib/internal/streams/from.js","node_modules/readable-stream/lib/internal/streams/writable.js","node_modules/readable-stream/lib/internal/streams/duplexify.js","node_modules/readable-stream/lib/internal/streams/passthrough.js","node_modules/readable-stream/lib/internal/streams/transform.js","convert_shacl.js","node_modules/n3/src/index.js","node_modules/n3/src/N3Lexer.js","node_modules/n3/src/IRIs.js","node_modules/n3/src/N3Parser.js","node_modules/n3/src/N3DataFactory.js","node_modules/n3/src/N3Writer.js","node_modules/n3/src/N3Util.js","node_modules/n3/src/BaseIRI.js","node_modules/n3/src/Util.js","node_modules/n3/src/N3Store.js","node_modules/readable-stream/lib/ours/browser.js","node_modules/readable-stream/lib/stream.js","node_modules/readable-stream/lib/internal/streams/operators.js","node_modules/readable-stream/lib/internal/streams/compose.js","node_modules/readable-stream/lib/internal/streams/pipeline.js","node_modules/readable-stream/lib/stream/promises.js","node_modules/n3/src/N3StoreFactory.js","node_modules/n3/src/N3Reasoner.js","node_modules/n3/src/N3StreamParser.js","node_modules/n3/src/N3StreamWriter.js","node_modules/@parcel/node-resolver-core/lib/_empty.js"],"sourcesContent":["(() => {\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\nfunction $parcel$defineInteropFlag(a) {\n  Object.defineProperty(a, '__esModule', {value: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequirec2d1\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequirec2d1\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"1by5F\", function(module, exports) {\n'use strict';\n/*\n  This file is a reduced and adapted version of the main lib/internal/per_context/primordials.js file defined at\n\n  https://github.com/nodejs/node/blob/main/lib/internal/per_context/primordials.js\n\n  Don't try to replace with the original file and keep it up to date with the upstream file.\n*/ // This is a simplified version of AggregateError\nclass $0dd1432eb082439e$var$AggregateError extends Error {\n    constructor(errors){\n        if (!Array.isArray(errors)) throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);\n        let message = '';\n        for(let i = 0; i < errors.length; i++)message += `    ${errors[i].stack}\\n`;\n        super(message);\n        this.name = 'AggregateError';\n        this.errors = errors;\n    }\n}\nmodule.exports = {\n    AggregateError: $0dd1432eb082439e$var$AggregateError,\n    ArrayIsArray (self) {\n        return Array.isArray(self);\n    },\n    ArrayPrototypeIncludes (self, el) {\n        return self.includes(el);\n    },\n    ArrayPrototypeIndexOf (self, el) {\n        return self.indexOf(el);\n    },\n    ArrayPrototypeJoin (self, sep) {\n        return self.join(sep);\n    },\n    ArrayPrototypeMap (self, fn) {\n        return self.map(fn);\n    },\n    ArrayPrototypePop (self, el) {\n        return self.pop(el);\n    },\n    ArrayPrototypePush (self, el) {\n        return self.push(el);\n    },\n    ArrayPrototypeSlice (self, start, end) {\n        return self.slice(start, end);\n    },\n    Error: Error,\n    FunctionPrototypeCall (fn, thisArgs, ...args) {\n        return fn.call(thisArgs, ...args);\n    },\n    FunctionPrototypeSymbolHasInstance (self, instance) {\n        return Function.prototype[Symbol.hasInstance].call(self, instance);\n    },\n    MathFloor: Math.floor,\n    Number: Number,\n    NumberIsInteger: Number.isInteger,\n    NumberIsNaN: Number.isNaN,\n    NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,\n    NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,\n    NumberParseInt: Number.parseInt,\n    ObjectDefineProperties (self, props) {\n        return Object.defineProperties(self, props);\n    },\n    ObjectDefineProperty (self, name, prop) {\n        return Object.defineProperty(self, name, prop);\n    },\n    ObjectGetOwnPropertyDescriptor (self, name) {\n        return Object.getOwnPropertyDescriptor(self, name);\n    },\n    ObjectKeys (obj) {\n        return Object.keys(obj);\n    },\n    ObjectSetPrototypeOf (target, proto) {\n        return Object.setPrototypeOf(target, proto);\n    },\n    Promise: Promise,\n    PromisePrototypeCatch (self, fn) {\n        return self.catch(fn);\n    },\n    PromisePrototypeThen (self, thenFn, catchFn) {\n        return self.then(thenFn, catchFn);\n    },\n    PromiseReject (err) {\n        return Promise.reject(err);\n    },\n    PromiseResolve (val) {\n        return Promise.resolve(val);\n    },\n    ReflectApply: Reflect.apply,\n    RegExpPrototypeTest (self, value) {\n        return self.test(value);\n    },\n    SafeSet: Set,\n    String: String,\n    StringPrototypeSlice (self, start, end) {\n        return self.slice(start, end);\n    },\n    StringPrototypeToLowerCase (self) {\n        return self.toLowerCase();\n    },\n    StringPrototypeToUpperCase (self) {\n        return self.toUpperCase();\n    },\n    StringPrototypeTrim (self) {\n        return self.trim();\n    },\n    Symbol: Symbol,\n    SymbolFor: Symbol.for,\n    SymbolAsyncIterator: Symbol.asyncIterator,\n    SymbolHasInstance: Symbol.hasInstance,\n    SymbolIterator: Symbol.iterator,\n    SymbolDispose: Symbol.dispose || Symbol('Symbol.dispose'),\n    SymbolAsyncDispose: Symbol.asyncDispose || Symbol('Symbol.asyncDispose'),\n    TypedArrayPrototypeSet (self, buf, len) {\n        return self.set(buf, len);\n    },\n    Boolean: Boolean,\n    Uint8Array: Uint8Array\n};\n\n});\n\nparcelRegister(\"kDFyU\", function(module, exports) {\n'use strict';\n\nvar $N0o3H = parcelRequire(\"N0o3H\");\n\nvar $adSME = parcelRequire(\"adSME\");\nvar $f067b0868781ced2$require$format = $adSME.format;\nvar $f067b0868781ced2$require$inspect = $adSME.inspect;\n\nvar $7ynhX = parcelRequire(\"7ynhX\");\nconst { codes: { ERR_INVALID_ARG_TYPE: $f067b0868781ced2$var$ERR_INVALID_ARG_TYPE } } = $7ynhX;\n\nvar $1by5F = parcelRequire(\"1by5F\");\nvar $f067b0868781ced2$require$kResistStopPropagation = $1by5F.kResistStopPropagation;\nvar $f067b0868781ced2$require$AggregateError = $1by5F.AggregateError;\nvar $f067b0868781ced2$require$SymbolDispose = $1by5F.SymbolDispose;\n\nconst $f067b0868781ced2$var$AbortSignal = globalThis.AbortSignal || (parcelRequire(\"5zWM9\")).AbortSignal;\n\nconst $f067b0868781ced2$var$AbortController = globalThis.AbortController || (parcelRequire(\"5zWM9\")).AbortController;\nconst $f067b0868781ced2$var$AsyncFunction = Object.getPrototypeOf(async function() {}).constructor;\nconst $f067b0868781ced2$var$Blob = globalThis.Blob || $N0o3H.Blob;\n/* eslint-disable indent */ const $f067b0868781ced2$var$isBlob = typeof $f067b0868781ced2$var$Blob !== 'undefined' ? function isBlob(b) {\n    // eslint-disable-next-line indent\n    return b instanceof $f067b0868781ced2$var$Blob;\n} : function isBlob(b) {\n    return false;\n};\n/* eslint-enable indent */ const $f067b0868781ced2$var$validateAbortSignal = (signal, name)=>{\n    if (signal !== undefined && (signal === null || typeof signal !== 'object' || !('aborted' in signal))) throw new $f067b0868781ced2$var$ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal);\n};\nconst $f067b0868781ced2$var$validateFunction = (value, name)=>{\n    if (typeof value !== 'function') throw new $f067b0868781ced2$var$ERR_INVALID_ARG_TYPE(name, 'Function', value);\n};\n\nmodule.exports = {\n    AggregateError: $f067b0868781ced2$require$AggregateError,\n    kEmptyObject: Object.freeze({}),\n    once (callback) {\n        let called = false;\n        return function(...args) {\n            if (called) return;\n            called = true;\n            callback.apply(this, args);\n        };\n    },\n    createDeferredPromise: function() {\n        let resolve;\n        let reject;\n        // eslint-disable-next-line promise/param-names\n        const promise = new Promise((res, rej)=>{\n            resolve = res;\n            reject = rej;\n        });\n        return {\n            promise: promise,\n            resolve: resolve,\n            reject: reject\n        };\n    },\n    promisify (fn) {\n        return new Promise((resolve, reject)=>{\n            fn((err, ...args)=>{\n                if (err) return reject(err);\n                return resolve(...args);\n            });\n        });\n    },\n    debuglog () {\n        return function() {};\n    },\n    format: $f067b0868781ced2$require$format,\n    inspect: $f067b0868781ced2$require$inspect,\n    types: {\n        isAsyncFunction (fn) {\n            return fn instanceof $f067b0868781ced2$var$AsyncFunction;\n        },\n        isArrayBufferView (arr) {\n            return ArrayBuffer.isView(arr);\n        }\n    },\n    isBlob: $f067b0868781ced2$var$isBlob,\n    deprecate (fn, message) {\n        return fn;\n    },\n    addAbortListener: (parcelRequire(\"9sqfU\")).addAbortListener || function addAbortListener(signal, listener) {\n        if (signal === undefined) throw new $f067b0868781ced2$var$ERR_INVALID_ARG_TYPE('signal', 'AbortSignal', signal);\n        $f067b0868781ced2$var$validateAbortSignal(signal, 'signal');\n        $f067b0868781ced2$var$validateFunction(listener, 'listener');\n        let removeEventListener;\n        if (signal.aborted) queueMicrotask(()=>listener());\n        else {\n            signal.addEventListener('abort', listener, {\n                __proto__: null,\n                once: true,\n                [$f067b0868781ced2$require$kResistStopPropagation]: true\n            });\n            removeEventListener = ()=>{\n                signal.removeEventListener('abort', listener);\n            };\n        }\n        return {\n            __proto__: null,\n            [$f067b0868781ced2$require$SymbolDispose] () {\n                var _removeEventListener;\n                (_removeEventListener = removeEventListener) === null || _removeEventListener === undefined ? undefined : _removeEventListener();\n            }\n        };\n    },\n    AbortSignalAny: $f067b0868781ced2$var$AbortSignal.any || function AbortSignalAny(signals) {\n        // Fast path if there is only one signal.\n        if (signals.length === 1) return signals[0];\n        const ac = new $f067b0868781ced2$var$AbortController();\n        const abort = ()=>ac.abort();\n        signals.forEach((signal)=>{\n            $f067b0868781ced2$var$validateAbortSignal(signal, 'signals');\n            signal.addEventListener('abort', abort, {\n                once: true\n            });\n        });\n        ac.signal.addEventListener('abort', ()=>{\n            signals.forEach((signal)=>signal.removeEventListener('abort', abort));\n        }, {\n            once: true\n        });\n        return ac.signal;\n    }\n};\nmodule.exports.promisify.custom = Symbol.for('nodejs.util.promisify.custom');\n\n});\nparcelRegister(\"N0o3H\", function(module, exports) {\n\n$parcel$export(module.exports, \"Buffer\", () => $0934e0939605d48c$export$a143d493d941bafc, (v) => $0934e0939605d48c$export$a143d493d941bafc = v);\n$parcel$export(module.exports, \"SlowBuffer\", () => $0934e0939605d48c$export$e4cf37d7f6fb9e0a, (v) => $0934e0939605d48c$export$e4cf37d7f6fb9e0a = v);\n$parcel$export(module.exports, \"INSPECT_MAX_BYTES\", () => $0934e0939605d48c$export$f99ded8fe4b79145, (v) => $0934e0939605d48c$export$f99ded8fe4b79145 = v);\n$parcel$export(module.exports, \"kMaxLength\", () => $0934e0939605d48c$export$599f31c3813fae4d, (v) => $0934e0939605d48c$export$599f31c3813fae4d = v);\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */ /* eslint-disable no-proto */ var $0934e0939605d48c$export$a143d493d941bafc;\nvar $0934e0939605d48c$export$e4cf37d7f6fb9e0a;\nvar $0934e0939605d48c$export$f99ded8fe4b79145;\nvar $0934e0939605d48c$export$599f31c3813fae4d;\n'use strict';\n\nvar $bQMRt = parcelRequire(\"bQMRt\");\n\nvar $dbnIE = parcelRequire(\"dbnIE\");\nconst $0934e0939605d48c$var$customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' // eslint-disable-line dot-notation\n ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n : null;\n$0934e0939605d48c$export$a143d493d941bafc = $0934e0939605d48c$var$Buffer;\n$0934e0939605d48c$export$e4cf37d7f6fb9e0a = $0934e0939605d48c$var$SlowBuffer;\n$0934e0939605d48c$export$f99ded8fe4b79145 = 50;\nconst $0934e0939605d48c$var$K_MAX_LENGTH = 0x7fffffff;\n$0934e0939605d48c$export$599f31c3813fae4d = $0934e0939605d48c$var$K_MAX_LENGTH;\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */ $0934e0939605d48c$var$Buffer.TYPED_ARRAY_SUPPORT = $0934e0939605d48c$var$typedArraySupport();\nif (!$0934e0939605d48c$var$Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') console.error(\"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\");\nfunction $0934e0939605d48c$var$typedArraySupport() {\n    // Can typed array instances can be augmented?\n    try {\n        const arr = new Uint8Array(1);\n        const proto = {\n            foo: function() {\n                return 42;\n            }\n        };\n        Object.setPrototypeOf(proto, Uint8Array.prototype);\n        Object.setPrototypeOf(arr, proto);\n        return arr.foo() === 42;\n    } catch (e) {\n        return false;\n    }\n}\nObject.defineProperty($0934e0939605d48c$var$Buffer.prototype, 'parent', {\n    enumerable: true,\n    get: function() {\n        if (!$0934e0939605d48c$var$Buffer.isBuffer(this)) return undefined;\n        return this.buffer;\n    }\n});\nObject.defineProperty($0934e0939605d48c$var$Buffer.prototype, 'offset', {\n    enumerable: true,\n    get: function() {\n        if (!$0934e0939605d48c$var$Buffer.isBuffer(this)) return undefined;\n        return this.byteOffset;\n    }\n});\nfunction $0934e0939605d48c$var$createBuffer(length) {\n    if (length > $0934e0939605d48c$var$K_MAX_LENGTH) throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n    // Return an augmented `Uint8Array` instance\n    const buf = new Uint8Array(length);\n    Object.setPrototypeOf(buf, $0934e0939605d48c$var$Buffer.prototype);\n    return buf;\n}\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */ function $0934e0939605d48c$var$Buffer(arg, encodingOrOffset, length) {\n    // Common case.\n    if (typeof arg === 'number') {\n        if (typeof encodingOrOffset === 'string') throw new TypeError('The \"string\" argument must be of type string. Received type number');\n        return $0934e0939605d48c$var$allocUnsafe(arg);\n    }\n    return $0934e0939605d48c$var$from(arg, encodingOrOffset, length);\n}\n$0934e0939605d48c$var$Buffer.poolSize = 8192 // not used by this implementation\n;\nfunction $0934e0939605d48c$var$from(value, encodingOrOffset, length) {\n    if (typeof value === 'string') return $0934e0939605d48c$var$fromString(value, encodingOrOffset);\n    if (ArrayBuffer.isView(value)) return $0934e0939605d48c$var$fromArrayView(value);\n    if (value == null) throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value);\n    if ($0934e0939605d48c$var$isInstance(value, ArrayBuffer) || value && $0934e0939605d48c$var$isInstance(value.buffer, ArrayBuffer)) return $0934e0939605d48c$var$fromArrayBuffer(value, encodingOrOffset, length);\n    if (typeof SharedArrayBuffer !== 'undefined' && ($0934e0939605d48c$var$isInstance(value, SharedArrayBuffer) || value && $0934e0939605d48c$var$isInstance(value.buffer, SharedArrayBuffer))) return $0934e0939605d48c$var$fromArrayBuffer(value, encodingOrOffset, length);\n    if (typeof value === 'number') throw new TypeError('The \"value\" argument must not be of type number. Received type number');\n    const valueOf = value.valueOf && value.valueOf();\n    if (valueOf != null && valueOf !== value) return $0934e0939605d48c$var$Buffer.from(valueOf, encodingOrOffset, length);\n    const b = $0934e0939605d48c$var$fromObject(value);\n    if (b) return b;\n    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') return $0934e0939605d48c$var$Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);\n    throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value);\n}\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/ $0934e0939605d48c$var$Buffer.from = function(value, encodingOrOffset, length) {\n    return $0934e0939605d48c$var$from(value, encodingOrOffset, length);\n};\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf($0934e0939605d48c$var$Buffer.prototype, Uint8Array.prototype);\nObject.setPrototypeOf($0934e0939605d48c$var$Buffer, Uint8Array);\nfunction $0934e0939605d48c$var$assertSize(size) {\n    if (typeof size !== 'number') throw new TypeError('\"size\" argument must be of type number');\n    else if (size < 0) throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n}\nfunction $0934e0939605d48c$var$alloc(size, fill, encoding) {\n    $0934e0939605d48c$var$assertSize(size);\n    if (size <= 0) return $0934e0939605d48c$var$createBuffer(size);\n    if (fill !== undefined) // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string' ? $0934e0939605d48c$var$createBuffer(size).fill(fill, encoding) : $0934e0939605d48c$var$createBuffer(size).fill(fill);\n    return $0934e0939605d48c$var$createBuffer(size);\n}\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/ $0934e0939605d48c$var$Buffer.alloc = function(size, fill, encoding) {\n    return $0934e0939605d48c$var$alloc(size, fill, encoding);\n};\nfunction $0934e0939605d48c$var$allocUnsafe(size) {\n    $0934e0939605d48c$var$assertSize(size);\n    return $0934e0939605d48c$var$createBuffer(size < 0 ? 0 : $0934e0939605d48c$var$checked(size) | 0);\n}\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */ $0934e0939605d48c$var$Buffer.allocUnsafe = function(size) {\n    return $0934e0939605d48c$var$allocUnsafe(size);\n};\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */ $0934e0939605d48c$var$Buffer.allocUnsafeSlow = function(size) {\n    return $0934e0939605d48c$var$allocUnsafe(size);\n};\nfunction $0934e0939605d48c$var$fromString(string, encoding) {\n    if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8';\n    if (!$0934e0939605d48c$var$Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);\n    const length = $0934e0939605d48c$var$byteLength(string, encoding) | 0;\n    let buf = $0934e0939605d48c$var$createBuffer(length);\n    const actual = buf.write(string, encoding);\n    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual);\n    return buf;\n}\nfunction $0934e0939605d48c$var$fromArrayLike(array) {\n    const length = array.length < 0 ? 0 : $0934e0939605d48c$var$checked(array.length) | 0;\n    const buf = $0934e0939605d48c$var$createBuffer(length);\n    for(let i = 0; i < length; i += 1)buf[i] = array[i] & 255;\n    return buf;\n}\nfunction $0934e0939605d48c$var$fromArrayView(arrayView) {\n    if ($0934e0939605d48c$var$isInstance(arrayView, Uint8Array)) {\n        const copy = new Uint8Array(arrayView);\n        return $0934e0939605d48c$var$fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n    }\n    return $0934e0939605d48c$var$fromArrayLike(arrayView);\n}\nfunction $0934e0939605d48c$var$fromArrayBuffer(array, byteOffset, length) {\n    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('\"offset\" is outside of buffer bounds');\n    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('\"length\" is outside of buffer bounds');\n    let buf;\n    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);\n    else if (length === undefined) buf = new Uint8Array(array, byteOffset);\n    else buf = new Uint8Array(array, byteOffset, length);\n    // Return an augmented `Uint8Array` instance\n    Object.setPrototypeOf(buf, $0934e0939605d48c$var$Buffer.prototype);\n    return buf;\n}\nfunction $0934e0939605d48c$var$fromObject(obj) {\n    if ($0934e0939605d48c$var$Buffer.isBuffer(obj)) {\n        const len = $0934e0939605d48c$var$checked(obj.length) | 0;\n        const buf = $0934e0939605d48c$var$createBuffer(len);\n        if (buf.length === 0) return buf;\n        obj.copy(buf, 0, 0, len);\n        return buf;\n    }\n    if (obj.length !== undefined) {\n        if (typeof obj.length !== 'number' || $0934e0939605d48c$var$numberIsNaN(obj.length)) return $0934e0939605d48c$var$createBuffer(0);\n        return $0934e0939605d48c$var$fromArrayLike(obj);\n    }\n    if (obj.type === 'Buffer' && Array.isArray(obj.data)) return $0934e0939605d48c$var$fromArrayLike(obj.data);\n}\nfunction $0934e0939605d48c$var$checked(length) {\n    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n    // length is NaN (which is otherwise coerced to zero.)\n    if (length >= $0934e0939605d48c$var$K_MAX_LENGTH) throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + $0934e0939605d48c$var$K_MAX_LENGTH.toString(16) + ' bytes');\n    return length | 0;\n}\nfunction $0934e0939605d48c$var$SlowBuffer(length) {\n    if (+length != length) length = 0;\n    return $0934e0939605d48c$var$Buffer.alloc(+length);\n}\n$0934e0939605d48c$var$Buffer.isBuffer = function isBuffer(b) {\n    return b != null && b._isBuffer === true && b !== $0934e0939605d48c$var$Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n    ;\n};\n$0934e0939605d48c$var$Buffer.compare = function compare(a, b) {\n    if ($0934e0939605d48c$var$isInstance(a, Uint8Array)) a = $0934e0939605d48c$var$Buffer.from(a, a.offset, a.byteLength);\n    if ($0934e0939605d48c$var$isInstance(b, Uint8Array)) b = $0934e0939605d48c$var$Buffer.from(b, b.offset, b.byteLength);\n    if (!$0934e0939605d48c$var$Buffer.isBuffer(a) || !$0934e0939605d48c$var$Buffer.isBuffer(b)) throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');\n    if (a === b) return 0;\n    let x = a.length;\n    let y = b.length;\n    for(let i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {\n        x = a[i];\n        y = b[i];\n        break;\n    }\n    if (x < y) return -1;\n    if (y < x) return 1;\n    return 0;\n};\n$0934e0939605d48c$var$Buffer.isEncoding = function isEncoding(encoding) {\n    switch(String(encoding).toLowerCase()){\n        case 'hex':\n        case 'utf8':\n        case 'utf-8':\n        case 'ascii':\n        case 'latin1':\n        case 'binary':\n        case 'base64':\n        case 'ucs2':\n        case 'ucs-2':\n        case 'utf16le':\n        case 'utf-16le':\n            return true;\n        default:\n            return false;\n    }\n};\n$0934e0939605d48c$var$Buffer.concat = function concat(list, length) {\n    if (!Array.isArray(list)) throw new TypeError('\"list\" argument must be an Array of Buffers');\n    if (list.length === 0) return $0934e0939605d48c$var$Buffer.alloc(0);\n    let i;\n    if (length === undefined) {\n        length = 0;\n        for(i = 0; i < list.length; ++i)length += list[i].length;\n    }\n    const buffer = $0934e0939605d48c$var$Buffer.allocUnsafe(length);\n    let pos = 0;\n    for(i = 0; i < list.length; ++i){\n        let buf = list[i];\n        if ($0934e0939605d48c$var$isInstance(buf, Uint8Array)) {\n            if (pos + buf.length > buffer.length) {\n                if (!$0934e0939605d48c$var$Buffer.isBuffer(buf)) buf = $0934e0939605d48c$var$Buffer.from(buf);\n                buf.copy(buffer, pos);\n            } else Uint8Array.prototype.set.call(buffer, buf, pos);\n        } else if (!$0934e0939605d48c$var$Buffer.isBuffer(buf)) throw new TypeError('\"list\" argument must be an Array of Buffers');\n        else buf.copy(buffer, pos);\n        pos += buf.length;\n    }\n    return buffer;\n};\nfunction $0934e0939605d48c$var$byteLength(string, encoding) {\n    if ($0934e0939605d48c$var$Buffer.isBuffer(string)) return string.length;\n    if (ArrayBuffer.isView(string) || $0934e0939605d48c$var$isInstance(string, ArrayBuffer)) return string.byteLength;\n    if (typeof string !== 'string') throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);\n    const len = string.length;\n    const mustMatch = arguments.length > 2 && arguments[2] === true;\n    if (!mustMatch && len === 0) return 0;\n    // Use a for loop to avoid recursion\n    let loweredCase = false;\n    for(;;)switch(encoding){\n        case 'ascii':\n        case 'latin1':\n        case 'binary':\n            return len;\n        case 'utf8':\n        case 'utf-8':\n            return $0934e0939605d48c$var$utf8ToBytes(string).length;\n        case 'ucs2':\n        case 'ucs-2':\n        case 'utf16le':\n        case 'utf-16le':\n            return len * 2;\n        case 'hex':\n            return len >>> 1;\n        case 'base64':\n            return $0934e0939605d48c$var$base64ToBytes(string).length;\n        default:\n            if (loweredCase) return mustMatch ? -1 : $0934e0939605d48c$var$utf8ToBytes(string).length // assume utf8\n            ;\n            encoding = ('' + encoding).toLowerCase();\n            loweredCase = true;\n    }\n}\n$0934e0939605d48c$var$Buffer.byteLength = $0934e0939605d48c$var$byteLength;\nfunction $0934e0939605d48c$var$slowToString(encoding, start, end) {\n    let loweredCase = false;\n    // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n    // property of a typed array.\n    // This behaves neither like String nor Uint8Array in that we set start/end\n    // to their upper/lower bounds if the value passed is out of range.\n    // undefined is handled specially as per ECMA-262 6th Edition,\n    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n    if (start === undefined || start < 0) start = 0;\n    // Return early if start > this.length. Done here to prevent potential uint32\n    // coercion fail below.\n    if (start > this.length) return '';\n    if (end === undefined || end > this.length) end = this.length;\n    if (end <= 0) return '';\n    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n    end >>>= 0;\n    start >>>= 0;\n    if (end <= start) return '';\n    if (!encoding) encoding = 'utf8';\n    while(true)switch(encoding){\n        case 'hex':\n            return $0934e0939605d48c$var$hexSlice(this, start, end);\n        case 'utf8':\n        case 'utf-8':\n            return $0934e0939605d48c$var$utf8Slice(this, start, end);\n        case 'ascii':\n            return $0934e0939605d48c$var$asciiSlice(this, start, end);\n        case 'latin1':\n        case 'binary':\n            return $0934e0939605d48c$var$latin1Slice(this, start, end);\n        case 'base64':\n            return $0934e0939605d48c$var$base64Slice(this, start, end);\n        case 'ucs2':\n        case 'ucs-2':\n        case 'utf16le':\n        case 'utf-16le':\n            return $0934e0939605d48c$var$utf16leSlice(this, start, end);\n        default:\n            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n            encoding = (encoding + '').toLowerCase();\n            loweredCase = true;\n    }\n}\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\n$0934e0939605d48c$var$Buffer.prototype._isBuffer = true;\nfunction $0934e0939605d48c$var$swap(b, n, m) {\n    const i = b[n];\n    b[n] = b[m];\n    b[m] = i;\n}\n$0934e0939605d48c$var$Buffer.prototype.swap16 = function swap16() {\n    const len = this.length;\n    if (len % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits');\n    for(let i = 0; i < len; i += 2)$0934e0939605d48c$var$swap(this, i, i + 1);\n    return this;\n};\n$0934e0939605d48c$var$Buffer.prototype.swap32 = function swap32() {\n    const len = this.length;\n    if (len % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits');\n    for(let i = 0; i < len; i += 4){\n        $0934e0939605d48c$var$swap(this, i, i + 3);\n        $0934e0939605d48c$var$swap(this, i + 1, i + 2);\n    }\n    return this;\n};\n$0934e0939605d48c$var$Buffer.prototype.swap64 = function swap64() {\n    const len = this.length;\n    if (len % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits');\n    for(let i = 0; i < len; i += 8){\n        $0934e0939605d48c$var$swap(this, i, i + 7);\n        $0934e0939605d48c$var$swap(this, i + 1, i + 6);\n        $0934e0939605d48c$var$swap(this, i + 2, i + 5);\n        $0934e0939605d48c$var$swap(this, i + 3, i + 4);\n    }\n    return this;\n};\n$0934e0939605d48c$var$Buffer.prototype.toString = function toString() {\n    const length = this.length;\n    if (length === 0) return '';\n    if (arguments.length === 0) return $0934e0939605d48c$var$utf8Slice(this, 0, length);\n    return $0934e0939605d48c$var$slowToString.apply(this, arguments);\n};\n$0934e0939605d48c$var$Buffer.prototype.toLocaleString = $0934e0939605d48c$var$Buffer.prototype.toString;\n$0934e0939605d48c$var$Buffer.prototype.equals = function equals(b) {\n    if (!$0934e0939605d48c$var$Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');\n    if (this === b) return true;\n    return $0934e0939605d48c$var$Buffer.compare(this, b) === 0;\n};\n$0934e0939605d48c$var$Buffer.prototype.inspect = function inspect() {\n    let str = '';\n    const max = $0934e0939605d48c$export$f99ded8fe4b79145;\n    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();\n    if (this.length > max) str += ' ... ';\n    return '<Buffer ' + str + '>';\n};\nif ($0934e0939605d48c$var$customInspectSymbol) $0934e0939605d48c$var$Buffer.prototype[$0934e0939605d48c$var$customInspectSymbol] = $0934e0939605d48c$var$Buffer.prototype.inspect;\n$0934e0939605d48c$var$Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n    if ($0934e0939605d48c$var$isInstance(target, Uint8Array)) target = $0934e0939605d48c$var$Buffer.from(target, target.offset, target.byteLength);\n    if (!$0934e0939605d48c$var$Buffer.isBuffer(target)) throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);\n    if (start === undefined) start = 0;\n    if (end === undefined) end = target ? target.length : 0;\n    if (thisStart === undefined) thisStart = 0;\n    if (thisEnd === undefined) thisEnd = this.length;\n    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError('out of range index');\n    if (thisStart >= thisEnd && start >= end) return 0;\n    if (thisStart >= thisEnd) return -1;\n    if (start >= end) return 1;\n    start >>>= 0;\n    end >>>= 0;\n    thisStart >>>= 0;\n    thisEnd >>>= 0;\n    if (this === target) return 0;\n    let x = thisEnd - thisStart;\n    let y = end - start;\n    const len = Math.min(x, y);\n    const thisCopy = this.slice(thisStart, thisEnd);\n    const targetCopy = target.slice(start, end);\n    for(let i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {\n        x = thisCopy[i];\n        y = targetCopy[i];\n        break;\n    }\n    if (x < y) return -1;\n    if (y < x) return 1;\n    return 0;\n};\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction $0934e0939605d48c$var$bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n    // Empty buffer means no match\n    if (buffer.length === 0) return -1;\n    // Normalize byteOffset\n    if (typeof byteOffset === 'string') {\n        encoding = byteOffset;\n        byteOffset = 0;\n    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;\n    else if (byteOffset < -2147483648) byteOffset = -2147483648;\n    byteOffset = +byteOffset // Coerce to Number.\n    ;\n    if ($0934e0939605d48c$var$numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : buffer.length - 1;\n    // Normalize byteOffset: negative offsets start from the end of the buffer\n    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n    if (byteOffset >= buffer.length) {\n        if (dir) return -1;\n        else byteOffset = buffer.length - 1;\n    } else if (byteOffset < 0) {\n        if (dir) byteOffset = 0;\n        else return -1;\n    }\n    // Normalize val\n    if (typeof val === 'string') val = $0934e0939605d48c$var$Buffer.from(val, encoding);\n    // Finally, search either indexOf (if dir is true) or lastIndexOf\n    if ($0934e0939605d48c$var$Buffer.isBuffer(val)) {\n        // Special case: looking for empty string/buffer always fails\n        if (val.length === 0) return -1;\n        return $0934e0939605d48c$var$arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n    } else if (typeof val === 'number') {\n        val = val & 0xFF // Search for a byte value [0-255]\n        ;\n        if (typeof Uint8Array.prototype.indexOf === 'function') {\n            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n        }\n        return $0934e0939605d48c$var$arrayIndexOf(buffer, [\n            val\n        ], byteOffset, encoding, dir);\n    }\n    throw new TypeError('val must be string, number or Buffer');\n}\nfunction $0934e0939605d48c$var$arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n    let indexSize = 1;\n    let arrLength = arr.length;\n    let valLength = val.length;\n    if (encoding !== undefined) {\n        encoding = String(encoding).toLowerCase();\n        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {\n            if (arr.length < 2 || val.length < 2) return -1;\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n        }\n    }\n    function read(buf, i) {\n        if (indexSize === 1) return buf[i];\n        else return buf.readUInt16BE(i * indexSize);\n    }\n    let i;\n    if (dir) {\n        let foundIndex = -1;\n        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n            if (foundIndex === -1) foundIndex = i;\n            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n        } else {\n            if (foundIndex !== -1) i -= i - foundIndex;\n            foundIndex = -1;\n        }\n    } else {\n        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n        for(i = byteOffset; i >= 0; i--){\n            let found = true;\n            for(let j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {\n                found = false;\n                break;\n            }\n            if (found) return i;\n        }\n    }\n    return -1;\n}\n$0934e0939605d48c$var$Buffer.prototype.includes = function includes(val, byteOffset, encoding) {\n    return this.indexOf(val, byteOffset, encoding) !== -1;\n};\n$0934e0939605d48c$var$Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n    return $0934e0939605d48c$var$bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n};\n$0934e0939605d48c$var$Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n    return $0934e0939605d48c$var$bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n};\nfunction $0934e0939605d48c$var$hexWrite(buf, string, offset, length) {\n    offset = Number(offset) || 0;\n    const remaining = buf.length - offset;\n    if (!length) length = remaining;\n    else {\n        length = Number(length);\n        if (length > remaining) length = remaining;\n    }\n    const strLen = string.length;\n    if (length > strLen / 2) length = strLen / 2;\n    let i;\n    for(i = 0; i < length; ++i){\n        const parsed = parseInt(string.substr(i * 2, 2), 16);\n        if ($0934e0939605d48c$var$numberIsNaN(parsed)) return i;\n        buf[offset + i] = parsed;\n    }\n    return i;\n}\nfunction $0934e0939605d48c$var$utf8Write(buf, string, offset, length) {\n    return $0934e0939605d48c$var$blitBuffer($0934e0939605d48c$var$utf8ToBytes(string, buf.length - offset), buf, offset, length);\n}\nfunction $0934e0939605d48c$var$asciiWrite(buf, string, offset, length) {\n    return $0934e0939605d48c$var$blitBuffer($0934e0939605d48c$var$asciiToBytes(string), buf, offset, length);\n}\nfunction $0934e0939605d48c$var$base64Write(buf, string, offset, length) {\n    return $0934e0939605d48c$var$blitBuffer($0934e0939605d48c$var$base64ToBytes(string), buf, offset, length);\n}\nfunction $0934e0939605d48c$var$ucs2Write(buf, string, offset, length) {\n    return $0934e0939605d48c$var$blitBuffer($0934e0939605d48c$var$utf16leToBytes(string, buf.length - offset), buf, offset, length);\n}\n$0934e0939605d48c$var$Buffer.prototype.write = function write(string, offset, length, encoding) {\n    // Buffer#write(string)\n    if (offset === undefined) {\n        encoding = 'utf8';\n        length = this.length;\n        offset = 0;\n    // Buffer#write(string, encoding)\n    } else if (length === undefined && typeof offset === 'string') {\n        encoding = offset;\n        length = this.length;\n        offset = 0;\n    // Buffer#write(string, offset[, length][, encoding])\n    } else if (isFinite(offset)) {\n        offset = offset >>> 0;\n        if (isFinite(length)) {\n            length = length >>> 0;\n            if (encoding === undefined) encoding = 'utf8';\n        } else {\n            encoding = length;\n            length = undefined;\n        }\n    } else throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');\n    const remaining = this.length - offset;\n    if (length === undefined || length > remaining) length = remaining;\n    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError('Attempt to write outside buffer bounds');\n    if (!encoding) encoding = 'utf8';\n    let loweredCase = false;\n    for(;;)switch(encoding){\n        case 'hex':\n            return $0934e0939605d48c$var$hexWrite(this, string, offset, length);\n        case 'utf8':\n        case 'utf-8':\n            return $0934e0939605d48c$var$utf8Write(this, string, offset, length);\n        case 'ascii':\n        case 'latin1':\n        case 'binary':\n            return $0934e0939605d48c$var$asciiWrite(this, string, offset, length);\n        case 'base64':\n            // Warning: maxLength not taken into account in base64Write\n            return $0934e0939605d48c$var$base64Write(this, string, offset, length);\n        case 'ucs2':\n        case 'ucs-2':\n        case 'utf16le':\n        case 'utf-16le':\n            return $0934e0939605d48c$var$ucs2Write(this, string, offset, length);\n        default:\n            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n            encoding = ('' + encoding).toLowerCase();\n            loweredCase = true;\n    }\n};\n$0934e0939605d48c$var$Buffer.prototype.toJSON = function toJSON() {\n    return {\n        type: 'Buffer',\n        data: Array.prototype.slice.call(this._arr || this, 0)\n    };\n};\nfunction $0934e0939605d48c$var$base64Slice(buf, start, end) {\n    if (start === 0 && end === buf.length) return $bQMRt.fromByteArray(buf);\n    else return $bQMRt.fromByteArray(buf.slice(start, end));\n}\nfunction $0934e0939605d48c$var$utf8Slice(buf, start, end) {\n    end = Math.min(buf.length, end);\n    const res = [];\n    let i = start;\n    while(i < end){\n        const firstByte = buf[i];\n        let codePoint = null;\n        let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n        if (i + bytesPerSequence <= end) {\n            let secondByte, thirdByte, fourthByte, tempCodePoint;\n            switch(bytesPerSequence){\n                case 1:\n                    if (firstByte < 0x80) codePoint = firstByte;\n                    break;\n                case 2:\n                    secondByte = buf[i + 1];\n                    if ((secondByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;\n                    }\n                    break;\n                case 3:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;\n                    }\n                    break;\n                case 4:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    fourthByte = buf[i + 3];\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;\n                    }\n            }\n        }\n        if (codePoint === null) {\n            // we did not generate a valid codePoint so insert a\n            // replacement char (U+FFFD) and advance only 1 byte\n            codePoint = 0xFFFD;\n            bytesPerSequence = 1;\n        } else if (codePoint > 0xFFFF) {\n            // encode to utf16 (surrogate pair dance)\n            codePoint -= 0x10000;\n            res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n            codePoint = 0xDC00 | codePoint & 0x3FF;\n        }\n        res.push(codePoint);\n        i += bytesPerSequence;\n    }\n    return $0934e0939605d48c$var$decodeCodePointsArray(res);\n}\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst $0934e0939605d48c$var$MAX_ARGUMENTS_LENGTH = 0x1000;\nfunction $0934e0939605d48c$var$decodeCodePointsArray(codePoints) {\n    const len = codePoints.length;\n    if (len <= $0934e0939605d48c$var$MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n    ;\n    // Decode in chunks to avoid \"call stack size exceeded\".\n    let res = '';\n    let i = 0;\n    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += $0934e0939605d48c$var$MAX_ARGUMENTS_LENGTH));\n    return res;\n}\nfunction $0934e0939605d48c$var$asciiSlice(buf, start, end) {\n    let ret = '';\n    end = Math.min(buf.length, end);\n    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);\n    return ret;\n}\nfunction $0934e0939605d48c$var$latin1Slice(buf, start, end) {\n    let ret = '';\n    end = Math.min(buf.length, end);\n    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);\n    return ret;\n}\nfunction $0934e0939605d48c$var$hexSlice(buf, start, end) {\n    const len = buf.length;\n    if (!start || start < 0) start = 0;\n    if (!end || end < 0 || end > len) end = len;\n    let out = '';\n    for(let i = start; i < end; ++i)out += $0934e0939605d48c$var$hexSliceLookupTable[buf[i]];\n    return out;\n}\nfunction $0934e0939605d48c$var$utf16leSlice(buf, start, end) {\n    const bytes = buf.slice(start, end);\n    let res = '';\n    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n    for(let i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n    return res;\n}\n$0934e0939605d48c$var$Buffer.prototype.slice = function slice(start, end) {\n    const len = this.length;\n    start = ~~start;\n    end = end === undefined ? len : ~~end;\n    if (start < 0) {\n        start += len;\n        if (start < 0) start = 0;\n    } else if (start > len) start = len;\n    if (end < 0) {\n        end += len;\n        if (end < 0) end = 0;\n    } else if (end > len) end = len;\n    if (end < start) end = start;\n    const newBuf = this.subarray(start, end);\n    // Return an augmented `Uint8Array` instance\n    Object.setPrototypeOf(newBuf, $0934e0939605d48c$var$Buffer.prototype);\n    return newBuf;\n};\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */ function $0934e0939605d48c$var$checkOffset(offset, ext, length) {\n    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');\n    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');\n}\n$0934e0939605d48c$var$Buffer.prototype.readUintLE = $0934e0939605d48c$var$Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, byteLength, this.length);\n    let val = this[offset];\n    let mul = 1;\n    let i = 0;\n    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;\n    return val;\n};\n$0934e0939605d48c$var$Buffer.prototype.readUintBE = $0934e0939605d48c$var$Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, byteLength, this.length);\n    let val = this[offset + --byteLength];\n    let mul = 1;\n    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;\n    return val;\n};\n$0934e0939605d48c$var$Buffer.prototype.readUint8 = $0934e0939605d48c$var$Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, 1, this.length);\n    return this[offset];\n};\n$0934e0939605d48c$var$Buffer.prototype.readUint16LE = $0934e0939605d48c$var$Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, 2, this.length);\n    return this[offset] | this[offset + 1] << 8;\n};\n$0934e0939605d48c$var$Buffer.prototype.readUint16BE = $0934e0939605d48c$var$Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, 2, this.length);\n    return this[offset] << 8 | this[offset + 1];\n};\n$0934e0939605d48c$var$Buffer.prototype.readUint32LE = $0934e0939605d48c$var$Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, 4, this.length);\n    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n};\n$0934e0939605d48c$var$Buffer.prototype.readUint32BE = $0934e0939605d48c$var$Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, 4, this.length);\n    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n};\n$0934e0939605d48c$var$Buffer.prototype.readBigUInt64LE = $0934e0939605d48c$var$defineBigIntMethod(function readBigUInt64LE(offset) {\n    offset = offset >>> 0;\n    $0934e0939605d48c$var$validateNumber(offset, 'offset');\n    const first = this[offset];\n    const last = this[offset + 7];\n    if (first === undefined || last === undefined) $0934e0939605d48c$var$boundsError(offset, this.length - 8);\n    const lo = first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;\n    const hi = this[++offset] + this[++offset] * 256 + this[++offset] * 2 ** 16 + last * 2 ** 24;\n    return BigInt(lo) + (BigInt(hi) << BigInt(32));\n});\n$0934e0939605d48c$var$Buffer.prototype.readBigUInt64BE = $0934e0939605d48c$var$defineBigIntMethod(function readBigUInt64BE(offset) {\n    offset = offset >>> 0;\n    $0934e0939605d48c$var$validateNumber(offset, 'offset');\n    const first = this[offset];\n    const last = this[offset + 7];\n    if (first === undefined || last === undefined) $0934e0939605d48c$var$boundsError(offset, this.length - 8);\n    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];\n    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last;\n    return (BigInt(hi) << BigInt(32)) + BigInt(lo);\n});\n$0934e0939605d48c$var$Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, byteLength, this.length);\n    let val = this[offset];\n    let mul = 1;\n    let i = 0;\n    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;\n    mul *= 0x80;\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n    return val;\n};\n$0934e0939605d48c$var$Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, byteLength, this.length);\n    let i = byteLength;\n    let mul = 1;\n    let val = this[offset + --i];\n    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;\n    mul *= 0x80;\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n    return val;\n};\n$0934e0939605d48c$var$Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, 1, this.length);\n    if (!(this[offset] & 0x80)) return this[offset];\n    return (0xff - this[offset] + 1) * -1;\n};\n$0934e0939605d48c$var$Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, 2, this.length);\n    const val = this[offset] | this[offset + 1] << 8;\n    return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\n$0934e0939605d48c$var$Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, 2, this.length);\n    const val = this[offset + 1] | this[offset] << 8;\n    return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\n$0934e0939605d48c$var$Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, 4, this.length);\n    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n};\n$0934e0939605d48c$var$Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, 4, this.length);\n    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n};\n$0934e0939605d48c$var$Buffer.prototype.readBigInt64LE = $0934e0939605d48c$var$defineBigIntMethod(function readBigInt64LE(offset) {\n    offset = offset >>> 0;\n    $0934e0939605d48c$var$validateNumber(offset, 'offset');\n    const first = this[offset];\n    const last = this[offset + 7];\n    if (first === undefined || last === undefined) $0934e0939605d48c$var$boundsError(offset, this.length - 8);\n    const val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * 2 ** 16 + (last << 24 // Overflow\n    );\n    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);\n});\n$0934e0939605d48c$var$Buffer.prototype.readBigInt64BE = $0934e0939605d48c$var$defineBigIntMethod(function readBigInt64BE(offset) {\n    offset = offset >>> 0;\n    $0934e0939605d48c$var$validateNumber(offset, 'offset');\n    const first = this[offset];\n    const last = this[offset + 7];\n    if (first === undefined || last === undefined) $0934e0939605d48c$var$boundsError(offset, this.length - 8);\n    const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];\n    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last);\n});\n$0934e0939605d48c$var$Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, 4, this.length);\n    return $dbnIE.read(this, offset, true, 23, 4);\n};\n$0934e0939605d48c$var$Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, 4, this.length);\n    return $dbnIE.read(this, offset, false, 23, 4);\n};\n$0934e0939605d48c$var$Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, 8, this.length);\n    return $dbnIE.read(this, offset, true, 52, 8);\n};\n$0934e0939605d48c$var$Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, 8, this.length);\n    return $dbnIE.read(this, offset, false, 52, 8);\n};\nfunction $0934e0939605d48c$var$checkInt(buf, value, offset, ext, max, min) {\n    if (!$0934e0939605d48c$var$Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n    if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n    if (offset + ext > buf.length) throw new RangeError('Index out of range');\n}\n$0934e0939605d48c$var$Buffer.prototype.writeUintLE = $0934e0939605d48c$var$Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) {\n        const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n        $0934e0939605d48c$var$checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n    let mul = 1;\n    let i = 0;\n    this[offset] = value & 0xFF;\n    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;\n    return offset + byteLength;\n};\n$0934e0939605d48c$var$Buffer.prototype.writeUintBE = $0934e0939605d48c$var$Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) {\n        const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n        $0934e0939605d48c$var$checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n    let i = byteLength - 1;\n    let mul = 1;\n    this[offset + i] = value & 0xFF;\n    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;\n    return offset + byteLength;\n};\n$0934e0939605d48c$var$Buffer.prototype.writeUint8 = $0934e0939605d48c$var$Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkInt(this, value, offset, 1, 0xff, 0);\n    this[offset] = value & 0xff;\n    return offset + 1;\n};\n$0934e0939605d48c$var$Buffer.prototype.writeUint16LE = $0934e0939605d48c$var$Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkInt(this, value, offset, 2, 0xffff, 0);\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n    return offset + 2;\n};\n$0934e0939605d48c$var$Buffer.prototype.writeUint16BE = $0934e0939605d48c$var$Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkInt(this, value, offset, 2, 0xffff, 0);\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 0xff;\n    return offset + 2;\n};\n$0934e0939605d48c$var$Buffer.prototype.writeUint32LE = $0934e0939605d48c$var$Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkInt(this, value, offset, 4, 0xffffffff, 0);\n    this[offset + 3] = value >>> 24;\n    this[offset + 2] = value >>> 16;\n    this[offset + 1] = value >>> 8;\n    this[offset] = value & 0xff;\n    return offset + 4;\n};\n$0934e0939605d48c$var$Buffer.prototype.writeUint32BE = $0934e0939605d48c$var$Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkInt(this, value, offset, 4, 0xffffffff, 0);\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 0xff;\n    return offset + 4;\n};\nfunction $0934e0939605d48c$var$wrtBigUInt64LE(buf, value, offset, min, max) {\n    $0934e0939605d48c$var$checkIntBI(value, min, max, buf, offset, 7);\n    let lo = Number(value & BigInt(0xffffffff));\n    buf[offset++] = lo;\n    lo = lo >> 8;\n    buf[offset++] = lo;\n    lo = lo >> 8;\n    buf[offset++] = lo;\n    lo = lo >> 8;\n    buf[offset++] = lo;\n    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));\n    buf[offset++] = hi;\n    hi = hi >> 8;\n    buf[offset++] = hi;\n    hi = hi >> 8;\n    buf[offset++] = hi;\n    hi = hi >> 8;\n    buf[offset++] = hi;\n    return offset;\n}\nfunction $0934e0939605d48c$var$wrtBigUInt64BE(buf, value, offset, min, max) {\n    $0934e0939605d48c$var$checkIntBI(value, min, max, buf, offset, 7);\n    let lo = Number(value & BigInt(0xffffffff));\n    buf[offset + 7] = lo;\n    lo = lo >> 8;\n    buf[offset + 6] = lo;\n    lo = lo >> 8;\n    buf[offset + 5] = lo;\n    lo = lo >> 8;\n    buf[offset + 4] = lo;\n    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));\n    buf[offset + 3] = hi;\n    hi = hi >> 8;\n    buf[offset + 2] = hi;\n    hi = hi >> 8;\n    buf[offset + 1] = hi;\n    hi = hi >> 8;\n    buf[offset] = hi;\n    return offset + 8;\n}\n$0934e0939605d48c$var$Buffer.prototype.writeBigUInt64LE = $0934e0939605d48c$var$defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {\n    return $0934e0939605d48c$var$wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));\n});\n$0934e0939605d48c$var$Buffer.prototype.writeBigUInt64BE = $0934e0939605d48c$var$defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {\n    return $0934e0939605d48c$var$wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));\n});\n$0934e0939605d48c$var$Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) {\n        const limit = Math.pow(2, 8 * byteLength - 1);\n        $0934e0939605d48c$var$checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n    let i = 0;\n    let mul = 1;\n    let sub = 0;\n    this[offset] = value & 0xFF;\n    while(++i < byteLength && (mul *= 0x100)){\n        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;\n        this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n    }\n    return offset + byteLength;\n};\n$0934e0939605d48c$var$Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) {\n        const limit = Math.pow(2, 8 * byteLength - 1);\n        $0934e0939605d48c$var$checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n    let i = byteLength - 1;\n    let mul = 1;\n    let sub = 0;\n    this[offset + i] = value & 0xFF;\n    while(--i >= 0 && (mul *= 0x100)){\n        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;\n        this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n    }\n    return offset + byteLength;\n};\n$0934e0939605d48c$var$Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkInt(this, value, offset, 1, 0x7f, -128);\n    if (value < 0) value = 0xff + value + 1;\n    this[offset] = value & 0xff;\n    return offset + 1;\n};\n$0934e0939605d48c$var$Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkInt(this, value, offset, 2, 0x7fff, -32768);\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n    return offset + 2;\n};\n$0934e0939605d48c$var$Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkInt(this, value, offset, 2, 0x7fff, -32768);\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 0xff;\n    return offset + 2;\n};\n$0934e0939605d48c$var$Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n    this[offset + 2] = value >>> 16;\n    this[offset + 3] = value >>> 24;\n    return offset + 4;\n};\n$0934e0939605d48c$var$Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);\n    if (value < 0) value = 0xffffffff + value + 1;\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 0xff;\n    return offset + 4;\n};\n$0934e0939605d48c$var$Buffer.prototype.writeBigInt64LE = $0934e0939605d48c$var$defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {\n    return $0934e0939605d48c$var$wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));\n});\n$0934e0939605d48c$var$Buffer.prototype.writeBigInt64BE = $0934e0939605d48c$var$defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {\n    return $0934e0939605d48c$var$wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));\n});\nfunction $0934e0939605d48c$var$checkIEEE754(buf, value, offset, ext, max, min) {\n    if (offset + ext > buf.length) throw new RangeError('Index out of range');\n    if (offset < 0) throw new RangeError('Index out of range');\n}\nfunction $0934e0939605d48c$var$writeFloat(buf, value, offset, littleEndian, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);\n    $dbnIE.write(buf, value, offset, littleEndian, 23, 4);\n    return offset + 4;\n}\n$0934e0939605d48c$var$Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n    return $0934e0939605d48c$var$writeFloat(this, value, offset, true, noAssert);\n};\n$0934e0939605d48c$var$Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n    return $0934e0939605d48c$var$writeFloat(this, value, offset, false, noAssert);\n};\nfunction $0934e0939605d48c$var$writeDouble(buf, value, offset, littleEndian, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);\n    $dbnIE.write(buf, value, offset, littleEndian, 52, 8);\n    return offset + 8;\n}\n$0934e0939605d48c$var$Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n    return $0934e0939605d48c$var$writeDouble(this, value, offset, true, noAssert);\n};\n$0934e0939605d48c$var$Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n    return $0934e0939605d48c$var$writeDouble(this, value, offset, false, noAssert);\n};\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n$0934e0939605d48c$var$Buffer.prototype.copy = function copy(target, targetStart, start, end) {\n    if (!$0934e0939605d48c$var$Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');\n    if (!start) start = 0;\n    if (!end && end !== 0) end = this.length;\n    if (targetStart >= target.length) targetStart = target.length;\n    if (!targetStart) targetStart = 0;\n    if (end > 0 && end < start) end = start;\n    // Copy 0 bytes; we're done\n    if (end === start) return 0;\n    if (target.length === 0 || this.length === 0) return 0;\n    // Fatal error conditions\n    if (targetStart < 0) throw new RangeError('targetStart out of bounds');\n    if (start < 0 || start >= this.length) throw new RangeError('Index out of range');\n    if (end < 0) throw new RangeError('sourceEnd out of bounds');\n    // Are we oob?\n    if (end > this.length) end = this.length;\n    if (target.length - targetStart < end - start) end = target.length - targetStart + start;\n    const len = end - start;\n    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end);\n    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);\n    return len;\n};\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\n$0934e0939605d48c$var$Buffer.prototype.fill = function fill(val, start, end, encoding) {\n    // Handle string cases:\n    if (typeof val === 'string') {\n        if (typeof start === 'string') {\n            encoding = start;\n            start = 0;\n            end = this.length;\n        } else if (typeof end === 'string') {\n            encoding = end;\n            end = this.length;\n        }\n        if (encoding !== undefined && typeof encoding !== 'string') throw new TypeError('encoding must be a string');\n        if (typeof encoding === 'string' && !$0934e0939605d48c$var$Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);\n        if (val.length === 1) {\n            const code = val.charCodeAt(0);\n            if (encoding === 'utf8' && code < 128 || encoding === 'latin1') // Fast path: If `val` fits into a single byte, use that numeric value.\n            val = code;\n        }\n    } else if (typeof val === 'number') val = val & 255;\n    else if (typeof val === 'boolean') val = Number(val);\n    // Invalid ranges are not set to a default, so can range check early.\n    if (start < 0 || this.length < start || this.length < end) throw new RangeError('Out of range index');\n    if (end <= start) return this;\n    start = start >>> 0;\n    end = end === undefined ? this.length : end >>> 0;\n    if (!val) val = 0;\n    let i;\n    if (typeof val === 'number') for(i = start; i < end; ++i)this[i] = val;\n    else {\n        const bytes = $0934e0939605d48c$var$Buffer.isBuffer(val) ? val : $0934e0939605d48c$var$Buffer.from(val, encoding);\n        const len = bytes.length;\n        if (len === 0) throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];\n    }\n    return this;\n};\n// CUSTOM ERRORS\n// =============\n// Simplified versions from Node, changed for Buffer-only usage\nconst $0934e0939605d48c$var$errors = {};\nfunction $0934e0939605d48c$var$E(sym, getMessage, Base) {\n    $0934e0939605d48c$var$errors[sym] = class NodeError extends Base {\n        constructor(){\n            super();\n            Object.defineProperty(this, 'message', {\n                value: getMessage.apply(this, arguments),\n                writable: true,\n                configurable: true\n            });\n            // Add the error code to the name to include it in the stack trace.\n            this.name = `${this.name} [${sym}]`;\n            // Access the stack to generate the error message including the error code\n            // from the name.\n            this.stack // eslint-disable-line no-unused-expressions\n            ;\n            // Reset the name to the actual name.\n            delete this.name;\n        }\n        get code() {\n            return sym;\n        }\n        set code(value) {\n            Object.defineProperty(this, 'code', {\n                configurable: true,\n                enumerable: true,\n                value: value,\n                writable: true\n            });\n        }\n        toString() {\n            return `${this.name} [${sym}]: ${this.message}`;\n        }\n    };\n}\n$0934e0939605d48c$var$E('ERR_BUFFER_OUT_OF_BOUNDS', function(name) {\n    if (name) return `${name} is outside of buffer bounds`;\n    return 'Attempt to access memory outside buffer bounds';\n}, RangeError);\n$0934e0939605d48c$var$E('ERR_INVALID_ARG_TYPE', function(name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`;\n}, TypeError);\n$0934e0939605d48c$var$E('ERR_OUT_OF_RANGE', function(str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`;\n    let received = input;\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) received = $0934e0939605d48c$var$addNumericalSeparator(String(input));\n    else if (typeof input === 'bigint') {\n        received = String(input);\n        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) received = $0934e0939605d48c$var$addNumericalSeparator(received);\n        received += 'n';\n    }\n    msg += ` It must be ${range}. Received ${received}`;\n    return msg;\n}, RangeError);\nfunction $0934e0939605d48c$var$addNumericalSeparator(val) {\n    let res = '';\n    let i = val.length;\n    const start = val[0] === '-' ? 1 : 0;\n    for(; i >= start + 4; i -= 3)res = `_${val.slice(i - 3, i)}${res}`;\n    return `${val.slice(0, i)}${res}`;\n}\n// CHECK FUNCTIONS\n// ===============\nfunction $0934e0939605d48c$var$checkBounds(buf, offset, byteLength) {\n    $0934e0939605d48c$var$validateNumber(offset, 'offset');\n    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) $0934e0939605d48c$var$boundsError(offset, buf.length - (byteLength + 1));\n}\nfunction $0934e0939605d48c$var$checkIntBI(value, min, max, buf, offset, byteLength) {\n    if (value > max || value < min) {\n        const n = typeof min === 'bigint' ? 'n' : '';\n        let range;\n        if (byteLength > 3) {\n            if (min === 0 || min === BigInt(0)) range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;\n            else range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;\n        } else range = `>= ${min}${n} and <= ${max}${n}`;\n        throw new $0934e0939605d48c$var$errors.ERR_OUT_OF_RANGE('value', range, value);\n    }\n    $0934e0939605d48c$var$checkBounds(buf, offset, byteLength);\n}\nfunction $0934e0939605d48c$var$validateNumber(value, name) {\n    if (typeof value !== 'number') throw new $0934e0939605d48c$var$errors.ERR_INVALID_ARG_TYPE(name, 'number', value);\n}\nfunction $0934e0939605d48c$var$boundsError(value, length, type) {\n    if (Math.floor(value) !== value) {\n        $0934e0939605d48c$var$validateNumber(value, type);\n        throw new $0934e0939605d48c$var$errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);\n    }\n    if (length < 0) throw new $0934e0939605d48c$var$errors.ERR_BUFFER_OUT_OF_BOUNDS();\n    throw new $0934e0939605d48c$var$errors.ERR_OUT_OF_RANGE(type || 'offset', `>= ${type ? 1 : 0} and <= ${length}`, value);\n}\n// HELPER FUNCTIONS\n// ================\nconst $0934e0939605d48c$var$INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\nfunction $0934e0939605d48c$var$base64clean(str) {\n    // Node takes equal signs as end of the Base64 encoding\n    str = str.split('=')[0];\n    // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n    str = str.trim().replace($0934e0939605d48c$var$INVALID_BASE64_RE, '');\n    // Node converts strings with length < 2 to ''\n    if (str.length < 2) return '';\n    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n    while(str.length % 4 !== 0)str = str + '=';\n    return str;\n}\nfunction $0934e0939605d48c$var$utf8ToBytes(string, units) {\n    units = units || Infinity;\n    let codePoint;\n    const length = string.length;\n    let leadSurrogate = null;\n    const bytes = [];\n    for(let i = 0; i < length; ++i){\n        codePoint = string.charCodeAt(i);\n        // is surrogate component\n        if (codePoint > 0xD7FF && codePoint < 0xE000) {\n            // last char was a lead\n            if (!leadSurrogate) {\n                // no lead yet\n                if (codePoint > 0xDBFF) {\n                    // unexpected trail\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                } else if (i + 1 === length) {\n                    // unpaired lead\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                }\n                // valid lead\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // 2 leads in a row\n            if (codePoint < 0xDC00) {\n                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // valid surrogate pair\n            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n        } else if (leadSurrogate) // valid bmp char, but last char was a lead\n        {\n            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        }\n        leadSurrogate = null;\n        // encode utf8\n        if (codePoint < 0x80) {\n            if ((units -= 1) < 0) break;\n            bytes.push(codePoint);\n        } else if (codePoint < 0x800) {\n            if ((units -= 2) < 0) break;\n            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n        } else if (codePoint < 0x10000) {\n            if ((units -= 3) < 0) break;\n            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        } else if (codePoint < 0x110000) {\n            if ((units -= 4) < 0) break;\n            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        } else throw new Error('Invalid code point');\n    }\n    return bytes;\n}\nfunction $0934e0939605d48c$var$asciiToBytes(str) {\n    const byteArray = [];\n    for(let i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF);\n    return byteArray;\n}\nfunction $0934e0939605d48c$var$utf16leToBytes(str, units) {\n    let c, hi, lo;\n    const byteArray = [];\n    for(let i = 0; i < str.length; ++i){\n        if ((units -= 2) < 0) break;\n        c = str.charCodeAt(i);\n        hi = c >> 8;\n        lo = c % 256;\n        byteArray.push(lo);\n        byteArray.push(hi);\n    }\n    return byteArray;\n}\nfunction $0934e0939605d48c$var$base64ToBytes(str) {\n    return $bQMRt.toByteArray($0934e0939605d48c$var$base64clean(str));\n}\nfunction $0934e0939605d48c$var$blitBuffer(src, dst, offset, length) {\n    let i;\n    for(i = 0; i < length; ++i){\n        if (i + offset >= dst.length || i >= src.length) break;\n        dst[i + offset] = src[i];\n    }\n    return i;\n}\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction $0934e0939605d48c$var$isInstance(obj, type) {\n    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n}\nfunction $0934e0939605d48c$var$numberIsNaN(obj) {\n    // For IE11 support\n    return obj !== obj // eslint-disable-line no-self-compare\n    ;\n}\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst $0934e0939605d48c$var$hexSliceLookupTable = function() {\n    const alphabet = '0123456789abcdef';\n    const table = new Array(256);\n    for(let i = 0; i < 16; ++i){\n        const i16 = i * 16;\n        for(let j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];\n    }\n    return table;\n}();\n// Return not function with Error if BigInt not supported\nfunction $0934e0939605d48c$var$defineBigIntMethod(fn) {\n    return typeof BigInt === 'undefined' ? $0934e0939605d48c$var$BufferBigIntNotDefined : fn;\n}\nfunction $0934e0939605d48c$var$BufferBigIntNotDefined() {\n    throw new Error('BigInt not supported');\n}\n\n});\nparcelRegister(\"bQMRt\", function(module, exports) {\n\n$parcel$export(module.exports, \"toByteArray\", () => $8a0a73e6b73fd0c4$export$d622b2ad8d90c771, (v) => $8a0a73e6b73fd0c4$export$d622b2ad8d90c771 = v);\n$parcel$export(module.exports, \"fromByteArray\", () => $8a0a73e6b73fd0c4$export$6100ba28696e12de, (v) => $8a0a73e6b73fd0c4$export$6100ba28696e12de = v);\nvar $8a0a73e6b73fd0c4$export$a48f0734ac7c2329;\nvar $8a0a73e6b73fd0c4$export$d622b2ad8d90c771;\nvar $8a0a73e6b73fd0c4$export$6100ba28696e12de;\n'use strict';\n$8a0a73e6b73fd0c4$export$a48f0734ac7c2329 = $8a0a73e6b73fd0c4$var$byteLength;\n$8a0a73e6b73fd0c4$export$d622b2ad8d90c771 = $8a0a73e6b73fd0c4$var$toByteArray;\n$8a0a73e6b73fd0c4$export$6100ba28696e12de = $8a0a73e6b73fd0c4$var$fromByteArray;\nvar $8a0a73e6b73fd0c4$var$lookup = [];\nvar $8a0a73e6b73fd0c4$var$revLookup = [];\nvar $8a0a73e6b73fd0c4$var$Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\nvar $8a0a73e6b73fd0c4$var$code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nfor(var $8a0a73e6b73fd0c4$var$i = 0, $8a0a73e6b73fd0c4$var$len = $8a0a73e6b73fd0c4$var$code.length; $8a0a73e6b73fd0c4$var$i < $8a0a73e6b73fd0c4$var$len; ++$8a0a73e6b73fd0c4$var$i){\n    $8a0a73e6b73fd0c4$var$lookup[$8a0a73e6b73fd0c4$var$i] = $8a0a73e6b73fd0c4$var$code[$8a0a73e6b73fd0c4$var$i];\n    $8a0a73e6b73fd0c4$var$revLookup[$8a0a73e6b73fd0c4$var$code.charCodeAt($8a0a73e6b73fd0c4$var$i)] = $8a0a73e6b73fd0c4$var$i;\n}\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\n$8a0a73e6b73fd0c4$var$revLookup['-'.charCodeAt(0)] = 62;\n$8a0a73e6b73fd0c4$var$revLookup['_'.charCodeAt(0)] = 63;\nfunction $8a0a73e6b73fd0c4$var$getLens(b64) {\n    var len = b64.length;\n    if (len % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4');\n    // Trim off extra bytes after placeholder bytes are found\n    // See: https://github.com/beatgammit/base64-js/issues/42\n    var validLen = b64.indexOf('=');\n    if (validLen === -1) validLen = len;\n    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n    return [\n        validLen,\n        placeHoldersLen\n    ];\n}\n// base64 is 4/3 + up to two characters of the original data\nfunction $8a0a73e6b73fd0c4$var$byteLength(b64) {\n    var lens = $8a0a73e6b73fd0c4$var$getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\nfunction $8a0a73e6b73fd0c4$var$_byteLength(b64, validLen, placeHoldersLen) {\n    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\nfunction $8a0a73e6b73fd0c4$var$toByteArray(b64) {\n    var tmp;\n    var lens = $8a0a73e6b73fd0c4$var$getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n    var arr = new $8a0a73e6b73fd0c4$var$Arr($8a0a73e6b73fd0c4$var$_byteLength(b64, validLen, placeHoldersLen));\n    var curByte = 0;\n    // if there are placeholders, only get up to the last complete 4 chars\n    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n    var i;\n    for(i = 0; i < len; i += 4){\n        tmp = $8a0a73e6b73fd0c4$var$revLookup[b64.charCodeAt(i)] << 18 | $8a0a73e6b73fd0c4$var$revLookup[b64.charCodeAt(i + 1)] << 12 | $8a0a73e6b73fd0c4$var$revLookup[b64.charCodeAt(i + 2)] << 6 | $8a0a73e6b73fd0c4$var$revLookup[b64.charCodeAt(i + 3)];\n        arr[curByte++] = tmp >> 16 & 0xFF;\n        arr[curByte++] = tmp >> 8 & 0xFF;\n        arr[curByte++] = tmp & 0xFF;\n    }\n    if (placeHoldersLen === 2) {\n        tmp = $8a0a73e6b73fd0c4$var$revLookup[b64.charCodeAt(i)] << 2 | $8a0a73e6b73fd0c4$var$revLookup[b64.charCodeAt(i + 1)] >> 4;\n        arr[curByte++] = tmp & 0xFF;\n    }\n    if (placeHoldersLen === 1) {\n        tmp = $8a0a73e6b73fd0c4$var$revLookup[b64.charCodeAt(i)] << 10 | $8a0a73e6b73fd0c4$var$revLookup[b64.charCodeAt(i + 1)] << 4 | $8a0a73e6b73fd0c4$var$revLookup[b64.charCodeAt(i + 2)] >> 2;\n        arr[curByte++] = tmp >> 8 & 0xFF;\n        arr[curByte++] = tmp & 0xFF;\n    }\n    return arr;\n}\nfunction $8a0a73e6b73fd0c4$var$tripletToBase64(num) {\n    return $8a0a73e6b73fd0c4$var$lookup[num >> 18 & 0x3F] + $8a0a73e6b73fd0c4$var$lookup[num >> 12 & 0x3F] + $8a0a73e6b73fd0c4$var$lookup[num >> 6 & 0x3F] + $8a0a73e6b73fd0c4$var$lookup[num & 0x3F];\n}\nfunction $8a0a73e6b73fd0c4$var$encodeChunk(uint8, start, end) {\n    var tmp;\n    var output = [];\n    for(var i = start; i < end; i += 3){\n        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);\n        output.push($8a0a73e6b73fd0c4$var$tripletToBase64(tmp));\n    }\n    return output.join('');\n}\nfunction $8a0a73e6b73fd0c4$var$fromByteArray(uint8) {\n    var tmp;\n    var len = uint8.length;\n    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n    ;\n    var parts = [];\n    var maxChunkLength = 16383 // must be multiple of 3\n    ;\n    // go through the array every three bytes, we'll deal with trailing stuff later\n    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push($8a0a73e6b73fd0c4$var$encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n    // pad the end with zeros, but make sure to not forget the extra bytes\n    if (extraBytes === 1) {\n        tmp = uint8[len - 1];\n        parts.push($8a0a73e6b73fd0c4$var$lookup[tmp >> 2] + $8a0a73e6b73fd0c4$var$lookup[tmp << 4 & 0x3F] + '==');\n    } else if (extraBytes === 2) {\n        tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n        parts.push($8a0a73e6b73fd0c4$var$lookup[tmp >> 10] + $8a0a73e6b73fd0c4$var$lookup[tmp >> 4 & 0x3F] + $8a0a73e6b73fd0c4$var$lookup[tmp << 2 & 0x3F] + '=');\n    }\n    return parts.join('');\n}\n\n});\n\nparcelRegister(\"dbnIE\", function(module, exports) {\n\n$parcel$export(module.exports, \"read\", () => $998eb38f4d082829$export$aafa59e2e03f2942, (v) => $998eb38f4d082829$export$aafa59e2e03f2942 = v);\n$parcel$export(module.exports, \"write\", () => $998eb38f4d082829$export$68d8715fc104d294, (v) => $998eb38f4d082829$export$68d8715fc104d294 = v);\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ var $998eb38f4d082829$export$aafa59e2e03f2942;\nvar $998eb38f4d082829$export$68d8715fc104d294;\n$998eb38f4d082829$export$aafa59e2e03f2942 = function(buffer, offset, isLE, mLen, nBytes) {\n    var e, m;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var nBits = -7;\n    var i = isLE ? nBytes - 1 : 0;\n    var d = isLE ? -1 : 1;\n    var s = buffer[offset + i];\n    i += d;\n    e = s & (1 << -nBits) - 1;\n    s >>= -nBits;\n    nBits += eLen;\n    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);\n    m = e & (1 << -nBits) - 1;\n    e >>= -nBits;\n    nBits += mLen;\n    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);\n    if (e === 0) e = 1 - eBias;\n    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;\n    else {\n        m = m + Math.pow(2, mLen);\n        e = e - eBias;\n    }\n    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n$998eb38f4d082829$export$68d8715fc104d294 = function(buffer, value, offset, isLE, mLen, nBytes) {\n    var e, m, c;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n    var i = isLE ? 0 : nBytes - 1;\n    var d = isLE ? 1 : -1;\n    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n    value = Math.abs(value);\n    if (isNaN(value) || value === Infinity) {\n        m = isNaN(value) ? 1 : 0;\n        e = eMax;\n    } else {\n        e = Math.floor(Math.log(value) / Math.LN2);\n        if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n        }\n        if (e + eBias >= 1) value += rt / c;\n        else value += rt * Math.pow(2, 1 - eBias);\n        if (value * c >= 2) {\n            e++;\n            c /= 2;\n        }\n        if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n        } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n        } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n        }\n    }\n    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);\n    e = e << mLen | m;\n    eLen += mLen;\n    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);\n    buffer[offset + i - d] |= s * 128;\n};\n\n});\n\n\nparcelRegister(\"adSME\", function(module, exports) {\n'use strict';\n/*\n  This file is a reduced and adapted version of the main lib/internal/util/inspect.js file defined at\n\n  https://github.com/nodejs/node/blob/main/lib/internal/util/inspect.js\n\n  Don't try to replace with the original file and keep it up to date with the upstream file.\n*/ module.exports = {\n    format (format, ...args) {\n        // Simplified version of https://nodejs.org/api/util.html#utilformatformat-args\n        return format.replace(/%([sdifj])/g, function(...[_unused, type]) {\n            const replacement = args.shift();\n            if (type === 'f') return replacement.toFixed(6);\n            else if (type === 'j') return JSON.stringify(replacement);\n            else if (type === 's' && typeof replacement === 'object') {\n                const ctor = replacement.constructor !== Object ? replacement.constructor.name : '';\n                return `${ctor} {}`.trim();\n            } else return replacement.toString();\n        });\n    },\n    inspect (value) {\n        // Vastly simplified version of https://nodejs.org/api/util.html#utilinspectobject-options\n        switch(typeof value){\n            case 'string':\n                if (value.includes(\"'\")) {\n                    if (!value.includes('\"')) return `\"${value}\"`;\n                    else if (!value.includes('`') && !value.includes('${')) return `\\`${value}\\``;\n                }\n                return `'${value}'`;\n            case 'number':\n                if (isNaN(value)) return 'NaN';\n                else if (Object.is(value, -0)) return String(value);\n                return value;\n            case 'bigint':\n                return `${String(value)}n`;\n            case 'boolean':\n            case 'undefined':\n                return String(value);\n            case 'object':\n                return '{}';\n        }\n    }\n};\n\n});\n\nparcelRegister(\"7ynhX\", function(module, exports) {\n'use strict';\n\nvar $adSME = parcelRequire(\"adSME\");\nvar $57fdc603f46fe300$require$format = $adSME.format;\nvar $57fdc603f46fe300$require$inspect = $adSME.inspect;\n\nvar $1by5F = parcelRequire(\"1by5F\");\nvar $57fdc603f46fe300$require$CustomAggregateError = $1by5F.AggregateError;\n/*\n  This file is a reduced and adapted version of the main lib/internal/errors.js file defined at\n\n  https://github.com/nodejs/node/blob/main/lib/internal/errors.js\n\n  Don't try to replace with the original file and keep it up to date (starting from E(...) definitions)\n  with the upstream file.\n*/ const $57fdc603f46fe300$var$AggregateError = globalThis.AggregateError || $57fdc603f46fe300$require$CustomAggregateError;\nconst $57fdc603f46fe300$var$kIsNodeError = Symbol('kIsNodeError');\nconst $57fdc603f46fe300$var$kTypes = [\n    'string',\n    'function',\n    'number',\n    'object',\n    // Accept 'Function' and 'Object' as alternative to the lower cased version.\n    'Function',\n    'Object',\n    'boolean',\n    'bigint',\n    'symbol'\n];\nconst $57fdc603f46fe300$var$classRegExp = /^([A-Z][a-z0-9]*)+$/;\nconst $57fdc603f46fe300$var$nodeInternalPrefix = '__node_internal_';\nconst $57fdc603f46fe300$var$codes = {};\nfunction $57fdc603f46fe300$var$assert(value, message) {\n    if (!value) throw new $57fdc603f46fe300$var$codes.ERR_INTERNAL_ASSERTION(message);\n}\n// Only use this for integers! Decimal numbers do not work with this function.\nfunction $57fdc603f46fe300$var$addNumericalSeparator(val) {\n    let res = '';\n    let i = val.length;\n    const start = val[0] === '-' ? 1 : 0;\n    for(; i >= start + 4; i -= 3)res = `_${val.slice(i - 3, i)}${res}`;\n    return `${val.slice(0, i)}${res}`;\n}\nfunction $57fdc603f46fe300$var$getMessage(key, msg, args) {\n    if (typeof msg === 'function') {\n        $57fdc603f46fe300$var$assert(msg.length <= args.length, // Default options do not count.\n        `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`);\n        return msg(...args);\n    }\n    const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;\n    $57fdc603f46fe300$var$assert(expectedLength === args.length, `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`);\n    if (args.length === 0) return msg;\n    return $57fdc603f46fe300$require$format(msg, ...args);\n}\nfunction $57fdc603f46fe300$var$E(code, message, Base) {\n    if (!Base) Base = Error;\n    class NodeError extends Base {\n        constructor(...args){\n            super($57fdc603f46fe300$var$getMessage(code, message, args));\n        }\n        toString() {\n            return `${this.name} [${code}]: ${this.message}`;\n        }\n    }\n    Object.defineProperties(NodeError.prototype, {\n        name: {\n            value: Base.name,\n            writable: true,\n            enumerable: false,\n            configurable: true\n        },\n        toString: {\n            value () {\n                return `${this.name} [${code}]: ${this.message}`;\n            },\n            writable: true,\n            enumerable: false,\n            configurable: true\n        }\n    });\n    NodeError.prototype.code = code;\n    NodeError.prototype[$57fdc603f46fe300$var$kIsNodeError] = true;\n    $57fdc603f46fe300$var$codes[code] = NodeError;\n}\nfunction $57fdc603f46fe300$var$hideStackFrames(fn) {\n    // We rename the functions that will be hidden to cut off the stacktrace\n    // at the outermost one\n    const hidden = $57fdc603f46fe300$var$nodeInternalPrefix + fn.name;\n    Object.defineProperty(fn, 'name', {\n        value: hidden\n    });\n    return fn;\n}\nfunction $57fdc603f46fe300$var$aggregateTwoErrors(innerError, outerError) {\n    if (innerError && outerError && innerError !== outerError) {\n        if (Array.isArray(outerError.errors)) {\n            // If `outerError` is already an `AggregateError`.\n            outerError.errors.push(innerError);\n            return outerError;\n        }\n        const err = new $57fdc603f46fe300$var$AggregateError([\n            outerError,\n            innerError\n        ], outerError.message);\n        err.code = outerError.code;\n        return err;\n    }\n    return innerError || outerError;\n}\nclass $57fdc603f46fe300$var$AbortError extends Error {\n    constructor(message = 'The operation was aborted', options){\n        if (options !== undefined && typeof options !== 'object') throw new $57fdc603f46fe300$var$codes.ERR_INVALID_ARG_TYPE('options', 'Object', options);\n        super(message, options);\n        this.code = 'ABORT_ERR';\n        this.name = 'AbortError';\n    }\n}\n$57fdc603f46fe300$var$E('ERR_ASSERTION', '%s', Error);\n$57fdc603f46fe300$var$E('ERR_INVALID_ARG_TYPE', (name, expected, actual)=>{\n    $57fdc603f46fe300$var$assert(typeof name === 'string', \"'name' must be a string\");\n    if (!Array.isArray(expected)) expected = [\n        expected\n    ];\n    let msg = 'The ';\n    if (name.endsWith(' argument')) // For cases like 'first argument'\n    msg += `${name} `;\n    else msg += `\"${name}\" ${name.includes('.') ? 'property' : 'argument'} `;\n    msg += 'must be ';\n    const types = [];\n    const instances = [];\n    const other = [];\n    for (const value of expected){\n        $57fdc603f46fe300$var$assert(typeof value === 'string', 'All expected entries have to be of type string');\n        if ($57fdc603f46fe300$var$kTypes.includes(value)) types.push(value.toLowerCase());\n        else if ($57fdc603f46fe300$var$classRegExp.test(value)) instances.push(value);\n        else {\n            $57fdc603f46fe300$var$assert(value !== 'object', 'The value \"object\" should be written as \"Object\"');\n            other.push(value);\n        }\n    }\n    // Special handle `object` in case other instances are allowed to outline\n    // the differences between each other.\n    if (instances.length > 0) {\n        const pos = types.indexOf('object');\n        if (pos !== -1) {\n            types.splice(types, pos, 1);\n            instances.push('Object');\n        }\n    }\n    if (types.length > 0) {\n        switch(types.length){\n            case 1:\n                msg += `of type ${types[0]}`;\n                break;\n            case 2:\n                msg += `one of type ${types[0]} or ${types[1]}`;\n                break;\n            default:\n                {\n                    const last = types.pop();\n                    msg += `one of type ${types.join(', ')}, or ${last}`;\n                }\n        }\n        if (instances.length > 0 || other.length > 0) msg += ' or ';\n    }\n    if (instances.length > 0) {\n        switch(instances.length){\n            case 1:\n                msg += `an instance of ${instances[0]}`;\n                break;\n            case 2:\n                msg += `an instance of ${instances[0]} or ${instances[1]}`;\n                break;\n            default:\n                {\n                    const last = instances.pop();\n                    msg += `an instance of ${instances.join(', ')}, or ${last}`;\n                }\n        }\n        if (other.length > 0) msg += ' or ';\n    }\n    switch(other.length){\n        case 0:\n            break;\n        case 1:\n            if (other[0].toLowerCase() !== other[0]) msg += 'an ';\n            msg += `${other[0]}`;\n            break;\n        case 2:\n            msg += `one of ${other[0]} or ${other[1]}`;\n            break;\n        default:\n            {\n                const last = other.pop();\n                msg += `one of ${other.join(', ')}, or ${last}`;\n            }\n    }\n    if (actual == null) msg += `. Received ${actual}`;\n    else if (typeof actual === 'function' && actual.name) msg += `. Received function ${actual.name}`;\n    else if (typeof actual === 'object') {\n        var _actual$constructor;\n        if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== undefined && _actual$constructor.name) msg += `. Received an instance of ${actual.constructor.name}`;\n        else {\n            const inspected = $57fdc603f46fe300$require$inspect(actual, {\n                depth: -1\n            });\n            msg += `. Received ${inspected}`;\n        }\n    } else {\n        let inspected = $57fdc603f46fe300$require$inspect(actual, {\n            colors: false\n        });\n        if (inspected.length > 25) inspected = `${inspected.slice(0, 25)}...`;\n        msg += `. Received type ${typeof actual} (${inspected})`;\n    }\n    return msg;\n}, TypeError);\n$57fdc603f46fe300$var$E('ERR_INVALID_ARG_VALUE', (name, value, reason = 'is invalid')=>{\n    let inspected = $57fdc603f46fe300$require$inspect(value);\n    if (inspected.length > 128) inspected = inspected.slice(0, 128) + '...';\n    const type = name.includes('.') ? 'property' : 'argument';\n    return `The ${type} '${name}' ${reason}. Received ${inspected}`;\n}, TypeError);\n$57fdc603f46fe300$var$E('ERR_INVALID_RETURN_VALUE', (input, name, value)=>{\n    var _value$constructor;\n    const type = value !== null && value !== undefined && (_value$constructor = value.constructor) !== null && _value$constructor !== undefined && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;\n    return `Expected ${input} to be returned from the \"${name}\"` + ` function but got ${type}.`;\n}, TypeError);\n$57fdc603f46fe300$var$E('ERR_MISSING_ARGS', (...args)=>{\n    $57fdc603f46fe300$var$assert(args.length > 0, 'At least one arg needs to be specified');\n    let msg;\n    const len = args.length;\n    args = (Array.isArray(args) ? args : [\n        args\n    ]).map((a)=>`\"${a}\"`).join(' or ');\n    switch(len){\n        case 1:\n            msg += `The ${args[0]} argument`;\n            break;\n        case 2:\n            msg += `The ${args[0]} and ${args[1]} arguments`;\n            break;\n        default:\n            {\n                const last = args.pop();\n                msg += `The ${args.join(', ')}, and ${last} arguments`;\n            }\n            break;\n    }\n    return `${msg} must be specified`;\n}, TypeError);\n$57fdc603f46fe300$var$E('ERR_OUT_OF_RANGE', (str, range, input)=>{\n    $57fdc603f46fe300$var$assert(range, 'Missing \"range\" argument');\n    let received;\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) received = $57fdc603f46fe300$var$addNumericalSeparator(String(input));\n    else if (typeof input === 'bigint') {\n        received = String(input);\n        const limit = BigInt(2) ** BigInt(32);\n        if (input > limit || input < -limit) received = $57fdc603f46fe300$var$addNumericalSeparator(received);\n        received += 'n';\n    } else received = $57fdc603f46fe300$require$inspect(input);\n    return `The value of \"${str}\" is out of range. It must be ${range}. Received ${received}`;\n}, RangeError);\n$57fdc603f46fe300$var$E('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times', Error);\n$57fdc603f46fe300$var$E('ERR_METHOD_NOT_IMPLEMENTED', 'The %s method is not implemented', Error);\n$57fdc603f46fe300$var$E('ERR_STREAM_ALREADY_FINISHED', 'Cannot call %s after a stream was finished', Error);\n$57fdc603f46fe300$var$E('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable', Error);\n$57fdc603f46fe300$var$E('ERR_STREAM_DESTROYED', 'Cannot call %s after a stream was destroyed', Error);\n$57fdc603f46fe300$var$E('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);\n$57fdc603f46fe300$var$E('ERR_STREAM_PREMATURE_CLOSE', 'Premature close', Error);\n$57fdc603f46fe300$var$E('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF', Error);\n$57fdc603f46fe300$var$E('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event', Error);\n$57fdc603f46fe300$var$E('ERR_STREAM_WRITE_AFTER_END', 'write after end', Error);\n$57fdc603f46fe300$var$E('ERR_UNKNOWN_ENCODING', 'Unknown encoding: %s', TypeError);\nmodule.exports = {\n    AbortError: $57fdc603f46fe300$var$AbortError,\n    aggregateTwoErrors: $57fdc603f46fe300$var$hideStackFrames($57fdc603f46fe300$var$aggregateTwoErrors),\n    hideStackFrames: $57fdc603f46fe300$var$hideStackFrames,\n    codes: $57fdc603f46fe300$var$codes\n};\n\n});\n\nparcelRegister(\"5zWM9\", function(module, exports) {\n/*globals self, window */ \"use strict\";\n/*eslint-disable @mysticatea/prettier */ const { AbortController: $40fdd0443eb0b6e5$var$AbortController, AbortSignal: $40fdd0443eb0b6e5$var$AbortSignal } = typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : /* otherwise */ undefined;\n/*eslint-enable @mysticatea/prettier */ module.exports = $40fdd0443eb0b6e5$var$AbortController;\nmodule.exports.AbortSignal = $40fdd0443eb0b6e5$var$AbortSignal;\nmodule.exports.default = $40fdd0443eb0b6e5$var$AbortController;\n\n});\n\nparcelRegister(\"9sqfU\", function(module, exports) {\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n'use strict';\nvar $6e2b186194ca9ee7$var$R = typeof Reflect === 'object' ? Reflect : null;\nvar $6e2b186194ca9ee7$var$ReflectApply = $6e2b186194ca9ee7$var$R && typeof $6e2b186194ca9ee7$var$R.apply === 'function' ? $6e2b186194ca9ee7$var$R.apply : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n};\nvar $6e2b186194ca9ee7$var$ReflectOwnKeys;\nif ($6e2b186194ca9ee7$var$R && typeof $6e2b186194ca9ee7$var$R.ownKeys === 'function') $6e2b186194ca9ee7$var$ReflectOwnKeys = $6e2b186194ca9ee7$var$R.ownKeys;\nelse if (Object.getOwnPropertySymbols) $6e2b186194ca9ee7$var$ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n};\nelse $6e2b186194ca9ee7$var$ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n};\nfunction $6e2b186194ca9ee7$var$ProcessEmitWarning(warning) {\n    if (console && console.warn) console.warn(warning);\n}\nvar $6e2b186194ca9ee7$var$NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n    return value !== value;\n};\nfunction $6e2b186194ca9ee7$var$EventEmitter() {\n    $6e2b186194ca9ee7$var$EventEmitter.init.call(this);\n}\nmodule.exports = $6e2b186194ca9ee7$var$EventEmitter;\nmodule.exports.once = $6e2b186194ca9ee7$var$once;\n// Backwards-compat with node 0.10.x\n$6e2b186194ca9ee7$var$EventEmitter.EventEmitter = $6e2b186194ca9ee7$var$EventEmitter;\n$6e2b186194ca9ee7$var$EventEmitter.prototype._events = undefined;\n$6e2b186194ca9ee7$var$EventEmitter.prototype._eventsCount = 0;\n$6e2b186194ca9ee7$var$EventEmitter.prototype._maxListeners = undefined;\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar $6e2b186194ca9ee7$var$defaultMaxListeners = 10;\nfunction $6e2b186194ca9ee7$var$checkListener(listener) {\n    if (typeof listener !== 'function') throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n}\nObject.defineProperty($6e2b186194ca9ee7$var$EventEmitter, 'defaultMaxListeners', {\n    enumerable: true,\n    get: function() {\n        return $6e2b186194ca9ee7$var$defaultMaxListeners;\n    },\n    set: function(arg) {\n        if (typeof arg !== 'number' || arg < 0 || $6e2b186194ca9ee7$var$NumberIsNaN(arg)) throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n        $6e2b186194ca9ee7$var$defaultMaxListeners = arg;\n    }\n});\n$6e2b186194ca9ee7$var$EventEmitter.init = function() {\n    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n    }\n    this._maxListeners = this._maxListeners || undefined;\n};\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\n$6e2b186194ca9ee7$var$EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n    if (typeof n !== 'number' || n < 0 || $6e2b186194ca9ee7$var$NumberIsNaN(n)) throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n    this._maxListeners = n;\n    return this;\n};\nfunction $6e2b186194ca9ee7$var$_getMaxListeners(that) {\n    if (that._maxListeners === undefined) return $6e2b186194ca9ee7$var$EventEmitter.defaultMaxListeners;\n    return that._maxListeners;\n}\n$6e2b186194ca9ee7$var$EventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n    return $6e2b186194ca9ee7$var$_getMaxListeners(this);\n};\n$6e2b186194ca9ee7$var$EventEmitter.prototype.emit = function emit(type) {\n    var args = [];\n    for(var i = 1; i < arguments.length; i++)args.push(arguments[i]);\n    var doError = type === 'error';\n    var events = this._events;\n    if (events !== undefined) doError = doError && events.error === undefined;\n    else if (!doError) return false;\n    // If there is no 'error' event listener then throw.\n    if (doError) {\n        var er;\n        if (args.length > 0) er = args[0];\n        if (er instanceof Error) // Note: The comments on the `throw` lines are intentional, they show\n        // up in Node's output if this results in an unhandled exception.\n        throw er; // Unhandled 'error' event\n        // At least give some kind of context to the user\n        var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n        err.context = er;\n        throw err; // Unhandled 'error' event\n    }\n    var handler = events[type];\n    if (handler === undefined) return false;\n    if (typeof handler === 'function') $6e2b186194ca9ee7$var$ReflectApply(handler, this, args);\n    else {\n        var len = handler.length;\n        var listeners = $6e2b186194ca9ee7$var$arrayClone(handler, len);\n        for(var i = 0; i < len; ++i)$6e2b186194ca9ee7$var$ReflectApply(listeners[i], this, args);\n    }\n    return true;\n};\nfunction $6e2b186194ca9ee7$var$_addListener(target, type, listener, prepend) {\n    var m;\n    var events;\n    var existing;\n    $6e2b186194ca9ee7$var$checkListener(listener);\n    events = target._events;\n    if (events === undefined) {\n        events = target._events = Object.create(null);\n        target._eventsCount = 0;\n    } else {\n        // To avoid recursion in the case that type === \"newListener\"! Before\n        // adding it to the listeners, first emit \"newListener\".\n        if (events.newListener !== undefined) {\n            target.emit('newListener', type, listener.listener ? listener.listener : listener);\n            // Re-assign `events` because a newListener handler could have caused the\n            // this._events to be assigned to a new object\n            events = target._events;\n        }\n        existing = events[type];\n    }\n    if (existing === undefined) {\n        // Optimize the case of one listener. Don't need the extra array object.\n        existing = events[type] = listener;\n        ++target._eventsCount;\n    } else {\n        if (typeof existing === 'function') // Adding the second element, need to change to array.\n        existing = events[type] = prepend ? [\n            listener,\n            existing\n        ] : [\n            existing,\n            listener\n        ];\n        else if (prepend) existing.unshift(listener);\n        else existing.push(listener);\n        // Check for listener leak\n        m = $6e2b186194ca9ee7$var$_getMaxListeners(target);\n        if (m > 0 && existing.length > m && !existing.warned) {\n            existing.warned = true;\n            // No error code for this since it is a Warning\n            // eslint-disable-next-line no-restricted-syntax\n            var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');\n            w.name = 'MaxListenersExceededWarning';\n            w.emitter = target;\n            w.type = type;\n            w.count = existing.length;\n            $6e2b186194ca9ee7$var$ProcessEmitWarning(w);\n        }\n    }\n    return target;\n}\n$6e2b186194ca9ee7$var$EventEmitter.prototype.addListener = function addListener(type, listener) {\n    return $6e2b186194ca9ee7$var$_addListener(this, type, listener, false);\n};\n$6e2b186194ca9ee7$var$EventEmitter.prototype.on = $6e2b186194ca9ee7$var$EventEmitter.prototype.addListener;\n$6e2b186194ca9ee7$var$EventEmitter.prototype.prependListener = function prependListener(type, listener) {\n    return $6e2b186194ca9ee7$var$_addListener(this, type, listener, true);\n};\nfunction $6e2b186194ca9ee7$var$onceWrapper() {\n    if (!this.fired) {\n        this.target.removeListener(this.type, this.wrapFn);\n        this.fired = true;\n        if (arguments.length === 0) return this.listener.call(this.target);\n        return this.listener.apply(this.target, arguments);\n    }\n}\nfunction $6e2b186194ca9ee7$var$_onceWrap(target, type, listener) {\n    var state = {\n        fired: false,\n        wrapFn: undefined,\n        target: target,\n        type: type,\n        listener: listener\n    };\n    var wrapped = $6e2b186194ca9ee7$var$onceWrapper.bind(state);\n    wrapped.listener = listener;\n    state.wrapFn = wrapped;\n    return wrapped;\n}\n$6e2b186194ca9ee7$var$EventEmitter.prototype.once = function once(type, listener) {\n    $6e2b186194ca9ee7$var$checkListener(listener);\n    this.on(type, $6e2b186194ca9ee7$var$_onceWrap(this, type, listener));\n    return this;\n};\n$6e2b186194ca9ee7$var$EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n    $6e2b186194ca9ee7$var$checkListener(listener);\n    this.prependListener(type, $6e2b186194ca9ee7$var$_onceWrap(this, type, listener));\n    return this;\n};\n// Emits a 'removeListener' event if and only if the listener was removed.\n$6e2b186194ca9ee7$var$EventEmitter.prototype.removeListener = function removeListener(type, listener) {\n    var list, events, position, i, originalListener;\n    $6e2b186194ca9ee7$var$checkListener(listener);\n    events = this._events;\n    if (events === undefined) return this;\n    list = events[type];\n    if (list === undefined) return this;\n    if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0) this._events = Object.create(null);\n        else {\n            delete events[type];\n            if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n        }\n    } else if (typeof list !== 'function') {\n        position = -1;\n        for(i = list.length - 1; i >= 0; i--)if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n        }\n        if (position < 0) return this;\n        if (position === 0) list.shift();\n        else $6e2b186194ca9ee7$var$spliceOne(list, position);\n        if (list.length === 1) events[type] = list[0];\n        if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);\n    }\n    return this;\n};\n$6e2b186194ca9ee7$var$EventEmitter.prototype.off = $6e2b186194ca9ee7$var$EventEmitter.prototype.removeListener;\n$6e2b186194ca9ee7$var$EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n    var listeners, events, i;\n    events = this._events;\n    if (events === undefined) return this;\n    // not listening for removeListener, no need to emit\n    if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n            this._events = Object.create(null);\n            this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n            if (--this._eventsCount === 0) this._events = Object.create(null);\n            else delete events[type];\n        }\n        return this;\n    }\n    // emit removeListener for all listeners on all events\n    if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for(i = 0; i < keys.length; ++i){\n            key = keys[i];\n            if (key === 'removeListener') continue;\n            this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n    }\n    listeners = events[type];\n    if (typeof listeners === 'function') this.removeListener(type, listeners);\n    else if (listeners !== undefined) // LIFO order\n    for(i = listeners.length - 1; i >= 0; i--)this.removeListener(type, listeners[i]);\n    return this;\n};\nfunction $6e2b186194ca9ee7$var$_listeners(target, type, unwrap) {\n    var events = target._events;\n    if (events === undefined) return [];\n    var evlistener = events[type];\n    if (evlistener === undefined) return [];\n    if (typeof evlistener === 'function') return unwrap ? [\n        evlistener.listener || evlistener\n    ] : [\n        evlistener\n    ];\n    return unwrap ? $6e2b186194ca9ee7$var$unwrapListeners(evlistener) : $6e2b186194ca9ee7$var$arrayClone(evlistener, evlistener.length);\n}\n$6e2b186194ca9ee7$var$EventEmitter.prototype.listeners = function listeners(type) {\n    return $6e2b186194ca9ee7$var$_listeners(this, type, true);\n};\n$6e2b186194ca9ee7$var$EventEmitter.prototype.rawListeners = function rawListeners(type) {\n    return $6e2b186194ca9ee7$var$_listeners(this, type, false);\n};\n$6e2b186194ca9ee7$var$EventEmitter.listenerCount = function(emitter, type) {\n    if (typeof emitter.listenerCount === 'function') return emitter.listenerCount(type);\n    else return $6e2b186194ca9ee7$var$listenerCount.call(emitter, type);\n};\n$6e2b186194ca9ee7$var$EventEmitter.prototype.listenerCount = $6e2b186194ca9ee7$var$listenerCount;\nfunction $6e2b186194ca9ee7$var$listenerCount(type) {\n    var events = this._events;\n    if (events !== undefined) {\n        var evlistener = events[type];\n        if (typeof evlistener === 'function') return 1;\n        else if (evlistener !== undefined) return evlistener.length;\n    }\n    return 0;\n}\n$6e2b186194ca9ee7$var$EventEmitter.prototype.eventNames = function eventNames() {\n    return this._eventsCount > 0 ? $6e2b186194ca9ee7$var$ReflectOwnKeys(this._events) : [];\n};\nfunction $6e2b186194ca9ee7$var$arrayClone(arr, n) {\n    var copy = new Array(n);\n    for(var i = 0; i < n; ++i)copy[i] = arr[i];\n    return copy;\n}\nfunction $6e2b186194ca9ee7$var$spliceOne(list, index) {\n    for(; index + 1 < list.length; index++)list[index] = list[index + 1];\n    list.pop();\n}\nfunction $6e2b186194ca9ee7$var$unwrapListeners(arr) {\n    var ret = new Array(arr.length);\n    for(var i = 0; i < ret.length; ++i)ret[i] = arr[i].listener || arr[i];\n    return ret;\n}\nfunction $6e2b186194ca9ee7$var$once(emitter, name) {\n    return new Promise(function(resolve, reject) {\n        function errorListener(err) {\n            emitter.removeListener(name, resolver);\n            reject(err);\n        }\n        function resolver() {\n            if (typeof emitter.removeListener === 'function') emitter.removeListener('error', errorListener);\n            resolve([].slice.call(arguments));\n        }\n        $6e2b186194ca9ee7$var$eventTargetAgnosticAddListener(emitter, name, resolver, {\n            once: true\n        });\n        if (name !== 'error') $6e2b186194ca9ee7$var$addErrorHandlerIfEventEmitter(emitter, errorListener, {\n            once: true\n        });\n    });\n}\nfunction $6e2b186194ca9ee7$var$addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n    if (typeof emitter.on === 'function') $6e2b186194ca9ee7$var$eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n}\nfunction $6e2b186194ca9ee7$var$eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n    if (typeof emitter.on === 'function') {\n        if (flags.once) emitter.once(name, listener);\n        else emitter.on(name, listener);\n    } else if (typeof emitter.addEventListener === 'function') // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n        // IE does not have builtin `{ once: true }` support so we\n        // have to do it manually.\n        if (flags.once) emitter.removeEventListener(name, wrapListener);\n        listener(arg);\n    });\n    else throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n}\n\n});\n\n\nparcelRegister(\"lyuEd\", function(module, exports) {\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototype inheritance, this class\n// prototypically inherits from Readable, and then parasitically from\n// Writable.\n'use strict';\n\nvar $1by5F = parcelRequire(\"1by5F\");\nvar $fb148bf0ab02793c$require$ObjectDefineProperties = $1by5F.ObjectDefineProperties;\nvar $fb148bf0ab02793c$require$ObjectGetOwnPropertyDescriptor = $1by5F.ObjectGetOwnPropertyDescriptor;\nvar $fb148bf0ab02793c$require$ObjectKeys = $1by5F.ObjectKeys;\nvar $fb148bf0ab02793c$require$ObjectSetPrototypeOf = $1by5F.ObjectSetPrototypeOf;\nmodule.exports = $fb148bf0ab02793c$var$Duplex;\n\nvar $c6GJA = parcelRequire(\"c6GJA\");\n\nvar $95yXm = parcelRequire(\"95yXm\");\n$fb148bf0ab02793c$require$ObjectSetPrototypeOf($fb148bf0ab02793c$var$Duplex.prototype, $c6GJA.prototype);\n$fb148bf0ab02793c$require$ObjectSetPrototypeOf($fb148bf0ab02793c$var$Duplex, $c6GJA);\n{\n    const keys = $fb148bf0ab02793c$require$ObjectKeys($95yXm.prototype);\n    // Allow the keys array to be GC'ed.\n    for(let i = 0; i < keys.length; i++){\n        const method = keys[i];\n        if (!$fb148bf0ab02793c$var$Duplex.prototype[method]) $fb148bf0ab02793c$var$Duplex.prototype[method] = $95yXm.prototype[method];\n    }\n}function $fb148bf0ab02793c$var$Duplex(options) {\n    if (!(this instanceof $fb148bf0ab02793c$var$Duplex)) return new $fb148bf0ab02793c$var$Duplex(options);\n    $c6GJA.call(this, options);\n    $95yXm.call(this, options);\n    if (options) {\n        this.allowHalfOpen = options.allowHalfOpen !== false;\n        if (options.readable === false) {\n            this._readableState.readable = false;\n            this._readableState.ended = true;\n            this._readableState.endEmitted = true;\n        }\n        if (options.writable === false) {\n            this._writableState.writable = false;\n            this._writableState.ending = true;\n            this._writableState.ended = true;\n            this._writableState.finished = true;\n        }\n    } else this.allowHalfOpen = true;\n}\n$fb148bf0ab02793c$require$ObjectDefineProperties($fb148bf0ab02793c$var$Duplex.prototype, {\n    writable: {\n        __proto__: null,\n        ...$fb148bf0ab02793c$require$ObjectGetOwnPropertyDescriptor($95yXm.prototype, 'writable')\n    },\n    writableHighWaterMark: {\n        __proto__: null,\n        ...$fb148bf0ab02793c$require$ObjectGetOwnPropertyDescriptor($95yXm.prototype, 'writableHighWaterMark')\n    },\n    writableObjectMode: {\n        __proto__: null,\n        ...$fb148bf0ab02793c$require$ObjectGetOwnPropertyDescriptor($95yXm.prototype, 'writableObjectMode')\n    },\n    writableBuffer: {\n        __proto__: null,\n        ...$fb148bf0ab02793c$require$ObjectGetOwnPropertyDescriptor($95yXm.prototype, 'writableBuffer')\n    },\n    writableLength: {\n        __proto__: null,\n        ...$fb148bf0ab02793c$require$ObjectGetOwnPropertyDescriptor($95yXm.prototype, 'writableLength')\n    },\n    writableFinished: {\n        __proto__: null,\n        ...$fb148bf0ab02793c$require$ObjectGetOwnPropertyDescriptor($95yXm.prototype, 'writableFinished')\n    },\n    writableCorked: {\n        __proto__: null,\n        ...$fb148bf0ab02793c$require$ObjectGetOwnPropertyDescriptor($95yXm.prototype, 'writableCorked')\n    },\n    writableEnded: {\n        __proto__: null,\n        ...$fb148bf0ab02793c$require$ObjectGetOwnPropertyDescriptor($95yXm.prototype, 'writableEnded')\n    },\n    writableNeedDrain: {\n        __proto__: null,\n        ...$fb148bf0ab02793c$require$ObjectGetOwnPropertyDescriptor($95yXm.prototype, 'writableNeedDrain')\n    },\n    destroyed: {\n        __proto__: null,\n        get () {\n            if (this._readableState === undefined || this._writableState === undefined) return false;\n            return this._readableState.destroyed && this._writableState.destroyed;\n        },\n        set (value) {\n            // Backward compatibility, the user is explicitly\n            // managing destroyed.\n            if (this._readableState && this._writableState) {\n                this._readableState.destroyed = value;\n                this._writableState.destroyed = value;\n            }\n        }\n    }\n});\nlet $fb148bf0ab02793c$var$webStreamsAdapters;\n// Lazy to avoid circular references\nfunction $fb148bf0ab02793c$var$lazyWebStreams() {\n    if ($fb148bf0ab02793c$var$webStreamsAdapters === undefined) $fb148bf0ab02793c$var$webStreamsAdapters = {};\n    return $fb148bf0ab02793c$var$webStreamsAdapters;\n}\n$fb148bf0ab02793c$var$Duplex.fromWeb = function(pair, options) {\n    return $fb148bf0ab02793c$var$lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);\n};\n$fb148bf0ab02793c$var$Duplex.toWeb = function(duplex) {\n    return $fb148bf0ab02793c$var$lazyWebStreams().newReadableWritablePairFromDuplex(duplex);\n};\nlet $fb148bf0ab02793c$var$duplexify;\n\n$fb148bf0ab02793c$var$Duplex.from = function(body) {\n    if (!$fb148bf0ab02793c$var$duplexify) $fb148bf0ab02793c$var$duplexify = (parcelRequire(\"kUcKi\"));\n    return $fb148bf0ab02793c$var$duplexify(body, 'body');\n};\n\n});\nparcelRegister(\"c6GJA\", function(module, exports) {\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n'use strict';\n\nvar $ibaza = parcelRequire(\"ibaza\");\n\nvar $1by5F = parcelRequire(\"1by5F\");\nvar $8d0731bae61c46b3$require$ArrayPrototypeIndexOf = $1by5F.ArrayPrototypeIndexOf;\nvar $8d0731bae61c46b3$require$NumberIsInteger = $1by5F.NumberIsInteger;\nvar $8d0731bae61c46b3$require$NumberIsNaN = $1by5F.NumberIsNaN;\nvar $8d0731bae61c46b3$require$NumberParseInt = $1by5F.NumberParseInt;\nvar $8d0731bae61c46b3$require$ObjectDefineProperties = $1by5F.ObjectDefineProperties;\nvar $8d0731bae61c46b3$require$ObjectKeys = $1by5F.ObjectKeys;\nvar $8d0731bae61c46b3$require$ObjectSetPrototypeOf = $1by5F.ObjectSetPrototypeOf;\nvar $8d0731bae61c46b3$require$Promise = $1by5F.Promise;\nvar $8d0731bae61c46b3$require$SafeSet = $1by5F.SafeSet;\nvar $8d0731bae61c46b3$require$SymbolAsyncDispose = $1by5F.SymbolAsyncDispose;\nvar $8d0731bae61c46b3$require$SymbolAsyncIterator = $1by5F.SymbolAsyncIterator;\nvar $8d0731bae61c46b3$require$Symbol = $1by5F.Symbol;\nmodule.exports = $8d0731bae61c46b3$var$Readable;\n$8d0731bae61c46b3$var$Readable.ReadableState = $8d0731bae61c46b3$var$ReadableState;\n\nvar $9sqfU = parcelRequire(\"9sqfU\");\nvar $8d0731bae61c46b3$require$EE = $9sqfU.EventEmitter;\n\nvar $1Tt4D = parcelRequire(\"1Tt4D\");\nvar $8d0731bae61c46b3$require$Stream = $1Tt4D.Stream;\nvar $8d0731bae61c46b3$require$prependListener = $1Tt4D.prependListener;\n\nvar $N0o3H = parcelRequire(\"N0o3H\");\nvar $8d0731bae61c46b3$require$Buffer = $N0o3H.Buffer;\n\nvar $6ASt2 = parcelRequire(\"6ASt2\");\nvar $8d0731bae61c46b3$require$addAbortSignal = $6ASt2.addAbortSignal;\n\nvar $9RUbc = parcelRequire(\"9RUbc\");\n\nlet $8d0731bae61c46b3$var$debug = (parcelRequire(\"kDFyU\")).debuglog('stream', (fn)=>{\n    $8d0731bae61c46b3$var$debug = fn;\n});\n\nvar $ikZyt = parcelRequire(\"ikZyt\");\n\nvar $7CELW = parcelRequire(\"7CELW\");\n\nvar $bKeTG = parcelRequire(\"bKeTG\");\nvar $8d0731bae61c46b3$require$getHighWaterMark = $bKeTG.getHighWaterMark;\nvar $8d0731bae61c46b3$require$getDefaultHighWaterMark = $bKeTG.getDefaultHighWaterMark;\n\nvar $7ynhX = parcelRequire(\"7ynhX\");\nconst { aggregateTwoErrors: $8d0731bae61c46b3$var$aggregateTwoErrors, codes: { ERR_INVALID_ARG_TYPE: $8d0731bae61c46b3$var$ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED: $8d0731bae61c46b3$var$ERR_METHOD_NOT_IMPLEMENTED, ERR_OUT_OF_RANGE: $8d0731bae61c46b3$var$ERR_OUT_OF_RANGE, ERR_STREAM_PUSH_AFTER_EOF: $8d0731bae61c46b3$var$ERR_STREAM_PUSH_AFTER_EOF, ERR_STREAM_UNSHIFT_AFTER_END_EVENT: $8d0731bae61c46b3$var$ERR_STREAM_UNSHIFT_AFTER_END_EVENT }, AbortError: $8d0731bae61c46b3$var$AbortError } = $7ynhX;\n\nvar $geuoF = parcelRequire(\"geuoF\");\nvar $8d0731bae61c46b3$require$validateObject = $geuoF.validateObject;\nconst $8d0731bae61c46b3$var$kPaused = $8d0731bae61c46b3$require$Symbol('kPaused');\n\nvar $jJ0xG = parcelRequire(\"jJ0xG\");\nvar $8d0731bae61c46b3$require$StringDecoder = $jJ0xG.StringDecoder;\n\nvar $ixzpt = parcelRequire(\"ixzpt\");\n$8d0731bae61c46b3$require$ObjectSetPrototypeOf($8d0731bae61c46b3$var$Readable.prototype, $8d0731bae61c46b3$require$Stream.prototype);\n$8d0731bae61c46b3$require$ObjectSetPrototypeOf($8d0731bae61c46b3$var$Readable, $8d0731bae61c46b3$require$Stream);\nconst $8d0731bae61c46b3$var$nop = ()=>{};\nconst { errorOrDestroy: $8d0731bae61c46b3$var$errorOrDestroy } = $7CELW;\nconst $8d0731bae61c46b3$var$kObjectMode = 1;\nconst $8d0731bae61c46b3$var$kEnded = 2;\nconst $8d0731bae61c46b3$var$kEndEmitted = 4;\nconst $8d0731bae61c46b3$var$kReading = 8;\nconst $8d0731bae61c46b3$var$kConstructed = 16;\nconst $8d0731bae61c46b3$var$kSync = 32;\nconst $8d0731bae61c46b3$var$kNeedReadable = 64;\nconst $8d0731bae61c46b3$var$kEmittedReadable = 128;\nconst $8d0731bae61c46b3$var$kReadableListening = 256;\nconst $8d0731bae61c46b3$var$kResumeScheduled = 512;\nconst $8d0731bae61c46b3$var$kErrorEmitted = 1024;\nconst $8d0731bae61c46b3$var$kEmitClose = 2048;\nconst $8d0731bae61c46b3$var$kAutoDestroy = 4096;\nconst $8d0731bae61c46b3$var$kDestroyed = 8192;\nconst $8d0731bae61c46b3$var$kClosed = 16384;\nconst $8d0731bae61c46b3$var$kCloseEmitted = 32768;\nconst $8d0731bae61c46b3$var$kMultiAwaitDrain = 65536;\nconst $8d0731bae61c46b3$var$kReadingMore = 131072;\nconst $8d0731bae61c46b3$var$kDataEmitted = 262144;\n// TODO(benjamingr) it is likely slower to do it this way than with free functions\nfunction $8d0731bae61c46b3$var$makeBitMapDescriptor(bit) {\n    return {\n        enumerable: false,\n        get () {\n            return (this.state & bit) !== 0;\n        },\n        set (value) {\n            if (value) this.state |= bit;\n            else this.state &= ~bit;\n        }\n    };\n}\n$8d0731bae61c46b3$require$ObjectDefineProperties($8d0731bae61c46b3$var$ReadableState.prototype, {\n    objectMode: $8d0731bae61c46b3$var$makeBitMapDescriptor($8d0731bae61c46b3$var$kObjectMode),\n    ended: $8d0731bae61c46b3$var$makeBitMapDescriptor($8d0731bae61c46b3$var$kEnded),\n    endEmitted: $8d0731bae61c46b3$var$makeBitMapDescriptor($8d0731bae61c46b3$var$kEndEmitted),\n    reading: $8d0731bae61c46b3$var$makeBitMapDescriptor($8d0731bae61c46b3$var$kReading),\n    // Stream is still being constructed and cannot be\n    // destroyed until construction finished or failed.\n    // Async construction is opt in, therefore we start as\n    // constructed.\n    constructed: $8d0731bae61c46b3$var$makeBitMapDescriptor($8d0731bae61c46b3$var$kConstructed),\n    // A flag to be able to tell if the event 'readable'/'data' is emitted\n    // immediately, or on a later tick.  We set this to true at first, because\n    // any actions that shouldn't happen until \"later\" should generally also\n    // not happen before the first read call.\n    sync: $8d0731bae61c46b3$var$makeBitMapDescriptor($8d0731bae61c46b3$var$kSync),\n    // Whenever we return null, then we set a flag to say\n    // that we're awaiting a 'readable' event emission.\n    needReadable: $8d0731bae61c46b3$var$makeBitMapDescriptor($8d0731bae61c46b3$var$kNeedReadable),\n    emittedReadable: $8d0731bae61c46b3$var$makeBitMapDescriptor($8d0731bae61c46b3$var$kEmittedReadable),\n    readableListening: $8d0731bae61c46b3$var$makeBitMapDescriptor($8d0731bae61c46b3$var$kReadableListening),\n    resumeScheduled: $8d0731bae61c46b3$var$makeBitMapDescriptor($8d0731bae61c46b3$var$kResumeScheduled),\n    // True if the error was already emitted and should not be thrown again.\n    errorEmitted: $8d0731bae61c46b3$var$makeBitMapDescriptor($8d0731bae61c46b3$var$kErrorEmitted),\n    emitClose: $8d0731bae61c46b3$var$makeBitMapDescriptor($8d0731bae61c46b3$var$kEmitClose),\n    autoDestroy: $8d0731bae61c46b3$var$makeBitMapDescriptor($8d0731bae61c46b3$var$kAutoDestroy),\n    // Has it been destroyed.\n    destroyed: $8d0731bae61c46b3$var$makeBitMapDescriptor($8d0731bae61c46b3$var$kDestroyed),\n    // Indicates whether the stream has finished destroying.\n    closed: $8d0731bae61c46b3$var$makeBitMapDescriptor($8d0731bae61c46b3$var$kClosed),\n    // True if close has been emitted or would have been emitted\n    // depending on emitClose.\n    closeEmitted: $8d0731bae61c46b3$var$makeBitMapDescriptor($8d0731bae61c46b3$var$kCloseEmitted),\n    multiAwaitDrain: $8d0731bae61c46b3$var$makeBitMapDescriptor($8d0731bae61c46b3$var$kMultiAwaitDrain),\n    // If true, a maybeReadMore has been scheduled.\n    readingMore: $8d0731bae61c46b3$var$makeBitMapDescriptor($8d0731bae61c46b3$var$kReadingMore),\n    dataEmitted: $8d0731bae61c46b3$var$makeBitMapDescriptor($8d0731bae61c46b3$var$kDataEmitted)\n});\n\nfunction $8d0731bae61c46b3$var$ReadableState(options, stream, isDuplex) {\n    // Duplex streams are both readable and writable, but share\n    // the same options object.\n    // However, some cases require setting options to different\n    // values for the readable and the writable sides of the duplex stream.\n    // These options can be provided separately as readableXXX and writableXXX.\n    if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof (parcelRequire(\"lyuEd\"));\n    // Bit map field to store ReadableState more effciently with 1 bit per field\n    // instead of a V8 slot per field.\n    this.state = $8d0731bae61c46b3$var$kEmitClose | $8d0731bae61c46b3$var$kAutoDestroy | $8d0731bae61c46b3$var$kConstructed | $8d0731bae61c46b3$var$kSync;\n    // Object stream flag. Used to make read(n) ignore n and to\n    // make all the buffer merging and length checks go away.\n    if (options && options.objectMode) this.state |= $8d0731bae61c46b3$var$kObjectMode;\n    if (isDuplex && options && options.readableObjectMode) this.state |= $8d0731bae61c46b3$var$kObjectMode;\n    // The point at which it stops calling _read() to fill the buffer\n    // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n    this.highWaterMark = options ? $8d0731bae61c46b3$require$getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex) : $8d0731bae61c46b3$require$getDefaultHighWaterMark(false);\n    // A linked list is used to store data chunks instead of an array because the\n    // linked list can remove elements from the beginning faster than\n    // array.shift().\n    this.buffer = new $ikZyt();\n    this.length = 0;\n    this.pipes = [];\n    this.flowing = null;\n    this[$8d0731bae61c46b3$var$kPaused] = null;\n    // Should close be emitted on destroy. Defaults to true.\n    if (options && options.emitClose === false) this.state &= ~$8d0731bae61c46b3$var$kEmitClose;\n    // Should .destroy() be called after 'end' (and potentially 'finish').\n    if (options && options.autoDestroy === false) this.state &= ~$8d0731bae61c46b3$var$kAutoDestroy;\n    // Indicates whether the stream has errored. When true no further\n    // _read calls, 'data' or 'readable' events should occur. This is needed\n    // since when autoDestroy is disabled we need a way to tell whether the\n    // stream has failed.\n    this.errored = null;\n    // Crypto is kind of old and crusty.  Historically, its default string\n    // encoding is 'binary' so we have to make this configurable.\n    // Everything else in the universe uses 'utf8', though.\n    this.defaultEncoding = options && options.defaultEncoding || 'utf8';\n    // Ref the piped dest which we need a drain event on it\n    // type: null | Writable | Set<Writable>.\n    this.awaitDrainWriters = null;\n    this.decoder = null;\n    this.encoding = null;\n    if (options && options.encoding) {\n        this.decoder = new $8d0731bae61c46b3$require$StringDecoder(options.encoding);\n        this.encoding = options.encoding;\n    }\n}\n\nfunction $8d0731bae61c46b3$var$Readable(options) {\n    if (!(this instanceof $8d0731bae61c46b3$var$Readable)) return new $8d0731bae61c46b3$var$Readable(options);\n    // Checking for a Stream.Duplex instance is faster here instead of inside\n    // the ReadableState constructor, at least with V8 6.5.\n    const isDuplex = this instanceof (parcelRequire(\"lyuEd\"));\n    this._readableState = new $8d0731bae61c46b3$var$ReadableState(options, this, isDuplex);\n    if (options) {\n        if (typeof options.read === 'function') this._read = options.read;\n        if (typeof options.destroy === 'function') this._destroy = options.destroy;\n        if (typeof options.construct === 'function') this._construct = options.construct;\n        if (options.signal && !isDuplex) $8d0731bae61c46b3$require$addAbortSignal(options.signal, this);\n    }\n    $8d0731bae61c46b3$require$Stream.call(this, options);\n    $7CELW.construct(this, ()=>{\n        if (this._readableState.needReadable) $8d0731bae61c46b3$var$maybeReadMore(this, this._readableState);\n    });\n}\n$8d0731bae61c46b3$var$Readable.prototype.destroy = $7CELW.destroy;\n$8d0731bae61c46b3$var$Readable.prototype._undestroy = $7CELW.undestroy;\n$8d0731bae61c46b3$var$Readable.prototype._destroy = function(err, cb) {\n    cb(err);\n};\n$8d0731bae61c46b3$var$Readable.prototype[$8d0731bae61c46b3$require$EE.captureRejectionSymbol] = function(err) {\n    this.destroy(err);\n};\n$8d0731bae61c46b3$var$Readable.prototype[$8d0731bae61c46b3$require$SymbolAsyncDispose] = function() {\n    let error;\n    if (!this.destroyed) {\n        error = this.readableEnded ? null : new $8d0731bae61c46b3$var$AbortError();\n        this.destroy(error);\n    }\n    return new $8d0731bae61c46b3$require$Promise((resolve, reject)=>$9RUbc(this, (err)=>err && err !== error ? reject(err) : resolve(null)));\n};\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\n$8d0731bae61c46b3$var$Readable.prototype.push = function(chunk, encoding) {\n    return $8d0731bae61c46b3$var$readableAddChunk(this, chunk, encoding, false);\n};\n// Unshift should *always* be something directly out of read().\n$8d0731bae61c46b3$var$Readable.prototype.unshift = function(chunk, encoding) {\n    return $8d0731bae61c46b3$var$readableAddChunk(this, chunk, encoding, true);\n};\nfunction $8d0731bae61c46b3$var$readableAddChunk(stream, chunk, encoding, addToFront) {\n    $8d0731bae61c46b3$var$debug('readableAddChunk', chunk);\n    const state = stream._readableState;\n    let err;\n    if ((state.state & $8d0731bae61c46b3$var$kObjectMode) === 0) {\n        if (typeof chunk === 'string') {\n            encoding = encoding || state.defaultEncoding;\n            if (state.encoding !== encoding) {\n                if (addToFront && state.encoding) // When unshifting, if state.encoding is set, we have to save\n                // the string in the BufferList with the state encoding.\n                chunk = $8d0731bae61c46b3$require$Buffer.from(chunk, encoding).toString(state.encoding);\n                else {\n                    chunk = $8d0731bae61c46b3$require$Buffer.from(chunk, encoding);\n                    encoding = '';\n                }\n            }\n        } else if (chunk instanceof $8d0731bae61c46b3$require$Buffer) encoding = '';\n        else if ($8d0731bae61c46b3$require$Stream._isUint8Array(chunk)) {\n            chunk = $8d0731bae61c46b3$require$Stream._uint8ArrayToBuffer(chunk);\n            encoding = '';\n        } else if (chunk != null) err = new $8d0731bae61c46b3$var$ERR_INVALID_ARG_TYPE('chunk', [\n            'string',\n            'Buffer',\n            'Uint8Array'\n        ], chunk);\n    }\n    if (err) $8d0731bae61c46b3$var$errorOrDestroy(stream, err);\n    else if (chunk === null) {\n        state.state &= ~$8d0731bae61c46b3$var$kReading;\n        $8d0731bae61c46b3$var$onEofChunk(stream, state);\n    } else if ((state.state & $8d0731bae61c46b3$var$kObjectMode) !== 0 || chunk && chunk.length > 0) {\n        if (addToFront) {\n            if ((state.state & $8d0731bae61c46b3$var$kEndEmitted) !== 0) $8d0731bae61c46b3$var$errorOrDestroy(stream, new $8d0731bae61c46b3$var$ERR_STREAM_UNSHIFT_AFTER_END_EVENT());\n            else if (state.destroyed || state.errored) return false;\n            else $8d0731bae61c46b3$var$addChunk(stream, state, chunk, true);\n        } else if (state.ended) $8d0731bae61c46b3$var$errorOrDestroy(stream, new $8d0731bae61c46b3$var$ERR_STREAM_PUSH_AFTER_EOF());\n        else if (state.destroyed || state.errored) return false;\n        else {\n            state.state &= ~$8d0731bae61c46b3$var$kReading;\n            if (state.decoder && !encoding) {\n                chunk = state.decoder.write(chunk);\n                if (state.objectMode || chunk.length !== 0) $8d0731bae61c46b3$var$addChunk(stream, state, chunk, false);\n                else $8d0731bae61c46b3$var$maybeReadMore(stream, state);\n            } else $8d0731bae61c46b3$var$addChunk(stream, state, chunk, false);\n        }\n    } else if (!addToFront) {\n        state.state &= ~$8d0731bae61c46b3$var$kReading;\n        $8d0731bae61c46b3$var$maybeReadMore(stream, state);\n    }\n    // We can push more data if we are below the highWaterMark.\n    // Also, if we have no data yet, we can stand some more bytes.\n    // This is to work around cases where hwm=0, such as the repl.\n    return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\nfunction $8d0731bae61c46b3$var$addChunk(stream, state, chunk, addToFront) {\n    if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount('data') > 0) {\n        // Use the guard to avoid creating `Set()` repeatedly\n        // when we have multiple pipes.\n        if ((state.state & $8d0731bae61c46b3$var$kMultiAwaitDrain) !== 0) state.awaitDrainWriters.clear();\n        else state.awaitDrainWriters = null;\n        state.dataEmitted = true;\n        stream.emit('data', chunk);\n    } else {\n        // Update the buffer info.\n        state.length += state.objectMode ? 1 : chunk.length;\n        if (addToFront) state.buffer.unshift(chunk);\n        else state.buffer.push(chunk);\n        if ((state.state & $8d0731bae61c46b3$var$kNeedReadable) !== 0) $8d0731bae61c46b3$var$emitReadable(stream);\n    }\n    $8d0731bae61c46b3$var$maybeReadMore(stream, state);\n}\n$8d0731bae61c46b3$var$Readable.prototype.isPaused = function() {\n    const state = this._readableState;\n    return state[$8d0731bae61c46b3$var$kPaused] === true || state.flowing === false;\n};\n// Backwards compatibility.\n$8d0731bae61c46b3$var$Readable.prototype.setEncoding = function(enc) {\n    const decoder = new $8d0731bae61c46b3$require$StringDecoder(enc);\n    this._readableState.decoder = decoder;\n    // If setEncoding(null), decoder.encoding equals utf8.\n    this._readableState.encoding = this._readableState.decoder.encoding;\n    const buffer = this._readableState.buffer;\n    // Iterate over current buffer to convert already stored Buffers:\n    let content = '';\n    for (const data of buffer)content += decoder.write(data);\n    buffer.clear();\n    if (content !== '') buffer.push(content);\n    this._readableState.length = content.length;\n    return this;\n};\n// Don't raise the hwm > 1GB.\nconst $8d0731bae61c46b3$var$MAX_HWM = 0x40000000;\nfunction $8d0731bae61c46b3$var$computeNewHighWaterMark(n) {\n    if (n > $8d0731bae61c46b3$var$MAX_HWM) throw new $8d0731bae61c46b3$var$ERR_OUT_OF_RANGE('size', '<= 1GiB', n);\n    else {\n        // Get the next highest power of 2 to prevent increasing hwm excessively in\n        // tiny amounts.\n        n--;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        n++;\n    }\n    return n;\n}\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction $8d0731bae61c46b3$var$howMuchToRead(n, state) {\n    if (n <= 0 || state.length === 0 && state.ended) return 0;\n    if ((state.state & $8d0731bae61c46b3$var$kObjectMode) !== 0) return 1;\n    if ($8d0731bae61c46b3$require$NumberIsNaN(n)) {\n        // Only flow one buffer at a time.\n        if (state.flowing && state.length) return state.buffer.first().length;\n        return state.length;\n    }\n    if (n <= state.length) return n;\n    return state.ended ? state.length : 0;\n}\n// You can override either this method, or the async _read(n) below.\n$8d0731bae61c46b3$var$Readable.prototype.read = function(n) {\n    $8d0731bae61c46b3$var$debug('read', n);\n    // Same as parseInt(undefined, 10), however V8 7.3 performance regressed\n    // in this scenario, so we are doing it manually.\n    if (n === undefined) n = NaN;\n    else if (!$8d0731bae61c46b3$require$NumberIsInteger(n)) n = $8d0731bae61c46b3$require$NumberParseInt(n, 10);\n    const state = this._readableState;\n    const nOrig = n;\n    // If we're asking for more than the current hwm, then raise the hwm.\n    if (n > state.highWaterMark) state.highWaterMark = $8d0731bae61c46b3$var$computeNewHighWaterMark(n);\n    if (n !== 0) state.state &= ~$8d0731bae61c46b3$var$kEmittedReadable;\n    // If we're doing read(0) to trigger a readable event, but we\n    // already have a bunch of data in the buffer, then just trigger\n    // the 'readable' event and move on.\n    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n        $8d0731bae61c46b3$var$debug('read: emitReadable', state.length, state.ended);\n        if (state.length === 0 && state.ended) $8d0731bae61c46b3$var$endReadable(this);\n        else $8d0731bae61c46b3$var$emitReadable(this);\n        return null;\n    }\n    n = $8d0731bae61c46b3$var$howMuchToRead(n, state);\n    // If we've ended, and we're now clear, then finish it up.\n    if (n === 0 && state.ended) {\n        if (state.length === 0) $8d0731bae61c46b3$var$endReadable(this);\n        return null;\n    }\n    // All the actual chunk generation logic needs to be\n    // *below* the call to _read.  The reason is that in certain\n    // synthetic stream cases, such as passthrough streams, _read\n    // may be a completely synchronous operation which may change\n    // the state of the read buffer, providing enough data when\n    // before there was *not* enough.\n    //\n    // So, the steps are:\n    // 1. Figure out what the state of things will be after we do\n    // a read from the buffer.\n    //\n    // 2. If that resulting state will trigger a _read, then call _read.\n    // Note that this may be asynchronous, or synchronous.  Yes, it is\n    // deeply ugly to write APIs this way, but that still doesn't mean\n    // that the Readable class should behave improperly, as streams are\n    // designed to be sync/async agnostic.\n    // Take note if the _read call is sync or async (ie, if the read call\n    // has returned yet), so that we know whether or not it's safe to emit\n    // 'readable' etc.\n    //\n    // 3. Actually pull the requested chunks out of the buffer and return.\n    // if we need a readable event, then we need to do some reading.\n    let doRead = (state.state & $8d0731bae61c46b3$var$kNeedReadable) !== 0;\n    $8d0731bae61c46b3$var$debug('need readable', doRead);\n    // If we currently have less than the highWaterMark, then also read some.\n    if (state.length === 0 || state.length - n < state.highWaterMark) {\n        doRead = true;\n        $8d0731bae61c46b3$var$debug('length less than watermark', doRead);\n    }\n    // However, if we've ended, then there's no point, if we're already\n    // reading, then it's unnecessary, if we're constructing we have to wait,\n    // and if we're destroyed or errored, then it's not allowed,\n    if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {\n        doRead = false;\n        $8d0731bae61c46b3$var$debug('reading, ended or constructing', doRead);\n    } else if (doRead) {\n        $8d0731bae61c46b3$var$debug('do read');\n        state.state |= $8d0731bae61c46b3$var$kReading | $8d0731bae61c46b3$var$kSync;\n        // If the length is currently zero, then we *need* a readable event.\n        if (state.length === 0) state.state |= $8d0731bae61c46b3$var$kNeedReadable;\n        // Call internal read method\n        try {\n            this._read(state.highWaterMark);\n        } catch (err) {\n            $8d0731bae61c46b3$var$errorOrDestroy(this, err);\n        }\n        state.state &= ~$8d0731bae61c46b3$var$kSync;\n        // If _read pushed data synchronously, then `reading` will be false,\n        // and we need to re-evaluate how much data we can return to the user.\n        if (!state.reading) n = $8d0731bae61c46b3$var$howMuchToRead(nOrig, state);\n    }\n    let ret;\n    if (n > 0) ret = $8d0731bae61c46b3$var$fromList(n, state);\n    else ret = null;\n    if (ret === null) {\n        state.needReadable = state.length <= state.highWaterMark;\n        n = 0;\n    } else {\n        state.length -= n;\n        if (state.multiAwaitDrain) state.awaitDrainWriters.clear();\n        else state.awaitDrainWriters = null;\n    }\n    if (state.length === 0) {\n        // If we have nothing in the buffer, then we want to know\n        // as soon as we *do* get something into the buffer.\n        if (!state.ended) state.needReadable = true;\n        // If we tried to read() past the EOF, then emit end on the next tick.\n        if (nOrig !== n && state.ended) $8d0731bae61c46b3$var$endReadable(this);\n    }\n    if (ret !== null && !state.errorEmitted && !state.closeEmitted) {\n        state.dataEmitted = true;\n        this.emit('data', ret);\n    }\n    return ret;\n};\nfunction $8d0731bae61c46b3$var$onEofChunk(stream, state) {\n    $8d0731bae61c46b3$var$debug('onEofChunk');\n    if (state.ended) return;\n    if (state.decoder) {\n        const chunk = state.decoder.end();\n        if (chunk && chunk.length) {\n            state.buffer.push(chunk);\n            state.length += state.objectMode ? 1 : chunk.length;\n        }\n    }\n    state.ended = true;\n    if (state.sync) // If we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call.\n    $8d0731bae61c46b3$var$emitReadable(stream);\n    else {\n        // Emit 'readable' now to make sure it gets picked up.\n        state.needReadable = false;\n        state.emittedReadable = true;\n        // We have to emit readable now that we are EOF. Modules\n        // in the ecosystem (e.g. dicer) rely on this event being sync.\n        $8d0731bae61c46b3$var$emitReadable_(stream);\n    }\n}\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction $8d0731bae61c46b3$var$emitReadable(stream) {\n    const state = stream._readableState;\n    $8d0731bae61c46b3$var$debug('emitReadable', state.needReadable, state.emittedReadable);\n    state.needReadable = false;\n    if (!state.emittedReadable) {\n        $8d0731bae61c46b3$var$debug('emitReadable', state.flowing);\n        state.emittedReadable = true;\n        $ibaza.nextTick($8d0731bae61c46b3$var$emitReadable_, stream);\n    }\n}\nfunction $8d0731bae61c46b3$var$emitReadable_(stream) {\n    const state = stream._readableState;\n    $8d0731bae61c46b3$var$debug('emitReadable_', state.destroyed, state.length, state.ended);\n    if (!state.destroyed && !state.errored && (state.length || state.ended)) {\n        stream.emit('readable');\n        state.emittedReadable = false;\n    }\n    // The stream needs another readable event if:\n    // 1. It is not flowing, as the flow mechanism will take\n    //    care of it.\n    // 2. It is not ended.\n    // 3. It is below the highWaterMark, so we can schedule\n    //    another readable later.\n    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n    $8d0731bae61c46b3$var$flow(stream);\n}\n// At this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction $8d0731bae61c46b3$var$maybeReadMore(stream, state) {\n    if (!state.readingMore && state.constructed) {\n        state.readingMore = true;\n        $ibaza.nextTick($8d0731bae61c46b3$var$maybeReadMore_, stream, state);\n    }\n}\nfunction $8d0731bae61c46b3$var$maybeReadMore_(stream, state) {\n    // Attempt to read more data if we should.\n    //\n    // The conditions for reading more data are (one of):\n    // - Not enough data buffered (state.length < state.highWaterMark). The loop\n    //   is responsible for filling the buffer with enough data if such data\n    //   is available. If highWaterMark is 0 and we are not in the flowing mode\n    //   we should _not_ attempt to buffer any extra data. We'll get more data\n    //   when the stream consumer calls read() instead.\n    // - No data in the buffer, and the stream is in flowing mode. In this mode\n    //   the loop below is responsible for ensuring read() is called. Failing to\n    //   call read here would abort the flow and there's no other mechanism for\n    //   continuing the flow if the stream consumer has just subscribed to the\n    //   'data' event.\n    //\n    // In addition to the above conditions to keep reading data, the following\n    // conditions prevent the data from being read:\n    // - The stream has ended (state.ended).\n    // - There is already a pending 'read' operation (state.reading). This is a\n    //   case where the stream has called the implementation defined _read()\n    //   method, but they are processing the call asynchronously and have _not_\n    //   called push() with new data. In this case we skip performing more\n    //   read()s. The execution ends in this method again after the _read() ends\n    //   up calling push() with more data.\n    while(!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)){\n        const len = state.length;\n        $8d0731bae61c46b3$var$debug('maybeReadMore read 0');\n        stream.read(0);\n        if (len === state.length) break;\n    }\n    state.readingMore = false;\n}\n// Abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\n$8d0731bae61c46b3$var$Readable.prototype._read = function(n) {\n    throw new $8d0731bae61c46b3$var$ERR_METHOD_NOT_IMPLEMENTED('_read()');\n};\n$8d0731bae61c46b3$var$Readable.prototype.pipe = function(dest, pipeOpts) {\n    const src = this;\n    const state = this._readableState;\n    if (state.pipes.length === 1) {\n        if (!state.multiAwaitDrain) {\n            state.multiAwaitDrain = true;\n            state.awaitDrainWriters = new $8d0731bae61c46b3$require$SafeSet(state.awaitDrainWriters ? [\n                state.awaitDrainWriters\n            ] : []);\n        }\n    }\n    state.pipes.push(dest);\n    $8d0731bae61c46b3$var$debug('pipe count=%d opts=%j', state.pipes.length, pipeOpts);\n    const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== $ibaza.stdout && dest !== $ibaza.stderr;\n    const endFn = doEnd ? onend : unpipe;\n    if (state.endEmitted) $ibaza.nextTick(endFn);\n    else src.once('end', endFn);\n    dest.on('unpipe', onunpipe);\n    function onunpipe(readable, unpipeInfo) {\n        $8d0731bae61c46b3$var$debug('onunpipe');\n        if (readable === src) {\n            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n                unpipeInfo.hasUnpiped = true;\n                cleanup();\n            }\n        }\n    }\n    function onend() {\n        $8d0731bae61c46b3$var$debug('onend');\n        dest.end();\n    }\n    let ondrain;\n    let cleanedUp = false;\n    function cleanup() {\n        $8d0731bae61c46b3$var$debug('cleanup');\n        // Cleanup event handlers once the pipe is broken.\n        dest.removeListener('close', onclose);\n        dest.removeListener('finish', onfinish);\n        if (ondrain) dest.removeListener('drain', ondrain);\n        dest.removeListener('error', onerror);\n        dest.removeListener('unpipe', onunpipe);\n        src.removeListener('end', onend);\n        src.removeListener('end', unpipe);\n        src.removeListener('data', ondata);\n        cleanedUp = true;\n        // If the reader is waiting for a drain event from this\n        // specific writer, then it would cause it to never start\n        // flowing again.\n        // So, if this is awaiting a drain, then we just call it now.\n        // If we don't know, then assume that we are waiting for one.\n        if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n    }\n    function pause() {\n        // If the user unpiped during `dest.write()`, it is possible\n        // to get stuck in a permanently paused state if that write\n        // also returned false.\n        // => Check whether `dest` is still a piping destination.\n        if (!cleanedUp) {\n            if (state.pipes.length === 1 && state.pipes[0] === dest) {\n                $8d0731bae61c46b3$var$debug('false write response, pause', 0);\n                state.awaitDrainWriters = dest;\n                state.multiAwaitDrain = false;\n            } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {\n                $8d0731bae61c46b3$var$debug('false write response, pause', state.awaitDrainWriters.size);\n                state.awaitDrainWriters.add(dest);\n            }\n            src.pause();\n        }\n        if (!ondrain) {\n            // When the dest drains, it reduces the awaitDrain counter\n            // on the source.  This would be more elegant with a .once()\n            // handler in flow(), but adding and removing repeatedly is\n            // too slow.\n            ondrain = $8d0731bae61c46b3$var$pipeOnDrain(src, dest);\n            dest.on('drain', ondrain);\n        }\n    }\n    src.on('data', ondata);\n    function ondata(chunk) {\n        $8d0731bae61c46b3$var$debug('ondata');\n        const ret = dest.write(chunk);\n        $8d0731bae61c46b3$var$debug('dest.write', ret);\n        if (ret === false) pause();\n    }\n    // If the dest has an error, then stop piping into it.\n    // However, don't suppress the throwing behavior for this.\n    function onerror(er) {\n        $8d0731bae61c46b3$var$debug('onerror', er);\n        unpipe();\n        dest.removeListener('error', onerror);\n        if (dest.listenerCount('error') === 0) {\n            const s = dest._writableState || dest._readableState;\n            if (s && !s.errorEmitted) // User incorrectly emitted 'error' directly on the stream.\n            $8d0731bae61c46b3$var$errorOrDestroy(dest, er);\n            else dest.emit('error', er);\n        }\n    }\n    // Make sure our error handler is attached before userland ones.\n    $8d0731bae61c46b3$require$prependListener(dest, 'error', onerror);\n    // Both close and finish should trigger unpipe, but only once.\n    function onclose() {\n        dest.removeListener('finish', onfinish);\n        unpipe();\n    }\n    dest.once('close', onclose);\n    function onfinish() {\n        $8d0731bae61c46b3$var$debug('onfinish');\n        dest.removeListener('close', onclose);\n        unpipe();\n    }\n    dest.once('finish', onfinish);\n    function unpipe() {\n        $8d0731bae61c46b3$var$debug('unpipe');\n        src.unpipe(dest);\n    }\n    // Tell the dest that it's being piped to.\n    dest.emit('pipe', src);\n    // Start the flow if it hasn't been started already.\n    if (dest.writableNeedDrain === true) pause();\n    else if (!state.flowing) {\n        $8d0731bae61c46b3$var$debug('pipe resume');\n        src.resume();\n    }\n    return dest;\n};\nfunction $8d0731bae61c46b3$var$pipeOnDrain(src, dest) {\n    return function pipeOnDrainFunctionResult() {\n        const state = src._readableState;\n        // `ondrain` will call directly,\n        // `this` maybe not a reference to dest,\n        // so we use the real dest here.\n        if (state.awaitDrainWriters === dest) {\n            $8d0731bae61c46b3$var$debug('pipeOnDrain', 1);\n            state.awaitDrainWriters = null;\n        } else if (state.multiAwaitDrain) {\n            $8d0731bae61c46b3$var$debug('pipeOnDrain', state.awaitDrainWriters.size);\n            state.awaitDrainWriters.delete(dest);\n        }\n        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount('data')) src.resume();\n    };\n}\n$8d0731bae61c46b3$var$Readable.prototype.unpipe = function(dest) {\n    const state = this._readableState;\n    const unpipeInfo = {\n        hasUnpiped: false\n    };\n    // If we're not piping anywhere, then do nothing.\n    if (state.pipes.length === 0) return this;\n    if (!dest) {\n        // remove all.\n        const dests = state.pipes;\n        state.pipes = [];\n        this.pause();\n        for(let i = 0; i < dests.length; i++)dests[i].emit('unpipe', this, {\n            hasUnpiped: false\n        });\n        return this;\n    }\n    // Try to find the right one.\n    const index = $8d0731bae61c46b3$require$ArrayPrototypeIndexOf(state.pipes, dest);\n    if (index === -1) return this;\n    state.pipes.splice(index, 1);\n    if (state.pipes.length === 0) this.pause();\n    dest.emit('unpipe', this, unpipeInfo);\n    return this;\n};\n// Set up data events if they are asked for\n// Ensure readable listeners eventually get something.\n$8d0731bae61c46b3$var$Readable.prototype.on = function(ev, fn) {\n    const res = $8d0731bae61c46b3$require$Stream.prototype.on.call(this, ev, fn);\n    const state = this._readableState;\n    if (ev === 'data') {\n        // Update readableListening so that resume() may be a no-op\n        // a few lines down. This is needed to support once('readable').\n        state.readableListening = this.listenerCount('readable') > 0;\n        // Try start flowing on next tick if stream isn't explicitly paused.\n        if (state.flowing !== false) this.resume();\n    } else if (ev === 'readable') {\n        if (!state.endEmitted && !state.readableListening) {\n            state.readableListening = state.needReadable = true;\n            state.flowing = false;\n            state.emittedReadable = false;\n            $8d0731bae61c46b3$var$debug('on readable', state.length, state.reading);\n            if (state.length) $8d0731bae61c46b3$var$emitReadable(this);\n            else if (!state.reading) $ibaza.nextTick($8d0731bae61c46b3$var$nReadingNextTick, this);\n        }\n    }\n    return res;\n};\n$8d0731bae61c46b3$var$Readable.prototype.addListener = $8d0731bae61c46b3$var$Readable.prototype.on;\n$8d0731bae61c46b3$var$Readable.prototype.removeListener = function(ev, fn) {\n    const res = $8d0731bae61c46b3$require$Stream.prototype.removeListener.call(this, ev, fn);\n    if (ev === 'readable') // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    $ibaza.nextTick($8d0731bae61c46b3$var$updateReadableListening, this);\n    return res;\n};\n$8d0731bae61c46b3$var$Readable.prototype.off = $8d0731bae61c46b3$var$Readable.prototype.removeListener;\n$8d0731bae61c46b3$var$Readable.prototype.removeAllListeners = function(ev) {\n    const res = $8d0731bae61c46b3$require$Stream.prototype.removeAllListeners.apply(this, arguments);\n    if (ev === 'readable' || ev === undefined) // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    $ibaza.nextTick($8d0731bae61c46b3$var$updateReadableListening, this);\n    return res;\n};\nfunction $8d0731bae61c46b3$var$updateReadableListening(self) {\n    const state = self._readableState;\n    state.readableListening = self.listenerCount('readable') > 0;\n    if (state.resumeScheduled && state[$8d0731bae61c46b3$var$kPaused] === false) // Flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true;\n    else if (self.listenerCount('data') > 0) self.resume();\n    else if (!state.readableListening) state.flowing = null;\n}\nfunction $8d0731bae61c46b3$var$nReadingNextTick(self) {\n    $8d0731bae61c46b3$var$debug('readable nexttick read 0');\n    self.read(0);\n}\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\n$8d0731bae61c46b3$var$Readable.prototype.resume = function() {\n    const state = this._readableState;\n    if (!state.flowing) {\n        $8d0731bae61c46b3$var$debug('resume');\n        // We flow only if there is no one listening\n        // for readable, but we still have to call\n        // resume().\n        state.flowing = !state.readableListening;\n        $8d0731bae61c46b3$var$resume(this, state);\n    }\n    state[$8d0731bae61c46b3$var$kPaused] = false;\n    return this;\n};\nfunction $8d0731bae61c46b3$var$resume(stream, state) {\n    if (!state.resumeScheduled) {\n        state.resumeScheduled = true;\n        $ibaza.nextTick($8d0731bae61c46b3$var$resume_, stream, state);\n    }\n}\nfunction $8d0731bae61c46b3$var$resume_(stream, state) {\n    $8d0731bae61c46b3$var$debug('resume', state.reading);\n    if (!state.reading) stream.read(0);\n    state.resumeScheduled = false;\n    stream.emit('resume');\n    $8d0731bae61c46b3$var$flow(stream);\n    if (state.flowing && !state.reading) stream.read(0);\n}\n$8d0731bae61c46b3$var$Readable.prototype.pause = function() {\n    $8d0731bae61c46b3$var$debug('call pause flowing=%j', this._readableState.flowing);\n    if (this._readableState.flowing !== false) {\n        $8d0731bae61c46b3$var$debug('pause');\n        this._readableState.flowing = false;\n        this.emit('pause');\n    }\n    this._readableState[$8d0731bae61c46b3$var$kPaused] = true;\n    return this;\n};\nfunction $8d0731bae61c46b3$var$flow(stream) {\n    const state = stream._readableState;\n    $8d0731bae61c46b3$var$debug('flow', state.flowing);\n    while(state.flowing && stream.read() !== null);\n}\n// Wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\n$8d0731bae61c46b3$var$Readable.prototype.wrap = function(stream) {\n    let paused = false;\n    // TODO (ronag): Should this.destroy(err) emit\n    // 'error' on the wrapped stream? Would require\n    // a static factory method, e.g. Readable.wrap(stream).\n    stream.on('data', (chunk)=>{\n        if (!this.push(chunk) && stream.pause) {\n            paused = true;\n            stream.pause();\n        }\n    });\n    stream.on('end', ()=>{\n        this.push(null);\n    });\n    stream.on('error', (err)=>{\n        $8d0731bae61c46b3$var$errorOrDestroy(this, err);\n    });\n    stream.on('close', ()=>{\n        this.destroy();\n    });\n    stream.on('destroy', ()=>{\n        this.destroy();\n    });\n    this._read = ()=>{\n        if (paused && stream.resume) {\n            paused = false;\n            stream.resume();\n        }\n    };\n    // Proxy all the other methods. Important when wrapping filters and duplexes.\n    const streamKeys = $8d0731bae61c46b3$require$ObjectKeys(stream);\n    for(let j = 1; j < streamKeys.length; j++){\n        const i = streamKeys[j];\n        if (this[i] === undefined && typeof stream[i] === 'function') this[i] = stream[i].bind(stream);\n    }\n    return this;\n};\n$8d0731bae61c46b3$var$Readable.prototype[$8d0731bae61c46b3$require$SymbolAsyncIterator] = function() {\n    return $8d0731bae61c46b3$var$streamToAsyncIterator(this);\n};\n$8d0731bae61c46b3$var$Readable.prototype.iterator = function(options) {\n    if (options !== undefined) $8d0731bae61c46b3$require$validateObject(options, 'options');\n    return $8d0731bae61c46b3$var$streamToAsyncIterator(this, options);\n};\nfunction $8d0731bae61c46b3$var$streamToAsyncIterator(stream, options) {\n    if (typeof stream.read !== 'function') stream = $8d0731bae61c46b3$var$Readable.wrap(stream, {\n        objectMode: true\n    });\n    const iter = $8d0731bae61c46b3$var$createAsyncIterator(stream, options);\n    iter.stream = stream;\n    return iter;\n}\nasync function* $8d0731bae61c46b3$var$createAsyncIterator(stream, options) {\n    let callback = $8d0731bae61c46b3$var$nop;\n    function next(resolve) {\n        if (this === stream) {\n            callback();\n            callback = $8d0731bae61c46b3$var$nop;\n        } else callback = resolve;\n    }\n    stream.on('readable', next);\n    let error;\n    const cleanup = $9RUbc(stream, {\n        writable: false\n    }, (err)=>{\n        error = err ? $8d0731bae61c46b3$var$aggregateTwoErrors(error, err) : null;\n        callback();\n        callback = $8d0731bae61c46b3$var$nop;\n    });\n    try {\n        while(true){\n            const chunk = stream.destroyed ? null : stream.read();\n            if (chunk !== null) yield chunk;\n            else if (error) throw error;\n            else if (error === null) return;\n            else await new $8d0731bae61c46b3$require$Promise(next);\n        }\n    } catch (err) {\n        error = $8d0731bae61c46b3$var$aggregateTwoErrors(error, err);\n        throw error;\n    } finally{\n        if ((error || (options === null || options === undefined ? undefined : options.destroyOnReturn) !== false) && (error === undefined || stream._readableState.autoDestroy)) $7CELW.destroyer(stream, null);\n        else {\n            stream.off('readable', next);\n            cleanup();\n        }\n    }\n}\n// Making it explicit these properties are not enumerable\n// because otherwise some prototype manipulation in\n// userland will fail.\n$8d0731bae61c46b3$require$ObjectDefineProperties($8d0731bae61c46b3$var$Readable.prototype, {\n    readable: {\n        __proto__: null,\n        get () {\n            const r = this._readableState;\n            // r.readable === false means that this is part of a Duplex stream\n            // where the readable side was disabled upon construction.\n            // Compat. The user might manually disable readable side through\n            // deprecated setter.\n            return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;\n        },\n        set (val) {\n            // Backwards compat.\n            if (this._readableState) this._readableState.readable = !!val;\n        }\n    },\n    readableDidRead: {\n        __proto__: null,\n        enumerable: false,\n        get: function() {\n            return this._readableState.dataEmitted;\n        }\n    },\n    readableAborted: {\n        __proto__: null,\n        enumerable: false,\n        get: function() {\n            return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);\n        }\n    },\n    readableHighWaterMark: {\n        __proto__: null,\n        enumerable: false,\n        get: function() {\n            return this._readableState.highWaterMark;\n        }\n    },\n    readableBuffer: {\n        __proto__: null,\n        enumerable: false,\n        get: function() {\n            return this._readableState && this._readableState.buffer;\n        }\n    },\n    readableFlowing: {\n        __proto__: null,\n        enumerable: false,\n        get: function() {\n            return this._readableState.flowing;\n        },\n        set: function(state) {\n            if (this._readableState) this._readableState.flowing = state;\n        }\n    },\n    readableLength: {\n        __proto__: null,\n        enumerable: false,\n        get () {\n            return this._readableState.length;\n        }\n    },\n    readableObjectMode: {\n        __proto__: null,\n        enumerable: false,\n        get () {\n            return this._readableState ? this._readableState.objectMode : false;\n        }\n    },\n    readableEncoding: {\n        __proto__: null,\n        enumerable: false,\n        get () {\n            return this._readableState ? this._readableState.encoding : null;\n        }\n    },\n    errored: {\n        __proto__: null,\n        enumerable: false,\n        get () {\n            return this._readableState ? this._readableState.errored : null;\n        }\n    },\n    closed: {\n        __proto__: null,\n        get () {\n            return this._readableState ? this._readableState.closed : false;\n        }\n    },\n    destroyed: {\n        __proto__: null,\n        enumerable: false,\n        get () {\n            return this._readableState ? this._readableState.destroyed : false;\n        },\n        set (value) {\n            // We ignore the value if the stream\n            // has not been initialized yet.\n            if (!this._readableState) return;\n            // Backward compatibility, the user is explicitly\n            // managing destroyed.\n            this._readableState.destroyed = value;\n        }\n    },\n    readableEnded: {\n        __proto__: null,\n        enumerable: false,\n        get () {\n            return this._readableState ? this._readableState.endEmitted : false;\n        }\n    }\n});\n$8d0731bae61c46b3$require$ObjectDefineProperties($8d0731bae61c46b3$var$ReadableState.prototype, {\n    // Legacy getter for `pipesCount`.\n    pipesCount: {\n        __proto__: null,\n        get () {\n            return this.pipes.length;\n        }\n    },\n    // Legacy property for `paused`.\n    paused: {\n        __proto__: null,\n        get () {\n            return this[$8d0731bae61c46b3$var$kPaused] !== false;\n        },\n        set (value) {\n            this[$8d0731bae61c46b3$var$kPaused] = !!value;\n        }\n    }\n});\n// Exposed for testing purposes only.\n$8d0731bae61c46b3$var$Readable._fromList = $8d0731bae61c46b3$var$fromList;\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction $8d0731bae61c46b3$var$fromList(n, state) {\n    // nothing buffered.\n    if (state.length === 0) return null;\n    let ret;\n    if (state.objectMode) ret = state.buffer.shift();\n    else if (!n || n >= state.length) {\n        // Read it all, truncate the list.\n        if (state.decoder) ret = state.buffer.join('');\n        else if (state.buffer.length === 1) ret = state.buffer.first();\n        else ret = state.buffer.concat(state.length);\n        state.buffer.clear();\n    } else // read part of list.\n    ret = state.buffer.consume(n, state.decoder);\n    return ret;\n}\nfunction $8d0731bae61c46b3$var$endReadable(stream) {\n    const state = stream._readableState;\n    $8d0731bae61c46b3$var$debug('endReadable', state.endEmitted);\n    if (!state.endEmitted) {\n        state.ended = true;\n        $ibaza.nextTick($8d0731bae61c46b3$var$endReadableNT, state, stream);\n    }\n}\nfunction $8d0731bae61c46b3$var$endReadableNT(state, stream) {\n    $8d0731bae61c46b3$var$debug('endReadableNT', state.endEmitted, state.length);\n    // Check that we didn't get one last unshift.\n    if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {\n        state.endEmitted = true;\n        stream.emit('end');\n        if (stream.writable && stream.allowHalfOpen === false) $ibaza.nextTick($8d0731bae61c46b3$var$endWritableNT, stream);\n        else if (state.autoDestroy) {\n            // In case of duplex streams we need a way to detect\n            // if the writable side is ready for autoDestroy as well.\n            const wState = stream._writableState;\n            const autoDestroy = !wState || wState.autoDestroy && // We don't expect the writable to ever 'finish'\n            // if writable is explicitly set to false.\n            (wState.finished || wState.writable === false);\n            if (autoDestroy) stream.destroy();\n        }\n    }\n}\nfunction $8d0731bae61c46b3$var$endWritableNT(stream) {\n    const writable = stream.writable && !stream.writableEnded && !stream.destroyed;\n    if (writable) stream.end();\n}\n$8d0731bae61c46b3$var$Readable.from = function(iterable, opts) {\n    return $ixzpt($8d0731bae61c46b3$var$Readable, iterable, opts);\n};\nlet $8d0731bae61c46b3$var$webStreamsAdapters;\n// Lazy to avoid circular references\nfunction $8d0731bae61c46b3$var$lazyWebStreams() {\n    if ($8d0731bae61c46b3$var$webStreamsAdapters === undefined) $8d0731bae61c46b3$var$webStreamsAdapters = {};\n    return $8d0731bae61c46b3$var$webStreamsAdapters;\n}\n$8d0731bae61c46b3$var$Readable.fromWeb = function(readableStream, options) {\n    return $8d0731bae61c46b3$var$lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);\n};\n$8d0731bae61c46b3$var$Readable.toWeb = function(streamReadable, options) {\n    return $8d0731bae61c46b3$var$lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);\n};\n$8d0731bae61c46b3$var$Readable.wrap = function(src, options) {\n    var _ref, _src$readableObjectMo;\n    return new $8d0731bae61c46b3$var$Readable({\n        objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== undefined ? _src$readableObjectMo : src.objectMode) !== null && _ref !== undefined ? _ref : true,\n        ...options,\n        destroy (err, callback) {\n            $7CELW.destroyer(src, err);\n            callback(err);\n        }\n    }).wrap(src);\n};\n\n});\nparcelRegister(\"ibaza\", function(module, exports) {\n// shim for using process in browser\nvar $d3c1734dacb01657$var$process = module.exports = {};\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\nvar $d3c1734dacb01657$var$cachedSetTimeout;\nvar $d3c1734dacb01657$var$cachedClearTimeout;\nfunction $d3c1734dacb01657$var$defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction $d3c1734dacb01657$var$defaultClearTimeout() {\n    throw new Error('clearTimeout has not been defined');\n}\n(function() {\n    try {\n        if (typeof setTimeout === 'function') $d3c1734dacb01657$var$cachedSetTimeout = setTimeout;\n        else $d3c1734dacb01657$var$cachedSetTimeout = $d3c1734dacb01657$var$defaultSetTimout;\n    } catch (e) {\n        $d3c1734dacb01657$var$cachedSetTimeout = $d3c1734dacb01657$var$defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') $d3c1734dacb01657$var$cachedClearTimeout = clearTimeout;\n        else $d3c1734dacb01657$var$cachedClearTimeout = $d3c1734dacb01657$var$defaultClearTimeout;\n    } catch (e) {\n        $d3c1734dacb01657$var$cachedClearTimeout = $d3c1734dacb01657$var$defaultClearTimeout;\n    }\n})();\nfunction $d3c1734dacb01657$var$runTimeout(fun) {\n    if ($d3c1734dacb01657$var$cachedSetTimeout === setTimeout) //normal enviroments in sane situations\n    return setTimeout(fun, 0);\n    // if setTimeout wasn't available but was latter defined\n    if (($d3c1734dacb01657$var$cachedSetTimeout === $d3c1734dacb01657$var$defaultSetTimout || !$d3c1734dacb01657$var$cachedSetTimeout) && setTimeout) {\n        $d3c1734dacb01657$var$cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return $d3c1734dacb01657$var$cachedSetTimeout(fun, 0);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return $d3c1734dacb01657$var$cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return $d3c1734dacb01657$var$cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction $d3c1734dacb01657$var$runClearTimeout(marker) {\n    if ($d3c1734dacb01657$var$cachedClearTimeout === clearTimeout) //normal enviroments in sane situations\n    return clearTimeout(marker);\n    // if clearTimeout wasn't available but was latter defined\n    if (($d3c1734dacb01657$var$cachedClearTimeout === $d3c1734dacb01657$var$defaultClearTimeout || !$d3c1734dacb01657$var$cachedClearTimeout) && clearTimeout) {\n        $d3c1734dacb01657$var$cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return $d3c1734dacb01657$var$cachedClearTimeout(marker);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return $d3c1734dacb01657$var$cachedClearTimeout.call(null, marker);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return $d3c1734dacb01657$var$cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar $d3c1734dacb01657$var$queue = [];\nvar $d3c1734dacb01657$var$draining = false;\nvar $d3c1734dacb01657$var$currentQueue;\nvar $d3c1734dacb01657$var$queueIndex = -1;\nfunction $d3c1734dacb01657$var$cleanUpNextTick() {\n    if (!$d3c1734dacb01657$var$draining || !$d3c1734dacb01657$var$currentQueue) return;\n    $d3c1734dacb01657$var$draining = false;\n    if ($d3c1734dacb01657$var$currentQueue.length) $d3c1734dacb01657$var$queue = $d3c1734dacb01657$var$currentQueue.concat($d3c1734dacb01657$var$queue);\n    else $d3c1734dacb01657$var$queueIndex = -1;\n    if ($d3c1734dacb01657$var$queue.length) $d3c1734dacb01657$var$drainQueue();\n}\nfunction $d3c1734dacb01657$var$drainQueue() {\n    if ($d3c1734dacb01657$var$draining) return;\n    var timeout = $d3c1734dacb01657$var$runTimeout($d3c1734dacb01657$var$cleanUpNextTick);\n    $d3c1734dacb01657$var$draining = true;\n    var len = $d3c1734dacb01657$var$queue.length;\n    while(len){\n        $d3c1734dacb01657$var$currentQueue = $d3c1734dacb01657$var$queue;\n        $d3c1734dacb01657$var$queue = [];\n        while(++$d3c1734dacb01657$var$queueIndex < len)if ($d3c1734dacb01657$var$currentQueue) $d3c1734dacb01657$var$currentQueue[$d3c1734dacb01657$var$queueIndex].run();\n        $d3c1734dacb01657$var$queueIndex = -1;\n        len = $d3c1734dacb01657$var$queue.length;\n    }\n    $d3c1734dacb01657$var$currentQueue = null;\n    $d3c1734dacb01657$var$draining = false;\n    $d3c1734dacb01657$var$runClearTimeout(timeout);\n}\n$d3c1734dacb01657$var$process.nextTick = function(fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];\n    $d3c1734dacb01657$var$queue.push(new $d3c1734dacb01657$var$Item(fun, args));\n    if ($d3c1734dacb01657$var$queue.length === 1 && !$d3c1734dacb01657$var$draining) $d3c1734dacb01657$var$runTimeout($d3c1734dacb01657$var$drainQueue);\n};\n// v8 likes predictible objects\nfunction $d3c1734dacb01657$var$Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\n$d3c1734dacb01657$var$Item.prototype.run = function() {\n    this.fun.apply(null, this.array);\n};\n$d3c1734dacb01657$var$process.title = 'browser';\n$d3c1734dacb01657$var$process.browser = true;\n$d3c1734dacb01657$var$process.env = {};\n$d3c1734dacb01657$var$process.argv = [];\n$d3c1734dacb01657$var$process.version = ''; // empty string to avoid regexp issues\n$d3c1734dacb01657$var$process.versions = {};\nfunction $d3c1734dacb01657$var$noop() {}\n$d3c1734dacb01657$var$process.on = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.addListener = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.once = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.off = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.removeListener = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.removeAllListeners = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.emit = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.prependListener = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.prependOnceListener = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.listeners = function(name) {\n    return [];\n};\n$d3c1734dacb01657$var$process.binding = function(name) {\n    throw new Error('process.binding is not supported');\n};\n$d3c1734dacb01657$var$process.cwd = function() {\n    return '/';\n};\n$d3c1734dacb01657$var$process.chdir = function(dir) {\n    throw new Error('process.chdir is not supported');\n};\n$d3c1734dacb01657$var$process.umask = function() {\n    return 0;\n};\n\n});\n\nparcelRegister(\"1Tt4D\", function(module, exports) {\n'use strict';\n\nvar $1by5F = parcelRequire(\"1by5F\");\nvar $16117aedbf487121$require$ArrayIsArray = $1by5F.ArrayIsArray;\nvar $16117aedbf487121$require$ObjectSetPrototypeOf = $1by5F.ObjectSetPrototypeOf;\n\nvar $9sqfU = parcelRequire(\"9sqfU\");\nvar $16117aedbf487121$require$EE = $9sqfU.EventEmitter;\nfunction $16117aedbf487121$var$Stream(opts) {\n    $16117aedbf487121$require$EE.call(this, opts);\n}\n$16117aedbf487121$require$ObjectSetPrototypeOf($16117aedbf487121$var$Stream.prototype, $16117aedbf487121$require$EE.prototype);\n$16117aedbf487121$require$ObjectSetPrototypeOf($16117aedbf487121$var$Stream, $16117aedbf487121$require$EE);\n$16117aedbf487121$var$Stream.prototype.pipe = function(dest, options) {\n    const source = this;\n    function ondata(chunk) {\n        if (dest.writable && dest.write(chunk) === false && source.pause) source.pause();\n    }\n    source.on('data', ondata);\n    function ondrain() {\n        if (source.readable && source.resume) source.resume();\n    }\n    dest.on('drain', ondrain);\n    // If the 'end' option is not supplied, dest.end() will be called when\n    // source gets the 'end' or 'close' events.  Only dest.end() once.\n    if (!dest._isStdio && (!options || options.end !== false)) {\n        source.on('end', onend);\n        source.on('close', onclose);\n    }\n    let didOnEnd = false;\n    function onend() {\n        if (didOnEnd) return;\n        didOnEnd = true;\n        dest.end();\n    }\n    function onclose() {\n        if (didOnEnd) return;\n        didOnEnd = true;\n        if (typeof dest.destroy === 'function') dest.destroy();\n    }\n    // Don't leave dangling pipes when there are errors.\n    function onerror(er) {\n        cleanup();\n        if ($16117aedbf487121$require$EE.listenerCount(this, 'error') === 0) this.emit('error', er);\n    }\n    $16117aedbf487121$var$prependListener(source, 'error', onerror);\n    $16117aedbf487121$var$prependListener(dest, 'error', onerror);\n    // Remove all the event listeners that were added.\n    function cleanup() {\n        source.removeListener('data', ondata);\n        dest.removeListener('drain', ondrain);\n        source.removeListener('end', onend);\n        source.removeListener('close', onclose);\n        source.removeListener('error', onerror);\n        dest.removeListener('error', onerror);\n        source.removeListener('end', cleanup);\n        source.removeListener('close', cleanup);\n        dest.removeListener('close', cleanup);\n    }\n    source.on('end', cleanup);\n    source.on('close', cleanup);\n    dest.on('close', cleanup);\n    dest.emit('pipe', source);\n    // Allow for unix-like usage: A.pipe(B).pipe(C)\n    return dest;\n};\nfunction $16117aedbf487121$var$prependListener(emitter, event, fn) {\n    // Sadly this is not cacheable as some libraries bundle their own\n    // event emitter implementation with them.\n    if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n    // This is a hack to make sure that our error handler is attached before any\n    // userland ones.  NEVER DO THIS. This is here only because this code needs\n    // to continue to work with older versions of Node.js that do not include\n    // the prependListener() method. The goal is to eventually remove this hack.\n    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);\n    else if ($16117aedbf487121$require$ArrayIsArray(emitter._events[event])) emitter._events[event].unshift(fn);\n    else emitter._events[event] = [\n        fn,\n        emitter._events[event]\n    ];\n}\nmodule.exports = {\n    Stream: $16117aedbf487121$var$Stream,\n    prependListener: $16117aedbf487121$var$prependListener\n};\n\n});\n\nparcelRegister(\"6ASt2\", function(module, exports) {\n\n$parcel$export(module.exports, \"addAbortSignal\", () => $4cd05af391a20c5a$export$e2db56ee53255a0, (v) => $4cd05af391a20c5a$export$e2db56ee53255a0 = v);\n$parcel$export(module.exports, \"addAbortSignalNoValidate\", () => $4cd05af391a20c5a$export$11956e9313f43de0, (v) => $4cd05af391a20c5a$export$11956e9313f43de0 = v);\nvar $4cd05af391a20c5a$export$e2db56ee53255a0;\nvar $4cd05af391a20c5a$export$11956e9313f43de0;\n'use strict';\n\nvar $1by5F = parcelRequire(\"1by5F\");\nvar $4cd05af391a20c5a$require$SymbolDispose = $1by5F.SymbolDispose;\n\nvar $7ynhX = parcelRequire(\"7ynhX\");\nvar $4cd05af391a20c5a$require$AbortError = $7ynhX.AbortError;\nvar $4cd05af391a20c5a$require$codes = $7ynhX.codes;\n\nvar $eY1Gs = parcelRequire(\"eY1Gs\");\nvar $4cd05af391a20c5a$require$isNodeStream = $eY1Gs.isNodeStream;\nvar $4cd05af391a20c5a$require$isWebStream = $eY1Gs.isWebStream;\nvar $4cd05af391a20c5a$require$kControllerErrorFunction = $eY1Gs.kControllerErrorFunction;\n\nvar $9RUbc = parcelRequire(\"9RUbc\");\nconst { ERR_INVALID_ARG_TYPE: $4cd05af391a20c5a$var$ERR_INVALID_ARG_TYPE } = $4cd05af391a20c5a$require$codes;\nlet $4cd05af391a20c5a$var$addAbortListener;\n// This method is inlined here for readable-stream\n// It also does not allow for signal to not exist on the stream\n// https://github.com/nodejs/node/pull/36061#discussion_r533718029\nconst $4cd05af391a20c5a$var$validateAbortSignal = (signal, name)=>{\n    if (typeof signal !== 'object' || !('aborted' in signal)) throw new $4cd05af391a20c5a$var$ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal);\n};\n$4cd05af391a20c5a$export$e2db56ee53255a0 = function addAbortSignal(signal, stream) {\n    $4cd05af391a20c5a$var$validateAbortSignal(signal, 'signal');\n    if (!$4cd05af391a20c5a$require$isNodeStream(stream) && !$4cd05af391a20c5a$require$isWebStream(stream)) throw new $4cd05af391a20c5a$var$ERR_INVALID_ARG_TYPE('stream', [\n        'ReadableStream',\n        'WritableStream',\n        'Stream'\n    ], stream);\n    return $4cd05af391a20c5a$export$11956e9313f43de0(signal, stream);\n};\n\n$4cd05af391a20c5a$export$11956e9313f43de0 = function(signal, stream) {\n    if (typeof signal !== 'object' || !('aborted' in signal)) return stream;\n    const onAbort = $4cd05af391a20c5a$require$isNodeStream(stream) ? ()=>{\n        stream.destroy(new $4cd05af391a20c5a$require$AbortError(undefined, {\n            cause: signal.reason\n        }));\n    } : ()=>{\n        stream[$4cd05af391a20c5a$require$kControllerErrorFunction](new $4cd05af391a20c5a$require$AbortError(undefined, {\n            cause: signal.reason\n        }));\n    };\n    if (signal.aborted) onAbort();\n    else {\n        $4cd05af391a20c5a$var$addAbortListener = $4cd05af391a20c5a$var$addAbortListener || (parcelRequire(\"kDFyU\")).addAbortListener;\n        const disposable = $4cd05af391a20c5a$var$addAbortListener(signal, onAbort);\n        $9RUbc(stream, disposable[$4cd05af391a20c5a$require$SymbolDispose]);\n    }\n    return stream;\n};\n\n});\nparcelRegister(\"eY1Gs\", function(module, exports) {\n'use strict';\n\nvar $1by5F = parcelRequire(\"1by5F\");\nvar $ae57f9ab8f8d2285$require$SymbolAsyncIterator = $1by5F.SymbolAsyncIterator;\nvar $ae57f9ab8f8d2285$require$SymbolIterator = $1by5F.SymbolIterator;\nvar $ae57f9ab8f8d2285$require$SymbolFor = $1by5F.SymbolFor;\n// We need to use SymbolFor to make these globally available\n// for interopt with readable-stream, i.e. readable-stream\n// and node core needs to be able to read/write private state\n// from each other for proper interoperability.\nconst $ae57f9ab8f8d2285$var$kIsDestroyed = $ae57f9ab8f8d2285$require$SymbolFor('nodejs.stream.destroyed');\nconst $ae57f9ab8f8d2285$var$kIsErrored = $ae57f9ab8f8d2285$require$SymbolFor('nodejs.stream.errored');\nconst $ae57f9ab8f8d2285$var$kIsReadable = $ae57f9ab8f8d2285$require$SymbolFor('nodejs.stream.readable');\nconst $ae57f9ab8f8d2285$var$kIsWritable = $ae57f9ab8f8d2285$require$SymbolFor('nodejs.stream.writable');\nconst $ae57f9ab8f8d2285$var$kIsDisturbed = $ae57f9ab8f8d2285$require$SymbolFor('nodejs.stream.disturbed');\nconst $ae57f9ab8f8d2285$var$kIsClosedPromise = $ae57f9ab8f8d2285$require$SymbolFor('nodejs.webstream.isClosedPromise');\nconst $ae57f9ab8f8d2285$var$kControllerErrorFunction = $ae57f9ab8f8d2285$require$SymbolFor('nodejs.webstream.controllerErrorFunction');\nfunction $ae57f9ab8f8d2285$var$isReadableNodeStream(obj, strict = false) {\n    var _obj$_readableState;\n    return !!(obj && typeof obj.pipe === 'function' && typeof obj.on === 'function' && (!strict || typeof obj.pause === 'function' && typeof obj.resume === 'function') && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === undefined ? undefined : _obj$_readableState.readable) !== false) && // Duplex\n    (!obj._writableState || obj._readableState) // Writable has .pipe.\n    );\n}\nfunction $ae57f9ab8f8d2285$var$isWritableNodeStream(obj) {\n    var _obj$_writableState;\n    return !!(obj && typeof obj.write === 'function' && typeof obj.on === 'function' && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === undefined ? undefined : _obj$_writableState.writable) !== false) // Duplex\n    );\n}\nfunction $ae57f9ab8f8d2285$var$isDuplexNodeStream(obj) {\n    return !!(obj && typeof obj.pipe === 'function' && obj._readableState && typeof obj.on === 'function' && typeof obj.write === 'function');\n}\nfunction $ae57f9ab8f8d2285$var$isNodeStream(obj) {\n    return obj && (obj._readableState || obj._writableState || typeof obj.write === 'function' && typeof obj.on === 'function' || typeof obj.pipe === 'function' && typeof obj.on === 'function');\n}\nfunction $ae57f9ab8f8d2285$var$isReadableStream(obj) {\n    return !!(obj && !$ae57f9ab8f8d2285$var$isNodeStream(obj) && typeof obj.pipeThrough === 'function' && typeof obj.getReader === 'function' && typeof obj.cancel === 'function');\n}\nfunction $ae57f9ab8f8d2285$var$isWritableStream(obj) {\n    return !!(obj && !$ae57f9ab8f8d2285$var$isNodeStream(obj) && typeof obj.getWriter === 'function' && typeof obj.abort === 'function');\n}\nfunction $ae57f9ab8f8d2285$var$isTransformStream(obj) {\n    return !!(obj && !$ae57f9ab8f8d2285$var$isNodeStream(obj) && typeof obj.readable === 'object' && typeof obj.writable === 'object');\n}\nfunction $ae57f9ab8f8d2285$var$isWebStream(obj) {\n    return $ae57f9ab8f8d2285$var$isReadableStream(obj) || $ae57f9ab8f8d2285$var$isWritableStream(obj) || $ae57f9ab8f8d2285$var$isTransformStream(obj);\n}\nfunction $ae57f9ab8f8d2285$var$isIterable(obj, isAsync) {\n    if (obj == null) return false;\n    if (isAsync === true) return typeof obj[$ae57f9ab8f8d2285$require$SymbolAsyncIterator] === 'function';\n    if (isAsync === false) return typeof obj[$ae57f9ab8f8d2285$require$SymbolIterator] === 'function';\n    return typeof obj[$ae57f9ab8f8d2285$require$SymbolAsyncIterator] === 'function' || typeof obj[$ae57f9ab8f8d2285$require$SymbolIterator] === 'function';\n}\nfunction $ae57f9ab8f8d2285$var$isDestroyed(stream) {\n    if (!$ae57f9ab8f8d2285$var$isNodeStream(stream)) return null;\n    const wState = stream._writableState;\n    const rState = stream._readableState;\n    const state = wState || rState;\n    return !!(stream.destroyed || stream[$ae57f9ab8f8d2285$var$kIsDestroyed] || state !== null && state !== undefined && state.destroyed);\n}\n// Have been end():d.\nfunction $ae57f9ab8f8d2285$var$isWritableEnded(stream) {\n    if (!$ae57f9ab8f8d2285$var$isWritableNodeStream(stream)) return null;\n    if (stream.writableEnded === true) return true;\n    const wState = stream._writableState;\n    if (wState !== null && wState !== undefined && wState.errored) return false;\n    if (typeof (wState === null || wState === undefined ? undefined : wState.ended) !== 'boolean') return null;\n    return wState.ended;\n}\n// Have emitted 'finish'.\nfunction $ae57f9ab8f8d2285$var$isWritableFinished(stream, strict) {\n    if (!$ae57f9ab8f8d2285$var$isWritableNodeStream(stream)) return null;\n    if (stream.writableFinished === true) return true;\n    const wState = stream._writableState;\n    if (wState !== null && wState !== undefined && wState.errored) return false;\n    if (typeof (wState === null || wState === undefined ? undefined : wState.finished) !== 'boolean') return null;\n    return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);\n}\n// Have been push(null):d.\nfunction $ae57f9ab8f8d2285$var$isReadableEnded(stream) {\n    if (!$ae57f9ab8f8d2285$var$isReadableNodeStream(stream)) return null;\n    if (stream.readableEnded === true) return true;\n    const rState = stream._readableState;\n    if (!rState || rState.errored) return false;\n    if (typeof (rState === null || rState === undefined ? undefined : rState.ended) !== 'boolean') return null;\n    return rState.ended;\n}\n// Have emitted 'end'.\nfunction $ae57f9ab8f8d2285$var$isReadableFinished(stream, strict) {\n    if (!$ae57f9ab8f8d2285$var$isReadableNodeStream(stream)) return null;\n    const rState = stream._readableState;\n    if (rState !== null && rState !== undefined && rState.errored) return false;\n    if (typeof (rState === null || rState === undefined ? undefined : rState.endEmitted) !== 'boolean') return null;\n    return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);\n}\nfunction $ae57f9ab8f8d2285$var$isReadable(stream) {\n    if (stream && stream[$ae57f9ab8f8d2285$var$kIsReadable] != null) return stream[$ae57f9ab8f8d2285$var$kIsReadable];\n    if (typeof (stream === null || stream === undefined ? undefined : stream.readable) !== 'boolean') return null;\n    if ($ae57f9ab8f8d2285$var$isDestroyed(stream)) return false;\n    return $ae57f9ab8f8d2285$var$isReadableNodeStream(stream) && stream.readable && !$ae57f9ab8f8d2285$var$isReadableFinished(stream);\n}\nfunction $ae57f9ab8f8d2285$var$isWritable(stream) {\n    if (stream && stream[$ae57f9ab8f8d2285$var$kIsWritable] != null) return stream[$ae57f9ab8f8d2285$var$kIsWritable];\n    if (typeof (stream === null || stream === undefined ? undefined : stream.writable) !== 'boolean') return null;\n    if ($ae57f9ab8f8d2285$var$isDestroyed(stream)) return false;\n    return $ae57f9ab8f8d2285$var$isWritableNodeStream(stream) && stream.writable && !$ae57f9ab8f8d2285$var$isWritableEnded(stream);\n}\nfunction $ae57f9ab8f8d2285$var$isFinished(stream, opts) {\n    if (!$ae57f9ab8f8d2285$var$isNodeStream(stream)) return null;\n    if ($ae57f9ab8f8d2285$var$isDestroyed(stream)) return true;\n    if ((opts === null || opts === undefined ? undefined : opts.readable) !== false && $ae57f9ab8f8d2285$var$isReadable(stream)) return false;\n    if ((opts === null || opts === undefined ? undefined : opts.writable) !== false && $ae57f9ab8f8d2285$var$isWritable(stream)) return false;\n    return true;\n}\nfunction $ae57f9ab8f8d2285$var$isWritableErrored(stream) {\n    var _stream$_writableStat, _stream$_writableStat2;\n    if (!$ae57f9ab8f8d2285$var$isNodeStream(stream)) return null;\n    if (stream.writableErrored) return stream.writableErrored;\n    return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === undefined ? undefined : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== undefined ? _stream$_writableStat : null;\n}\nfunction $ae57f9ab8f8d2285$var$isReadableErrored(stream) {\n    var _stream$_readableStat, _stream$_readableStat2;\n    if (!$ae57f9ab8f8d2285$var$isNodeStream(stream)) return null;\n    if (stream.readableErrored) return stream.readableErrored;\n    return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === undefined ? undefined : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== undefined ? _stream$_readableStat : null;\n}\nfunction $ae57f9ab8f8d2285$var$isClosed(stream) {\n    if (!$ae57f9ab8f8d2285$var$isNodeStream(stream)) return null;\n    if (typeof stream.closed === 'boolean') return stream.closed;\n    const wState = stream._writableState;\n    const rState = stream._readableState;\n    if (typeof (wState === null || wState === undefined ? undefined : wState.closed) === 'boolean' || typeof (rState === null || rState === undefined ? undefined : rState.closed) === 'boolean') return (wState === null || wState === undefined ? undefined : wState.closed) || (rState === null || rState === undefined ? undefined : rState.closed);\n    if (typeof stream._closed === 'boolean' && $ae57f9ab8f8d2285$var$isOutgoingMessage(stream)) return stream._closed;\n    return null;\n}\nfunction $ae57f9ab8f8d2285$var$isOutgoingMessage(stream) {\n    return typeof stream._closed === 'boolean' && typeof stream._defaultKeepAlive === 'boolean' && typeof stream._removedConnection === 'boolean' && typeof stream._removedContLen === 'boolean';\n}\nfunction $ae57f9ab8f8d2285$var$isServerResponse(stream) {\n    return typeof stream._sent100 === 'boolean' && $ae57f9ab8f8d2285$var$isOutgoingMessage(stream);\n}\nfunction $ae57f9ab8f8d2285$var$isServerRequest(stream) {\n    var _stream$req;\n    return typeof stream._consuming === 'boolean' && typeof stream._dumped === 'boolean' && ((_stream$req = stream.req) === null || _stream$req === undefined ? undefined : _stream$req.upgradeOrConnect) === undefined;\n}\nfunction $ae57f9ab8f8d2285$var$willEmitClose(stream) {\n    if (!$ae57f9ab8f8d2285$var$isNodeStream(stream)) return null;\n    const wState = stream._writableState;\n    const rState = stream._readableState;\n    const state = wState || rState;\n    return !state && $ae57f9ab8f8d2285$var$isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);\n}\nfunction $ae57f9ab8f8d2285$var$isDisturbed(stream) {\n    var _stream$kIsDisturbed;\n    return !!(stream && ((_stream$kIsDisturbed = stream[$ae57f9ab8f8d2285$var$kIsDisturbed]) !== null && _stream$kIsDisturbed !== undefined ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));\n}\nfunction $ae57f9ab8f8d2285$var$isErrored(stream) {\n    var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;\n    return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[$ae57f9ab8f8d2285$var$kIsErrored]) !== null && _stream$kIsErrored !== undefined ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== undefined ? _ref5 : stream.writableErrored) !== null && _ref4 !== undefined ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === undefined ? undefined : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== undefined ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === undefined ? undefined : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== undefined ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === undefined ? undefined : _stream$_readableStat4.errored) !== null && _ref !== undefined ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === undefined ? undefined : _stream$_writableStat4.errored));\n}\nmodule.exports = {\n    isDestroyed: $ae57f9ab8f8d2285$var$isDestroyed,\n    kIsDestroyed: $ae57f9ab8f8d2285$var$kIsDestroyed,\n    isDisturbed: $ae57f9ab8f8d2285$var$isDisturbed,\n    kIsDisturbed: $ae57f9ab8f8d2285$var$kIsDisturbed,\n    isErrored: $ae57f9ab8f8d2285$var$isErrored,\n    kIsErrored: $ae57f9ab8f8d2285$var$kIsErrored,\n    isReadable: $ae57f9ab8f8d2285$var$isReadable,\n    kIsReadable: $ae57f9ab8f8d2285$var$kIsReadable,\n    kIsClosedPromise: $ae57f9ab8f8d2285$var$kIsClosedPromise,\n    kControllerErrorFunction: $ae57f9ab8f8d2285$var$kControllerErrorFunction,\n    kIsWritable: $ae57f9ab8f8d2285$var$kIsWritable,\n    isClosed: $ae57f9ab8f8d2285$var$isClosed,\n    isDuplexNodeStream: $ae57f9ab8f8d2285$var$isDuplexNodeStream,\n    isFinished: $ae57f9ab8f8d2285$var$isFinished,\n    isIterable: $ae57f9ab8f8d2285$var$isIterable,\n    isReadableNodeStream: $ae57f9ab8f8d2285$var$isReadableNodeStream,\n    isReadableStream: $ae57f9ab8f8d2285$var$isReadableStream,\n    isReadableEnded: $ae57f9ab8f8d2285$var$isReadableEnded,\n    isReadableFinished: $ae57f9ab8f8d2285$var$isReadableFinished,\n    isReadableErrored: $ae57f9ab8f8d2285$var$isReadableErrored,\n    isNodeStream: $ae57f9ab8f8d2285$var$isNodeStream,\n    isWebStream: $ae57f9ab8f8d2285$var$isWebStream,\n    isWritable: $ae57f9ab8f8d2285$var$isWritable,\n    isWritableNodeStream: $ae57f9ab8f8d2285$var$isWritableNodeStream,\n    isWritableStream: $ae57f9ab8f8d2285$var$isWritableStream,\n    isWritableEnded: $ae57f9ab8f8d2285$var$isWritableEnded,\n    isWritableFinished: $ae57f9ab8f8d2285$var$isWritableFinished,\n    isWritableErrored: $ae57f9ab8f8d2285$var$isWritableErrored,\n    isServerRequest: $ae57f9ab8f8d2285$var$isServerRequest,\n    isServerResponse: $ae57f9ab8f8d2285$var$isServerResponse,\n    willEmitClose: $ae57f9ab8f8d2285$var$willEmitClose,\n    isTransformStream: $ae57f9ab8f8d2285$var$isTransformStream\n};\n\n});\n\nparcelRegister(\"9RUbc\", function(module, exports) {\n// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n'use strict';\n\nvar $ibaza = parcelRequire(\"ibaza\");\n\nvar $7ynhX = parcelRequire(\"7ynhX\");\nvar $72f4a4664289a3fc$require$AbortError = $7ynhX.AbortError;\nvar $72f4a4664289a3fc$require$codes = $7ynhX.codes;\nconst { ERR_INVALID_ARG_TYPE: $72f4a4664289a3fc$var$ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE: $72f4a4664289a3fc$var$ERR_STREAM_PREMATURE_CLOSE } = $72f4a4664289a3fc$require$codes;\n\nvar $72f4a4664289a3fc$require$kEmptyObject = (parcelRequire(\"kDFyU\")).kEmptyObject;\nvar $72f4a4664289a3fc$require$once = (parcelRequire(\"kDFyU\")).once;\n\nvar $geuoF = parcelRequire(\"geuoF\");\nvar $72f4a4664289a3fc$require$validateAbortSignal = $geuoF.validateAbortSignal;\nvar $72f4a4664289a3fc$require$validateFunction = $geuoF.validateFunction;\nvar $72f4a4664289a3fc$require$validateObject = $geuoF.validateObject;\nvar $72f4a4664289a3fc$require$validateBoolean = $geuoF.validateBoolean;\n\nvar $1by5F = parcelRequire(\"1by5F\");\nvar $72f4a4664289a3fc$require$Promise = $1by5F.Promise;\nvar $72f4a4664289a3fc$require$PromisePrototypeThen = $1by5F.PromisePrototypeThen;\nvar $72f4a4664289a3fc$require$SymbolDispose = $1by5F.SymbolDispose;\n\nvar $eY1Gs = parcelRequire(\"eY1Gs\");\nvar $72f4a4664289a3fc$require$isClosed = $eY1Gs.isClosed;\nvar $72f4a4664289a3fc$require$isReadable = $eY1Gs.isReadable;\nvar $72f4a4664289a3fc$require$isReadableNodeStream = $eY1Gs.isReadableNodeStream;\nvar $72f4a4664289a3fc$require$isReadableStream = $eY1Gs.isReadableStream;\nvar $72f4a4664289a3fc$require$isReadableFinished = $eY1Gs.isReadableFinished;\nvar $72f4a4664289a3fc$require$isReadableErrored = $eY1Gs.isReadableErrored;\nvar $72f4a4664289a3fc$require$isWritable = $eY1Gs.isWritable;\nvar $72f4a4664289a3fc$require$isWritableNodeStream = $eY1Gs.isWritableNodeStream;\nvar $72f4a4664289a3fc$require$isWritableStream = $eY1Gs.isWritableStream;\nvar $72f4a4664289a3fc$require$isWritableFinished = $eY1Gs.isWritableFinished;\nvar $72f4a4664289a3fc$require$isWritableErrored = $eY1Gs.isWritableErrored;\nvar $72f4a4664289a3fc$require$isNodeStream = $eY1Gs.isNodeStream;\nvar $72f4a4664289a3fc$require$_willEmitClose = $eY1Gs.willEmitClose;\nvar $72f4a4664289a3fc$require$kIsClosedPromise = $eY1Gs.kIsClosedPromise;\nlet $72f4a4664289a3fc$var$addAbortListener;\nfunction $72f4a4664289a3fc$var$isRequest(stream) {\n    return stream.setHeader && typeof stream.abort === 'function';\n}\nconst $72f4a4664289a3fc$var$nop = ()=>{};\n\nfunction $72f4a4664289a3fc$var$eos(stream, options, callback) {\n    var _options$readable, _options$writable;\n    if (arguments.length === 2) {\n        callback = options;\n        options = $72f4a4664289a3fc$require$kEmptyObject;\n    } else if (options == null) options = $72f4a4664289a3fc$require$kEmptyObject;\n    else $72f4a4664289a3fc$require$validateObject(options, 'options');\n    $72f4a4664289a3fc$require$validateFunction(callback, 'callback');\n    $72f4a4664289a3fc$require$validateAbortSignal(options.signal, 'options.signal');\n    callback = $72f4a4664289a3fc$require$once(callback);\n    if ($72f4a4664289a3fc$require$isReadableStream(stream) || $72f4a4664289a3fc$require$isWritableStream(stream)) return $72f4a4664289a3fc$var$eosWeb(stream, options, callback);\n    if (!$72f4a4664289a3fc$require$isNodeStream(stream)) throw new $72f4a4664289a3fc$var$ERR_INVALID_ARG_TYPE('stream', [\n        'ReadableStream',\n        'WritableStream',\n        'Stream'\n    ], stream);\n    const readable = (_options$readable = options.readable) !== null && _options$readable !== undefined ? _options$readable : $72f4a4664289a3fc$require$isReadableNodeStream(stream);\n    const writable = (_options$writable = options.writable) !== null && _options$writable !== undefined ? _options$writable : $72f4a4664289a3fc$require$isWritableNodeStream(stream);\n    const wState = stream._writableState;\n    const rState = stream._readableState;\n    const onlegacyfinish = ()=>{\n        if (!stream.writable) onfinish();\n    };\n    // TODO (ronag): Improve soft detection to include core modules and\n    // common ecosystem modules that do properly emit 'close' but fail\n    // this generic check.\n    let willEmitClose = $72f4a4664289a3fc$require$_willEmitClose(stream) && $72f4a4664289a3fc$require$isReadableNodeStream(stream) === readable && $72f4a4664289a3fc$require$isWritableNodeStream(stream) === writable;\n    let writableFinished = $72f4a4664289a3fc$require$isWritableFinished(stream, false);\n    const onfinish = ()=>{\n        writableFinished = true;\n        // Stream should not be destroyed here. If it is that\n        // means that user space is doing something differently and\n        // we cannot trust willEmitClose.\n        if (stream.destroyed) willEmitClose = false;\n        if (willEmitClose && (!stream.readable || readable)) return;\n        if (!readable || readableFinished) callback.call(stream);\n    };\n    let readableFinished = $72f4a4664289a3fc$require$isReadableFinished(stream, false);\n    const onend = ()=>{\n        readableFinished = true;\n        // Stream should not be destroyed here. If it is that\n        // means that user space is doing something differently and\n        // we cannot trust willEmitClose.\n        if (stream.destroyed) willEmitClose = false;\n        if (willEmitClose && (!stream.writable || writable)) return;\n        if (!writable || writableFinished) callback.call(stream);\n    };\n    const onerror = (err)=>{\n        callback.call(stream, err);\n    };\n    let closed = $72f4a4664289a3fc$require$isClosed(stream);\n    const onclose = ()=>{\n        closed = true;\n        const errored = $72f4a4664289a3fc$require$isWritableErrored(stream) || $72f4a4664289a3fc$require$isReadableErrored(stream);\n        if (errored && typeof errored !== 'boolean') return callback.call(stream, errored);\n        if (readable && !readableFinished && $72f4a4664289a3fc$require$isReadableNodeStream(stream, true)) {\n            if (!$72f4a4664289a3fc$require$isReadableFinished(stream, false)) return callback.call(stream, new $72f4a4664289a3fc$var$ERR_STREAM_PREMATURE_CLOSE());\n        }\n        if (writable && !writableFinished) {\n            if (!$72f4a4664289a3fc$require$isWritableFinished(stream, false)) return callback.call(stream, new $72f4a4664289a3fc$var$ERR_STREAM_PREMATURE_CLOSE());\n        }\n        callback.call(stream);\n    };\n    const onclosed = ()=>{\n        closed = true;\n        const errored = $72f4a4664289a3fc$require$isWritableErrored(stream) || $72f4a4664289a3fc$require$isReadableErrored(stream);\n        if (errored && typeof errored !== 'boolean') return callback.call(stream, errored);\n        callback.call(stream);\n    };\n    const onrequest = ()=>{\n        stream.req.on('finish', onfinish);\n    };\n    if ($72f4a4664289a3fc$var$isRequest(stream)) {\n        stream.on('complete', onfinish);\n        if (!willEmitClose) stream.on('abort', onclose);\n        if (stream.req) onrequest();\n        else stream.on('request', onrequest);\n    } else if (writable && !wState) {\n        // legacy streams\n        stream.on('end', onlegacyfinish);\n        stream.on('close', onlegacyfinish);\n    }\n    // Not all streams will emit 'close' after 'aborted'.\n    if (!willEmitClose && typeof stream.aborted === 'boolean') stream.on('aborted', onclose);\n    stream.on('end', onend);\n    stream.on('finish', onfinish);\n    if (options.error !== false) stream.on('error', onerror);\n    stream.on('close', onclose);\n    if (closed) $ibaza.nextTick(onclose);\n    else if (wState !== null && wState !== undefined && wState.errorEmitted || rState !== null && rState !== undefined && rState.errorEmitted) {\n        if (!willEmitClose) $ibaza.nextTick(onclosed);\n    } else if (!readable && (!willEmitClose || $72f4a4664289a3fc$require$isReadable(stream)) && (writableFinished || $72f4a4664289a3fc$require$isWritable(stream) === false)) $ibaza.nextTick(onclosed);\n    else if (!writable && (!willEmitClose || $72f4a4664289a3fc$require$isWritable(stream)) && (readableFinished || $72f4a4664289a3fc$require$isReadable(stream) === false)) $ibaza.nextTick(onclosed);\n    else if (rState && stream.req && stream.aborted) $ibaza.nextTick(onclosed);\n    const cleanup = ()=>{\n        callback = $72f4a4664289a3fc$var$nop;\n        stream.removeListener('aborted', onclose);\n        stream.removeListener('complete', onfinish);\n        stream.removeListener('abort', onclose);\n        stream.removeListener('request', onrequest);\n        if (stream.req) stream.req.removeListener('finish', onfinish);\n        stream.removeListener('end', onlegacyfinish);\n        stream.removeListener('close', onlegacyfinish);\n        stream.removeListener('finish', onfinish);\n        stream.removeListener('end', onend);\n        stream.removeListener('error', onerror);\n        stream.removeListener('close', onclose);\n    };\n    if (options.signal && !closed) {\n        const abort = ()=>{\n            // Keep it because cleanup removes it.\n            const endCallback = callback;\n            cleanup();\n            endCallback.call(stream, new $72f4a4664289a3fc$require$AbortError(undefined, {\n                cause: options.signal.reason\n            }));\n        };\n        if (options.signal.aborted) $ibaza.nextTick(abort);\n        else {\n            $72f4a4664289a3fc$var$addAbortListener = $72f4a4664289a3fc$var$addAbortListener || (parcelRequire(\"kDFyU\")).addAbortListener;\n            const disposable = $72f4a4664289a3fc$var$addAbortListener(options.signal, abort);\n            const originalCallback = callback;\n            callback = $72f4a4664289a3fc$require$once((...args)=>{\n                disposable[$72f4a4664289a3fc$require$SymbolDispose]();\n                originalCallback.apply(stream, args);\n            });\n        }\n    }\n    return cleanup;\n}\n\nfunction $72f4a4664289a3fc$var$eosWeb(stream, options, callback) {\n    let isAborted = false;\n    let abort = $72f4a4664289a3fc$var$nop;\n    if (options.signal) {\n        abort = ()=>{\n            isAborted = true;\n            callback.call(stream, new $72f4a4664289a3fc$require$AbortError(undefined, {\n                cause: options.signal.reason\n            }));\n        };\n        if (options.signal.aborted) $ibaza.nextTick(abort);\n        else {\n            $72f4a4664289a3fc$var$addAbortListener = $72f4a4664289a3fc$var$addAbortListener || (parcelRequire(\"kDFyU\")).addAbortListener;\n            const disposable = $72f4a4664289a3fc$var$addAbortListener(options.signal, abort);\n            const originalCallback = callback;\n            callback = $72f4a4664289a3fc$require$once((...args)=>{\n                disposable[$72f4a4664289a3fc$require$SymbolDispose]();\n                originalCallback.apply(stream, args);\n            });\n        }\n    }\n    const resolverFn = (...args)=>{\n        if (!isAborted) $ibaza.nextTick(()=>callback.apply(stream, args));\n    };\n    $72f4a4664289a3fc$require$PromisePrototypeThen(stream[$72f4a4664289a3fc$require$kIsClosedPromise].promise, resolverFn, resolverFn);\n    return $72f4a4664289a3fc$var$nop;\n}\nfunction $72f4a4664289a3fc$var$finished(stream, opts) {\n    var _opts;\n    let autoCleanup = false;\n    if (opts === null) opts = $72f4a4664289a3fc$require$kEmptyObject;\n    if ((_opts = opts) !== null && _opts !== undefined && _opts.cleanup) {\n        $72f4a4664289a3fc$require$validateBoolean(opts.cleanup, 'cleanup');\n        autoCleanup = opts.cleanup;\n    }\n    return new $72f4a4664289a3fc$require$Promise((resolve, reject)=>{\n        const cleanup = $72f4a4664289a3fc$var$eos(stream, opts, (err)=>{\n            if (autoCleanup) cleanup();\n            if (err) reject(err);\n            else resolve();\n        });\n    });\n}\nmodule.exports = $72f4a4664289a3fc$var$eos;\nmodule.exports.finished = $72f4a4664289a3fc$var$finished;\n\n});\nparcelRegister(\"geuoF\", function(module, exports) {\n/* eslint jsdoc/require-jsdoc: \"error\" */ 'use strict';\n\nvar $1by5F = parcelRequire(\"1by5F\");\nvar $bd158850c742705e$require$ArrayIsArray = $1by5F.ArrayIsArray;\nvar $bd158850c742705e$require$ArrayPrototypeIncludes = $1by5F.ArrayPrototypeIncludes;\nvar $bd158850c742705e$require$ArrayPrototypeJoin = $1by5F.ArrayPrototypeJoin;\nvar $bd158850c742705e$require$ArrayPrototypeMap = $1by5F.ArrayPrototypeMap;\nvar $bd158850c742705e$require$NumberIsInteger = $1by5F.NumberIsInteger;\nvar $bd158850c742705e$require$NumberIsNaN = $1by5F.NumberIsNaN;\nvar $bd158850c742705e$require$NumberMAX_SAFE_INTEGER = $1by5F.NumberMAX_SAFE_INTEGER;\nvar $bd158850c742705e$require$NumberMIN_SAFE_INTEGER = $1by5F.NumberMIN_SAFE_INTEGER;\nvar $bd158850c742705e$require$NumberParseInt = $1by5F.NumberParseInt;\nvar $bd158850c742705e$require$ObjectPrototypeHasOwnProperty = $1by5F.ObjectPrototypeHasOwnProperty;\nvar $bd158850c742705e$require$RegExpPrototypeExec = $1by5F.RegExpPrototypeExec;\nvar $bd158850c742705e$require$String = $1by5F.String;\nvar $bd158850c742705e$require$StringPrototypeToUpperCase = $1by5F.StringPrototypeToUpperCase;\nvar $bd158850c742705e$require$StringPrototypeTrim = $1by5F.StringPrototypeTrim;\n\nvar $7ynhX = parcelRequire(\"7ynhX\");\nconst { hideStackFrames: $bd158850c742705e$var$hideStackFrames, codes: { ERR_SOCKET_BAD_PORT: $bd158850c742705e$var$ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE: $bd158850c742705e$var$ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE: $bd158850c742705e$var$ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE: $bd158850c742705e$var$ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL: $bd158850c742705e$var$ERR_UNKNOWN_SIGNAL } } = $7ynhX;\n\nvar $kDFyU = parcelRequire(\"kDFyU\");\nconst { normalizeEncoding: $bd158850c742705e$var$normalizeEncoding } = $kDFyU;\n\nvar $kDFyU = parcelRequire(\"kDFyU\");\nconst { isAsyncFunction: $bd158850c742705e$var$isAsyncFunction, isArrayBufferView: $bd158850c742705e$var$isArrayBufferView } = $kDFyU.types;\nconst $bd158850c742705e$var$signals = {};\n/**\n * @param {*} value\n * @returns {boolean}\n */ function $bd158850c742705e$var$isInt32(value) {\n    return value === (value | 0);\n}\n/**\n * @param {*} value\n * @returns {boolean}\n */ function $bd158850c742705e$var$isUint32(value) {\n    return value === value >>> 0;\n}\nconst $bd158850c742705e$var$octalReg = /^[0-7]+$/;\nconst $bd158850c742705e$var$modeDesc = 'must be a 32-bit unsigned integer or an octal string';\n/**\n * Parse and validate values that will be converted into mode_t (the S_*\n * constants). Only valid numbers and octal strings are allowed. They could be\n * converted to 32-bit unsigned integers or non-negative signed integers in the\n * C++ land, but any value higher than 0o777 will result in platform-specific\n * behaviors.\n * @param {*} value Values to be validated\n * @param {string} name Name of the argument\n * @param {number} [def] If specified, will be returned for invalid values\n * @returns {number}\n */ function $bd158850c742705e$var$parseFileMode(value, name, def) {\n    if (typeof value === 'undefined') value = def;\n    if (typeof value === 'string') {\n        if ($bd158850c742705e$require$RegExpPrototypeExec($bd158850c742705e$var$octalReg, value) === null) throw new $bd158850c742705e$var$ERR_INVALID_ARG_VALUE(name, value, $bd158850c742705e$var$modeDesc);\n        value = $bd158850c742705e$require$NumberParseInt(value, 8);\n    }\n    $bd158850c742705e$var$validateUint32(value, name);\n    return value;\n}\n/**\n * @callback validateInteger\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */ /** @type {validateInteger} */ const $bd158850c742705e$var$validateInteger = $bd158850c742705e$var$hideStackFrames((value, name, min = $bd158850c742705e$require$NumberMIN_SAFE_INTEGER, max = $bd158850c742705e$require$NumberMAX_SAFE_INTEGER)=>{\n    if (typeof value !== 'number') throw new $bd158850c742705e$var$ERR_INVALID_ARG_TYPE(name, 'number', value);\n    if (!$bd158850c742705e$require$NumberIsInteger(value)) throw new $bd158850c742705e$var$ERR_OUT_OF_RANGE(name, 'an integer', value);\n    if (value < min || value > max) throw new $bd158850c742705e$var$ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n});\n/**\n * @callback validateInt32\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */ /** @type {validateInt32} */ const $bd158850c742705e$var$validateInt32 = $bd158850c742705e$var$hideStackFrames((value, name, min = -2147483648, max = 2147483647)=>{\n    // The defaults for min and max correspond to the limits of 32-bit integers.\n    if (typeof value !== 'number') throw new $bd158850c742705e$var$ERR_INVALID_ARG_TYPE(name, 'number', value);\n    if (!$bd158850c742705e$require$NumberIsInteger(value)) throw new $bd158850c742705e$var$ERR_OUT_OF_RANGE(name, 'an integer', value);\n    if (value < min || value > max) throw new $bd158850c742705e$var$ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n});\n/**\n * @callback validateUint32\n * @param {*} value\n * @param {string} name\n * @param {number|boolean} [positive=false]\n * @returns {asserts value is number}\n */ /** @type {validateUint32} */ const $bd158850c742705e$var$validateUint32 = $bd158850c742705e$var$hideStackFrames((value, name, positive = false)=>{\n    if (typeof value !== 'number') throw new $bd158850c742705e$var$ERR_INVALID_ARG_TYPE(name, 'number', value);\n    if (!$bd158850c742705e$require$NumberIsInteger(value)) throw new $bd158850c742705e$var$ERR_OUT_OF_RANGE(name, 'an integer', value);\n    const min = positive ? 1 : 0;\n    // 2 ** 32 === 4294967296\n    const max = 4294967295;\n    if (value < min || value > max) throw new $bd158850c742705e$var$ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n});\n/**\n * @callback validateString\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string}\n */ /** @type {validateString} */ function $bd158850c742705e$var$validateString(value, name) {\n    if (typeof value !== 'string') throw new $bd158850c742705e$var$ERR_INVALID_ARG_TYPE(name, 'string', value);\n}\n/**\n * @callback validateNumber\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */ /** @type {validateNumber} */ function $bd158850c742705e$var$validateNumber(value, name, min, max) {\n    if (typeof value !== 'number') throw new $bd158850c742705e$var$ERR_INVALID_ARG_TYPE(name, 'number', value);\n    if (min != null && value < min || max != null && value > max || (min != null || max != null) && $bd158850c742705e$require$NumberIsNaN(value)) throw new $bd158850c742705e$var$ERR_OUT_OF_RANGE(name, `${min != null ? `>= ${min}` : ''}${min != null && max != null ? ' && ' : ''}${max != null ? `<= ${max}` : ''}`, value);\n}\n/**\n * @callback validateOneOf\n * @template T\n * @param {T} value\n * @param {string} name\n * @param {T[]} oneOf\n */ /** @type {validateOneOf} */ const $bd158850c742705e$var$validateOneOf = $bd158850c742705e$var$hideStackFrames((value, name, oneOf)=>{\n    if (!$bd158850c742705e$require$ArrayPrototypeIncludes(oneOf, value)) {\n        const allowed = $bd158850c742705e$require$ArrayPrototypeJoin($bd158850c742705e$require$ArrayPrototypeMap(oneOf, (v)=>typeof v === 'string' ? `'${v}'` : $bd158850c742705e$require$String(v)), ', ');\n        const reason = 'must be one of: ' + allowed;\n        throw new $bd158850c742705e$var$ERR_INVALID_ARG_VALUE(name, value, reason);\n    }\n});\n/**\n * @callback validateBoolean\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is boolean}\n */ /** @type {validateBoolean} */ function $bd158850c742705e$var$validateBoolean(value, name) {\n    if (typeof value !== 'boolean') throw new $bd158850c742705e$var$ERR_INVALID_ARG_TYPE(name, 'boolean', value);\n}\n/**\n * @param {any} options\n * @param {string} key\n * @param {boolean} defaultValue\n * @returns {boolean}\n */ function $bd158850c742705e$var$getOwnPropertyValueOrDefault(options, key, defaultValue) {\n    return options == null || !$bd158850c742705e$require$ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];\n}\n/**\n * @callback validateObject\n * @param {*} value\n * @param {string} name\n * @param {{\n *   allowArray?: boolean,\n *   allowFunction?: boolean,\n *   nullable?: boolean\n * }} [options]\n */ /** @type {validateObject} */ const $bd158850c742705e$var$validateObject = $bd158850c742705e$var$hideStackFrames((value, name, options = null)=>{\n    const allowArray = $bd158850c742705e$var$getOwnPropertyValueOrDefault(options, 'allowArray', false);\n    const allowFunction = $bd158850c742705e$var$getOwnPropertyValueOrDefault(options, 'allowFunction', false);\n    const nullable = $bd158850c742705e$var$getOwnPropertyValueOrDefault(options, 'nullable', false);\n    if (!nullable && value === null || !allowArray && $bd158850c742705e$require$ArrayIsArray(value) || typeof value !== 'object' && (!allowFunction || typeof value !== 'function')) throw new $bd158850c742705e$var$ERR_INVALID_ARG_TYPE(name, 'Object', value);\n});\n/**\n * @callback validateDictionary - We are using the Web IDL Standard definition\n *                                of \"dictionary\" here, which means any value\n *                                whose Type is either Undefined, Null, or\n *                                Object (which includes functions).\n * @param {*} value\n * @param {string} name\n * @see https://webidl.spec.whatwg.org/#es-dictionary\n * @see https://tc39.es/ecma262/#table-typeof-operator-results\n */ /** @type {validateDictionary} */ const $bd158850c742705e$var$validateDictionary = $bd158850c742705e$var$hideStackFrames((value, name)=>{\n    if (value != null && typeof value !== 'object' && typeof value !== 'function') throw new $bd158850c742705e$var$ERR_INVALID_ARG_TYPE(name, 'a dictionary', value);\n});\n/**\n * @callback validateArray\n * @param {*} value\n * @param {string} name\n * @param {number} [minLength]\n * @returns {asserts value is any[]}\n */ /** @type {validateArray} */ const $bd158850c742705e$var$validateArray = $bd158850c742705e$var$hideStackFrames((value, name, minLength = 0)=>{\n    if (!$bd158850c742705e$require$ArrayIsArray(value)) throw new $bd158850c742705e$var$ERR_INVALID_ARG_TYPE(name, 'Array', value);\n    if (value.length < minLength) {\n        const reason = `must be longer than ${minLength}`;\n        throw new $bd158850c742705e$var$ERR_INVALID_ARG_VALUE(name, value, reason);\n    }\n});\n/**\n * @callback validateStringArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string[]}\n */ /** @type {validateStringArray} */ function $bd158850c742705e$var$validateStringArray(value, name) {\n    $bd158850c742705e$var$validateArray(value, name);\n    for(let i = 0; i < value.length; i++)$bd158850c742705e$var$validateString(value[i], `${name}[${i}]`);\n}\n/**\n * @callback validateBooleanArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is boolean[]}\n */ /** @type {validateBooleanArray} */ function $bd158850c742705e$var$validateBooleanArray(value, name) {\n    $bd158850c742705e$var$validateArray(value, name);\n    for(let i = 0; i < value.length; i++)$bd158850c742705e$var$validateBoolean(value[i], `${name}[${i}]`);\n}\n/**\n * @callback validateAbortSignalArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is AbortSignal[]}\n */ /** @type {validateAbortSignalArray} */ function $bd158850c742705e$var$validateAbortSignalArray(value, name) {\n    $bd158850c742705e$var$validateArray(value, name);\n    for(let i = 0; i < value.length; i++){\n        const signal = value[i];\n        const indexedName = `${name}[${i}]`;\n        if (signal == null) throw new $bd158850c742705e$var$ERR_INVALID_ARG_TYPE(indexedName, 'AbortSignal', signal);\n        $bd158850c742705e$var$validateAbortSignal(signal, indexedName);\n    }\n}\n/**\n * @param {*} signal\n * @param {string} [name='signal']\n * @returns {asserts signal is keyof signals}\n */ function $bd158850c742705e$var$validateSignalName(signal, name = 'signal') {\n    $bd158850c742705e$var$validateString(signal, name);\n    if ($bd158850c742705e$var$signals[signal] === undefined) {\n        if ($bd158850c742705e$var$signals[$bd158850c742705e$require$StringPrototypeToUpperCase(signal)] !== undefined) throw new $bd158850c742705e$var$ERR_UNKNOWN_SIGNAL(signal + ' (signals must use all capital letters)');\n        throw new $bd158850c742705e$var$ERR_UNKNOWN_SIGNAL(signal);\n    }\n}\n/**\n * @callback validateBuffer\n * @param {*} buffer\n * @param {string} [name='buffer']\n * @returns {asserts buffer is ArrayBufferView}\n */ /** @type {validateBuffer} */ const $bd158850c742705e$var$validateBuffer = $bd158850c742705e$var$hideStackFrames((buffer, name = 'buffer')=>{\n    if (!$bd158850c742705e$var$isArrayBufferView(buffer)) throw new $bd158850c742705e$var$ERR_INVALID_ARG_TYPE(name, [\n        'Buffer',\n        'TypedArray',\n        'DataView'\n    ], buffer);\n});\n/**\n * @param {string} data\n * @param {string} encoding\n */ function $bd158850c742705e$var$validateEncoding(data, encoding) {\n    const normalizedEncoding = $bd158850c742705e$var$normalizeEncoding(encoding);\n    const length = data.length;\n    if (normalizedEncoding === 'hex' && length % 2 !== 0) throw new $bd158850c742705e$var$ERR_INVALID_ARG_VALUE('encoding', encoding, `is invalid for data of length ${length}`);\n}\n/**\n * Check that the port number is not NaN when coerced to a number,\n * is an integer and that it falls within the legal range of port numbers.\n * @param {*} port\n * @param {string} [name='Port']\n * @param {boolean} [allowZero=true]\n * @returns {number}\n */ function $bd158850c742705e$var$validatePort(port, name = 'Port', allowZero = true) {\n    if (typeof port !== 'number' && typeof port !== 'string' || typeof port === 'string' && $bd158850c742705e$require$StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 0xffff || port === 0 && !allowZero) throw new $bd158850c742705e$var$ERR_SOCKET_BAD_PORT(name, port, allowZero);\n    return port | 0;\n}\n/**\n * @callback validateAbortSignal\n * @param {*} signal\n * @param {string} name\n */ /** @type {validateAbortSignal} */ const $bd158850c742705e$var$validateAbortSignal = $bd158850c742705e$var$hideStackFrames((signal, name)=>{\n    if (signal !== undefined && (signal === null || typeof signal !== 'object' || !('aborted' in signal))) throw new $bd158850c742705e$var$ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal);\n});\n/**\n * @callback validateFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */ /** @type {validateFunction} */ const $bd158850c742705e$var$validateFunction = $bd158850c742705e$var$hideStackFrames((value, name)=>{\n    if (typeof value !== 'function') throw new $bd158850c742705e$var$ERR_INVALID_ARG_TYPE(name, 'Function', value);\n});\n/**\n * @callback validatePlainFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */ /** @type {validatePlainFunction} */ const $bd158850c742705e$var$validatePlainFunction = $bd158850c742705e$var$hideStackFrames((value, name)=>{\n    if (typeof value !== 'function' || $bd158850c742705e$var$isAsyncFunction(value)) throw new $bd158850c742705e$var$ERR_INVALID_ARG_TYPE(name, 'Function', value);\n});\n/**\n * @callback validateUndefined\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is undefined}\n */ /** @type {validateUndefined} */ const $bd158850c742705e$var$validateUndefined = $bd158850c742705e$var$hideStackFrames((value, name)=>{\n    if (value !== undefined) throw new $bd158850c742705e$var$ERR_INVALID_ARG_TYPE(name, 'undefined', value);\n});\n/**\n * @template T\n * @param {T} value\n * @param {string} name\n * @param {T[]} union\n */ function $bd158850c742705e$var$validateUnion(value, name, union) {\n    if (!$bd158850c742705e$require$ArrayPrototypeIncludes(union, value)) throw new $bd158850c742705e$var$ERR_INVALID_ARG_TYPE(name, `('${$bd158850c742705e$require$ArrayPrototypeJoin(union, '|')}')`, value);\n}\n/*\n  The rules for the Link header field are described here:\n  https://www.rfc-editor.org/rfc/rfc8288.html#section-3\n\n  This regex validates any string surrounded by angle brackets\n  (not necessarily a valid URI reference) followed by zero or more\n  link-params separated by semicolons.\n*/ const $bd158850c742705e$var$linkValueRegExp = /^(?:<[^>]*>)(?:\\s*;\\s*[^;\"\\s]+(?:=(\")?[^;\"\\s]*\\1)?)*$/;\n/**\n * @param {any} value\n * @param {string} name\n */ function $bd158850c742705e$var$validateLinkHeaderFormat(value, name) {\n    if (typeof value === 'undefined' || !$bd158850c742705e$require$RegExpPrototypeExec($bd158850c742705e$var$linkValueRegExp, value)) throw new $bd158850c742705e$var$ERR_INVALID_ARG_VALUE(name, value, 'must be an array or string of format \"</styles.css>; rel=preload; as=style\"');\n}\n/**\n * @param {any} hints\n * @return {string}\n */ function $bd158850c742705e$var$validateLinkHeaderValue(hints) {\n    if (typeof hints === 'string') {\n        $bd158850c742705e$var$validateLinkHeaderFormat(hints, 'hints');\n        return hints;\n    } else if ($bd158850c742705e$require$ArrayIsArray(hints)) {\n        const hintsLength = hints.length;\n        let result = '';\n        if (hintsLength === 0) return result;\n        for(let i = 0; i < hintsLength; i++){\n            const link = hints[i];\n            $bd158850c742705e$var$validateLinkHeaderFormat(link, 'hints');\n            result += link;\n            if (i !== hintsLength - 1) result += ', ';\n        }\n        return result;\n    }\n    throw new $bd158850c742705e$var$ERR_INVALID_ARG_VALUE('hints', hints, 'must be an array or string of format \"</styles.css>; rel=preload; as=style\"');\n}\nmodule.exports = {\n    isInt32: $bd158850c742705e$var$isInt32,\n    isUint32: $bd158850c742705e$var$isUint32,\n    parseFileMode: $bd158850c742705e$var$parseFileMode,\n    validateArray: $bd158850c742705e$var$validateArray,\n    validateStringArray: $bd158850c742705e$var$validateStringArray,\n    validateBooleanArray: $bd158850c742705e$var$validateBooleanArray,\n    validateAbortSignalArray: $bd158850c742705e$var$validateAbortSignalArray,\n    validateBoolean: $bd158850c742705e$var$validateBoolean,\n    validateBuffer: $bd158850c742705e$var$validateBuffer,\n    validateDictionary: $bd158850c742705e$var$validateDictionary,\n    validateEncoding: $bd158850c742705e$var$validateEncoding,\n    validateFunction: $bd158850c742705e$var$validateFunction,\n    validateInt32: $bd158850c742705e$var$validateInt32,\n    validateInteger: $bd158850c742705e$var$validateInteger,\n    validateNumber: $bd158850c742705e$var$validateNumber,\n    validateObject: $bd158850c742705e$var$validateObject,\n    validateOneOf: $bd158850c742705e$var$validateOneOf,\n    validatePlainFunction: $bd158850c742705e$var$validatePlainFunction,\n    validatePort: $bd158850c742705e$var$validatePort,\n    validateSignalName: $bd158850c742705e$var$validateSignalName,\n    validateString: $bd158850c742705e$var$validateString,\n    validateUint32: $bd158850c742705e$var$validateUint32,\n    validateUndefined: $bd158850c742705e$var$validateUndefined,\n    validateUnion: $bd158850c742705e$var$validateUnion,\n    validateAbortSignal: $bd158850c742705e$var$validateAbortSignal,\n    validateLinkHeaderValue: $bd158850c742705e$var$validateLinkHeaderValue\n};\n\n});\n\n\n\nparcelRegister(\"ikZyt\", function(module, exports) {\n'use strict';\n\nvar $1by5F = parcelRequire(\"1by5F\");\nvar $d599d7d1fba2dc7c$require$StringPrototypeSlice = $1by5F.StringPrototypeSlice;\nvar $d599d7d1fba2dc7c$require$SymbolIterator = $1by5F.SymbolIterator;\nvar $d599d7d1fba2dc7c$require$TypedArrayPrototypeSet = $1by5F.TypedArrayPrototypeSet;\nvar $d599d7d1fba2dc7c$require$Uint8Array = $1by5F.Uint8Array;\n\nvar $N0o3H = parcelRequire(\"N0o3H\");\nvar $d599d7d1fba2dc7c$require$Buffer = $N0o3H.Buffer;\n\nvar $kDFyU = parcelRequire(\"kDFyU\");\nvar $d599d7d1fba2dc7c$require$inspect = $kDFyU.inspect;\nmodule.exports = class BufferList {\n    constructor(){\n        this.head = null;\n        this.tail = null;\n        this.length = 0;\n    }\n    push(v) {\n        const entry = {\n            data: v,\n            next: null\n        };\n        if (this.length > 0) this.tail.next = entry;\n        else this.head = entry;\n        this.tail = entry;\n        ++this.length;\n    }\n    unshift(v) {\n        const entry = {\n            data: v,\n            next: this.head\n        };\n        if (this.length === 0) this.tail = entry;\n        this.head = entry;\n        ++this.length;\n    }\n    shift() {\n        if (this.length === 0) return;\n        const ret = this.head.data;\n        if (this.length === 1) this.head = this.tail = null;\n        else this.head = this.head.next;\n        --this.length;\n        return ret;\n    }\n    clear() {\n        this.head = this.tail = null;\n        this.length = 0;\n    }\n    join(s) {\n        if (this.length === 0) return '';\n        let p = this.head;\n        let ret = '' + p.data;\n        while((p = p.next) !== null)ret += s + p.data;\n        return ret;\n    }\n    concat(n) {\n        if (this.length === 0) return $d599d7d1fba2dc7c$require$Buffer.alloc(0);\n        const ret = $d599d7d1fba2dc7c$require$Buffer.allocUnsafe(n >>> 0);\n        let p = this.head;\n        let i = 0;\n        while(p){\n            $d599d7d1fba2dc7c$require$TypedArrayPrototypeSet(ret, p.data, i);\n            i += p.data.length;\n            p = p.next;\n        }\n        return ret;\n    }\n    // Consumes a specified amount of bytes or characters from the buffered data.\n    consume(n, hasStrings) {\n        const data = this.head.data;\n        if (n < data.length) {\n            // `slice` is the same for buffers and strings.\n            const slice = data.slice(0, n);\n            this.head.data = data.slice(n);\n            return slice;\n        }\n        if (n === data.length) // First chunk is a perfect match.\n        return this.shift();\n        // Result spans more than one buffer.\n        return hasStrings ? this._getString(n) : this._getBuffer(n);\n    }\n    first() {\n        return this.head.data;\n    }\n    *[$d599d7d1fba2dc7c$require$SymbolIterator]() {\n        for(let p = this.head; p; p = p.next)yield p.data;\n    }\n    // Consumes a specified amount of characters from the buffered data.\n    _getString(n) {\n        let ret = '';\n        let p = this.head;\n        let c = 0;\n        do {\n            const str = p.data;\n            if (n > str.length) {\n                ret += str;\n                n -= str.length;\n            } else {\n                if (n === str.length) {\n                    ret += str;\n                    ++c;\n                    if (p.next) this.head = p.next;\n                    else this.head = this.tail = null;\n                } else {\n                    ret += $d599d7d1fba2dc7c$require$StringPrototypeSlice(str, 0, n);\n                    this.head = p;\n                    p.data = $d599d7d1fba2dc7c$require$StringPrototypeSlice(str, n);\n                }\n                break;\n            }\n            ++c;\n        }while ((p = p.next) !== null);\n        this.length -= c;\n        return ret;\n    }\n    // Consumes a specified amount of bytes from the buffered data.\n    _getBuffer(n) {\n        const ret = $d599d7d1fba2dc7c$require$Buffer.allocUnsafe(n);\n        const retLen = n;\n        let p = this.head;\n        let c = 0;\n        do {\n            const buf = p.data;\n            if (n > buf.length) {\n                $d599d7d1fba2dc7c$require$TypedArrayPrototypeSet(ret, buf, retLen - n);\n                n -= buf.length;\n            } else {\n                if (n === buf.length) {\n                    $d599d7d1fba2dc7c$require$TypedArrayPrototypeSet(ret, buf, retLen - n);\n                    ++c;\n                    if (p.next) this.head = p.next;\n                    else this.head = this.tail = null;\n                } else {\n                    $d599d7d1fba2dc7c$require$TypedArrayPrototypeSet(ret, new $d599d7d1fba2dc7c$require$Uint8Array(buf.buffer, buf.byteOffset, n), retLen - n);\n                    this.head = p;\n                    p.data = buf.slice(n);\n                }\n                break;\n            }\n            ++c;\n        }while ((p = p.next) !== null);\n        this.length -= c;\n        return ret;\n    }\n    // Make sure the linked list only shows the minimal necessary information.\n    [Symbol.for('nodejs.util.inspect.custom')](_, options) {\n        return $d599d7d1fba2dc7c$require$inspect(this, {\n            ...options,\n            // Only inspect one level.\n            depth: 0,\n            // It should not recurse.\n            customInspect: false\n        });\n    }\n};\n\n});\n\nparcelRegister(\"7CELW\", function(module, exports) {\n'use strict';\n\nvar $ibaza = parcelRequire(\"ibaza\");\n\nvar $7ynhX = parcelRequire(\"7ynhX\");\n/* replacement end */ const { aggregateTwoErrors: $58cbb58867ae5051$var$aggregateTwoErrors, codes: { ERR_MULTIPLE_CALLBACK: $58cbb58867ae5051$var$ERR_MULTIPLE_CALLBACK }, AbortError: $58cbb58867ae5051$var$AbortError } = $7ynhX;\n\nvar $1by5F = parcelRequire(\"1by5F\");\nvar $58cbb58867ae5051$require$Symbol = $1by5F.Symbol;\n\nvar $eY1Gs = parcelRequire(\"eY1Gs\");\nvar $58cbb58867ae5051$require$kIsDestroyed = $eY1Gs.kIsDestroyed;\nvar $58cbb58867ae5051$require$isDestroyed = $eY1Gs.isDestroyed;\nvar $58cbb58867ae5051$require$isFinished = $eY1Gs.isFinished;\nvar $58cbb58867ae5051$require$isServerRequest = $eY1Gs.isServerRequest;\nconst $58cbb58867ae5051$var$kDestroy = $58cbb58867ae5051$require$Symbol('kDestroy');\nconst $58cbb58867ae5051$var$kConstruct = $58cbb58867ae5051$require$Symbol('kConstruct');\nfunction $58cbb58867ae5051$var$checkError(err, w, r) {\n    if (err) {\n        // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n        err.stack // eslint-disable-line no-unused-expressions\n        ;\n        if (w && !w.errored) w.errored = err;\n        if (r && !r.errored) r.errored = err;\n    }\n}\n// Backwards compat. cb() is undocumented and unused in core but\n// unfortunately might be used by modules.\nfunction $58cbb58867ae5051$var$destroy(err, cb) {\n    const r = this._readableState;\n    const w = this._writableState;\n    // With duplex streams we use the writable side for state.\n    const s = w || r;\n    if (w !== null && w !== undefined && w.destroyed || r !== null && r !== undefined && r.destroyed) {\n        if (typeof cb === 'function') cb();\n        return this;\n    }\n    // We set destroyed to true before firing error callbacks in order\n    // to make it re-entrance safe in case destroy() is called within callbacks\n    $58cbb58867ae5051$var$checkError(err, w, r);\n    if (w) w.destroyed = true;\n    if (r) r.destroyed = true;\n    // If still constructing then defer calling _destroy.\n    if (!s.constructed) this.once($58cbb58867ae5051$var$kDestroy, function(er) {\n        $58cbb58867ae5051$var$_destroy(this, $58cbb58867ae5051$var$aggregateTwoErrors(er, err), cb);\n    });\n    else $58cbb58867ae5051$var$_destroy(this, err, cb);\n    return this;\n}\nfunction $58cbb58867ae5051$var$_destroy(self, err, cb) {\n    let called = false;\n    function onDestroy(err) {\n        if (called) return;\n        called = true;\n        const r = self._readableState;\n        const w = self._writableState;\n        $58cbb58867ae5051$var$checkError(err, w, r);\n        if (w) w.closed = true;\n        if (r) r.closed = true;\n        if (typeof cb === 'function') cb(err);\n        if (err) $ibaza.nextTick($58cbb58867ae5051$var$emitErrorCloseNT, self, err);\n        else $ibaza.nextTick($58cbb58867ae5051$var$emitCloseNT, self);\n    }\n    try {\n        self._destroy(err || null, onDestroy);\n    } catch (err) {\n        onDestroy(err);\n    }\n}\nfunction $58cbb58867ae5051$var$emitErrorCloseNT(self, err) {\n    $58cbb58867ae5051$var$emitErrorNT(self, err);\n    $58cbb58867ae5051$var$emitCloseNT(self);\n}\nfunction $58cbb58867ae5051$var$emitCloseNT(self) {\n    const r = self._readableState;\n    const w = self._writableState;\n    if (w) w.closeEmitted = true;\n    if (r) r.closeEmitted = true;\n    if (w !== null && w !== undefined && w.emitClose || r !== null && r !== undefined && r.emitClose) self.emit('close');\n}\nfunction $58cbb58867ae5051$var$emitErrorNT(self, err) {\n    const r = self._readableState;\n    const w = self._writableState;\n    if (w !== null && w !== undefined && w.errorEmitted || r !== null && r !== undefined && r.errorEmitted) return;\n    if (w) w.errorEmitted = true;\n    if (r) r.errorEmitted = true;\n    self.emit('error', err);\n}\nfunction $58cbb58867ae5051$var$undestroy() {\n    const r = this._readableState;\n    const w = this._writableState;\n    if (r) {\n        r.constructed = true;\n        r.closed = false;\n        r.closeEmitted = false;\n        r.destroyed = false;\n        r.errored = null;\n        r.errorEmitted = false;\n        r.reading = false;\n        r.ended = r.readable === false;\n        r.endEmitted = r.readable === false;\n    }\n    if (w) {\n        w.constructed = true;\n        w.destroyed = false;\n        w.closed = false;\n        w.closeEmitted = false;\n        w.errored = null;\n        w.errorEmitted = false;\n        w.finalCalled = false;\n        w.prefinished = false;\n        w.ended = w.writable === false;\n        w.ending = w.writable === false;\n        w.finished = w.writable === false;\n    }\n}\nfunction $58cbb58867ae5051$var$errorOrDestroy(stream, err, sync) {\n    // We have tests that rely on errors being emitted\n    // in the same tick, so changing this is semver major.\n    // For now when you opt-in to autoDestroy we allow\n    // the error to be emitted nextTick. In a future\n    // semver major update we should change the default to this.\n    const r = stream._readableState;\n    const w = stream._writableState;\n    if (w !== null && w !== undefined && w.destroyed || r !== null && r !== undefined && r.destroyed) return this;\n    if (r !== null && r !== undefined && r.autoDestroy || w !== null && w !== undefined && w.autoDestroy) stream.destroy(err);\n    else if (err) {\n        // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n        err.stack // eslint-disable-line no-unused-expressions\n        ;\n        if (w && !w.errored) w.errored = err;\n        if (r && !r.errored) r.errored = err;\n        if (sync) $ibaza.nextTick($58cbb58867ae5051$var$emitErrorNT, stream, err);\n        else $58cbb58867ae5051$var$emitErrorNT(stream, err);\n    }\n}\nfunction $58cbb58867ae5051$var$construct(stream, cb) {\n    if (typeof stream._construct !== 'function') return;\n    const r = stream._readableState;\n    const w = stream._writableState;\n    if (r) r.constructed = false;\n    if (w) w.constructed = false;\n    stream.once($58cbb58867ae5051$var$kConstruct, cb);\n    if (stream.listenerCount($58cbb58867ae5051$var$kConstruct) > 1) // Duplex\n    return;\n    $ibaza.nextTick($58cbb58867ae5051$var$constructNT, stream);\n}\nfunction $58cbb58867ae5051$var$constructNT(stream) {\n    let called = false;\n    function onConstruct(err) {\n        if (called) {\n            $58cbb58867ae5051$var$errorOrDestroy(stream, err !== null && err !== undefined ? err : new $58cbb58867ae5051$var$ERR_MULTIPLE_CALLBACK());\n            return;\n        }\n        called = true;\n        const r = stream._readableState;\n        const w = stream._writableState;\n        const s = w || r;\n        if (r) r.constructed = true;\n        if (w) w.constructed = true;\n        if (s.destroyed) stream.emit($58cbb58867ae5051$var$kDestroy, err);\n        else if (err) $58cbb58867ae5051$var$errorOrDestroy(stream, err, true);\n        else $ibaza.nextTick($58cbb58867ae5051$var$emitConstructNT, stream);\n    }\n    try {\n        stream._construct((err)=>{\n            $ibaza.nextTick(onConstruct, err);\n        });\n    } catch (err) {\n        $ibaza.nextTick(onConstruct, err);\n    }\n}\nfunction $58cbb58867ae5051$var$emitConstructNT(stream) {\n    stream.emit($58cbb58867ae5051$var$kConstruct);\n}\nfunction $58cbb58867ae5051$var$isRequest(stream) {\n    return (stream === null || stream === undefined ? undefined : stream.setHeader) && typeof stream.abort === 'function';\n}\nfunction $58cbb58867ae5051$var$emitCloseLegacy(stream) {\n    stream.emit('close');\n}\nfunction $58cbb58867ae5051$var$emitErrorCloseLegacy(stream, err) {\n    stream.emit('error', err);\n    $ibaza.nextTick($58cbb58867ae5051$var$emitCloseLegacy, stream);\n}\n// Normalize destroy for legacy.\nfunction $58cbb58867ae5051$var$destroyer(stream, err) {\n    if (!stream || $58cbb58867ae5051$require$isDestroyed(stream)) return;\n    if (!err && !$58cbb58867ae5051$require$isFinished(stream)) err = new $58cbb58867ae5051$var$AbortError();\n    // TODO: Remove isRequest branches.\n    if ($58cbb58867ae5051$require$isServerRequest(stream)) {\n        stream.socket = null;\n        stream.destroy(err);\n    } else if ($58cbb58867ae5051$var$isRequest(stream)) stream.abort();\n    else if ($58cbb58867ae5051$var$isRequest(stream.req)) stream.req.abort();\n    else if (typeof stream.destroy === 'function') stream.destroy(err);\n    else if (typeof stream.close === 'function') // TODO: Don't lose err?\n    stream.close();\n    else if (err) $ibaza.nextTick($58cbb58867ae5051$var$emitErrorCloseLegacy, stream, err);\n    else $ibaza.nextTick($58cbb58867ae5051$var$emitCloseLegacy, stream);\n    if (!stream.destroyed) stream[$58cbb58867ae5051$require$kIsDestroyed] = true;\n}\nmodule.exports = {\n    construct: $58cbb58867ae5051$var$construct,\n    destroyer: $58cbb58867ae5051$var$destroyer,\n    destroy: $58cbb58867ae5051$var$destroy,\n    undestroy: $58cbb58867ae5051$var$undestroy,\n    errorOrDestroy: $58cbb58867ae5051$var$errorOrDestroy\n};\n\n});\n\nparcelRegister(\"bKeTG\", function(module, exports) {\n'use strict';\n\nvar $1by5F = parcelRequire(\"1by5F\");\nvar $88cf8bd7837b28dd$require$MathFloor = $1by5F.MathFloor;\nvar $88cf8bd7837b28dd$require$NumberIsInteger = $1by5F.NumberIsInteger;\n\nvar $geuoF = parcelRequire(\"geuoF\");\nvar $88cf8bd7837b28dd$require$validateInteger = $geuoF.validateInteger;\n\nvar $7ynhX = parcelRequire(\"7ynhX\");\nconst { ERR_INVALID_ARG_VALUE: $88cf8bd7837b28dd$var$ERR_INVALID_ARG_VALUE } = $7ynhX.codes;\nlet $88cf8bd7837b28dd$var$defaultHighWaterMarkBytes = 16384;\nlet $88cf8bd7837b28dd$var$defaultHighWaterMarkObjectMode = 16;\nfunction $88cf8bd7837b28dd$var$highWaterMarkFrom(options, isDuplex, duplexKey) {\n    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n}\nfunction $88cf8bd7837b28dd$var$getDefaultHighWaterMark(objectMode) {\n    return objectMode ? $88cf8bd7837b28dd$var$defaultHighWaterMarkObjectMode : $88cf8bd7837b28dd$var$defaultHighWaterMarkBytes;\n}\nfunction $88cf8bd7837b28dd$var$setDefaultHighWaterMark(objectMode, value) {\n    $88cf8bd7837b28dd$require$validateInteger(value, 'value', 0);\n    if (objectMode) $88cf8bd7837b28dd$var$defaultHighWaterMarkObjectMode = value;\n    else $88cf8bd7837b28dd$var$defaultHighWaterMarkBytes = value;\n}\nfunction $88cf8bd7837b28dd$var$getHighWaterMark(state, options, duplexKey, isDuplex) {\n    const hwm = $88cf8bd7837b28dd$var$highWaterMarkFrom(options, isDuplex, duplexKey);\n    if (hwm != null) {\n        if (!$88cf8bd7837b28dd$require$NumberIsInteger(hwm) || hwm < 0) {\n            const name = isDuplex ? `options.${duplexKey}` : 'options.highWaterMark';\n            throw new $88cf8bd7837b28dd$var$ERR_INVALID_ARG_VALUE(name, hwm);\n        }\n        return $88cf8bd7837b28dd$require$MathFloor(hwm);\n    }\n    // Default value\n    return $88cf8bd7837b28dd$var$getDefaultHighWaterMark(state.objectMode);\n}\nmodule.exports = {\n    getHighWaterMark: $88cf8bd7837b28dd$var$getHighWaterMark,\n    getDefaultHighWaterMark: $88cf8bd7837b28dd$var$getDefaultHighWaterMark,\n    setDefaultHighWaterMark: $88cf8bd7837b28dd$var$setDefaultHighWaterMark\n};\n\n});\n\nparcelRegister(\"jJ0xG\", function(module, exports) {\n\n$parcel$export(module.exports, \"StringDecoder\", () => $e5c2a3f70c10f900$export$63a7aa211a91ed69, (v) => $e5c2a3f70c10f900$export$63a7aa211a91ed69 = v);\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nvar $e5c2a3f70c10f900$export$63a7aa211a91ed69;\n'use strict';\n\nvar $fx8YU = parcelRequire(\"fx8YU\");\nvar $e5c2a3f70c10f900$require$Buffer = $fx8YU.Buffer;\n/*</replacement>*/ var $e5c2a3f70c10f900$var$isEncoding = $e5c2a3f70c10f900$require$Buffer.isEncoding || function(encoding) {\n    encoding = '' + encoding;\n    switch(encoding && encoding.toLowerCase()){\n        case 'hex':\n        case 'utf8':\n        case 'utf-8':\n        case 'ascii':\n        case 'binary':\n        case 'base64':\n        case 'ucs2':\n        case 'ucs-2':\n        case 'utf16le':\n        case 'utf-16le':\n        case 'raw':\n            return true;\n        default:\n            return false;\n    }\n};\nfunction $e5c2a3f70c10f900$var$_normalizeEncoding(enc) {\n    if (!enc) return 'utf8';\n    var retried;\n    while(true)switch(enc){\n        case 'utf8':\n        case 'utf-8':\n            return 'utf8';\n        case 'ucs2':\n        case 'ucs-2':\n        case 'utf16le':\n        case 'utf-16le':\n            return 'utf16le';\n        case 'latin1':\n        case 'binary':\n            return 'latin1';\n        case 'base64':\n        case 'ascii':\n        case 'hex':\n            return enc;\n        default:\n            if (retried) return; // undefined\n            enc = ('' + enc).toLowerCase();\n            retried = true;\n    }\n}\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction $e5c2a3f70c10f900$var$normalizeEncoding(enc) {\n    var nenc = $e5c2a3f70c10f900$var$_normalizeEncoding(enc);\n    if (typeof nenc !== 'string' && ($e5c2a3f70c10f900$require$Buffer.isEncoding === $e5c2a3f70c10f900$var$isEncoding || !$e5c2a3f70c10f900$var$isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n    return nenc || enc;\n}\n$e5c2a3f70c10f900$export$63a7aa211a91ed69 = $e5c2a3f70c10f900$var$StringDecoder;\nfunction $e5c2a3f70c10f900$var$StringDecoder(encoding) {\n    this.encoding = $e5c2a3f70c10f900$var$normalizeEncoding(encoding);\n    var nb;\n    switch(this.encoding){\n        case 'utf16le':\n            this.text = $e5c2a3f70c10f900$var$utf16Text;\n            this.end = $e5c2a3f70c10f900$var$utf16End;\n            nb = 4;\n            break;\n        case 'utf8':\n            this.fillLast = $e5c2a3f70c10f900$var$utf8FillLast;\n            nb = 4;\n            break;\n        case 'base64':\n            this.text = $e5c2a3f70c10f900$var$base64Text;\n            this.end = $e5c2a3f70c10f900$var$base64End;\n            nb = 3;\n            break;\n        default:\n            this.write = $e5c2a3f70c10f900$var$simpleWrite;\n            this.end = $e5c2a3f70c10f900$var$simpleEnd;\n            return;\n    }\n    this.lastNeed = 0;\n    this.lastTotal = 0;\n    this.lastChar = $e5c2a3f70c10f900$require$Buffer.allocUnsafe(nb);\n}\n$e5c2a3f70c10f900$var$StringDecoder.prototype.write = function(buf) {\n    if (buf.length === 0) return '';\n    var r;\n    var i;\n    if (this.lastNeed) {\n        r = this.fillLast(buf);\n        if (r === undefined) return '';\n        i = this.lastNeed;\n        this.lastNeed = 0;\n    } else i = 0;\n    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n    return r || '';\n};\n$e5c2a3f70c10f900$var$StringDecoder.prototype.end = $e5c2a3f70c10f900$var$utf8End;\n// Returns only complete characters in a Buffer\n$e5c2a3f70c10f900$var$StringDecoder.prototype.text = $e5c2a3f70c10f900$var$utf8Text;\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\n$e5c2a3f70c10f900$var$StringDecoder.prototype.fillLast = function(buf) {\n    if (this.lastNeed <= buf.length) {\n        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n        return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n    }\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n    this.lastNeed -= buf.length;\n};\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction $e5c2a3f70c10f900$var$utf8CheckByte(byte) {\n    if (byte <= 0x7F) return 0;\n    else if (byte >> 5 === 0x06) return 2;\n    else if (byte >> 4 === 0x0E) return 3;\n    else if (byte >> 3 === 0x1E) return 4;\n    return byte >> 6 === 0x02 ? -1 : -2;\n}\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction $e5c2a3f70c10f900$var$utf8CheckIncomplete(self, buf, i) {\n    var j = buf.length - 1;\n    if (j < i) return 0;\n    var nb = $e5c2a3f70c10f900$var$utf8CheckByte(buf[j]);\n    if (nb >= 0) {\n        if (nb > 0) self.lastNeed = nb - 1;\n        return nb;\n    }\n    if (--j < i || nb === -2) return 0;\n    nb = $e5c2a3f70c10f900$var$utf8CheckByte(buf[j]);\n    if (nb >= 0) {\n        if (nb > 0) self.lastNeed = nb - 2;\n        return nb;\n    }\n    if (--j < i || nb === -2) return 0;\n    nb = $e5c2a3f70c10f900$var$utf8CheckByte(buf[j]);\n    if (nb >= 0) {\n        if (nb > 0) {\n            if (nb === 2) nb = 0;\n            else self.lastNeed = nb - 3;\n        }\n        return nb;\n    }\n    return 0;\n}\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction $e5c2a3f70c10f900$var$utf8CheckExtraBytes(self, buf, p) {\n    if ((buf[0] & 0xC0) !== 0x80) {\n        self.lastNeed = 0;\n        return '\\ufffd';\n    }\n    if (self.lastNeed > 1 && buf.length > 1) {\n        if ((buf[1] & 0xC0) !== 0x80) {\n            self.lastNeed = 1;\n            return '\\ufffd';\n        }\n        if (self.lastNeed > 2 && buf.length > 2) {\n            if ((buf[2] & 0xC0) !== 0x80) {\n                self.lastNeed = 2;\n                return '\\ufffd';\n            }\n        }\n    }\n}\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction $e5c2a3f70c10f900$var$utf8FillLast(buf) {\n    var p = this.lastTotal - this.lastNeed;\n    var r = $e5c2a3f70c10f900$var$utf8CheckExtraBytes(this, buf, p);\n    if (r !== undefined) return r;\n    if (this.lastNeed <= buf.length) {\n        buf.copy(this.lastChar, p, 0, this.lastNeed);\n        return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n    }\n    buf.copy(this.lastChar, p, 0, buf.length);\n    this.lastNeed -= buf.length;\n}\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction $e5c2a3f70c10f900$var$utf8Text(buf, i) {\n    var total = $e5c2a3f70c10f900$var$utf8CheckIncomplete(this, buf, i);\n    if (!this.lastNeed) return buf.toString('utf8', i);\n    this.lastTotal = total;\n    var end = buf.length - (total - this.lastNeed);\n    buf.copy(this.lastChar, 0, end);\n    return buf.toString('utf8', i, end);\n}\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction $e5c2a3f70c10f900$var$utf8End(buf) {\n    var r = buf && buf.length ? this.write(buf) : '';\n    if (this.lastNeed) return r + '\\ufffd';\n    return r;\n}\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction $e5c2a3f70c10f900$var$utf16Text(buf, i) {\n    if ((buf.length - i) % 2 === 0) {\n        var r = buf.toString('utf16le', i);\n        if (r) {\n            var c = r.charCodeAt(r.length - 1);\n            if (c >= 0xD800 && c <= 0xDBFF) {\n                this.lastNeed = 2;\n                this.lastTotal = 4;\n                this.lastChar[0] = buf[buf.length - 2];\n                this.lastChar[1] = buf[buf.length - 1];\n                return r.slice(0, -1);\n            }\n        }\n        return r;\n    }\n    this.lastNeed = 1;\n    this.lastTotal = 2;\n    this.lastChar[0] = buf[buf.length - 1];\n    return buf.toString('utf16le', i, buf.length - 1);\n}\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction $e5c2a3f70c10f900$var$utf16End(buf) {\n    var r = buf && buf.length ? this.write(buf) : '';\n    if (this.lastNeed) {\n        var end = this.lastTotal - this.lastNeed;\n        return r + this.lastChar.toString('utf16le', 0, end);\n    }\n    return r;\n}\nfunction $e5c2a3f70c10f900$var$base64Text(buf, i) {\n    var n = (buf.length - i) % 3;\n    if (n === 0) return buf.toString('base64', i);\n    this.lastNeed = 3 - n;\n    this.lastTotal = 3;\n    if (n === 1) this.lastChar[0] = buf[buf.length - 1];\n    else {\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n    }\n    return buf.toString('base64', i, buf.length - n);\n}\nfunction $e5c2a3f70c10f900$var$base64End(buf) {\n    var r = buf && buf.length ? this.write(buf) : '';\n    if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n    return r;\n}\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction $e5c2a3f70c10f900$var$simpleWrite(buf) {\n    return buf.toString(this.encoding);\n}\nfunction $e5c2a3f70c10f900$var$simpleEnd(buf) {\n    return buf && buf.length ? this.write(buf) : '';\n}\n\n});\nparcelRegister(\"fx8YU\", function(module, exports) {\n/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ /* eslint-disable node/no-deprecated-api */ \nvar $N0o3H = parcelRequire(\"N0o3H\");\nvar $b4f0e7985342bd1b$var$Buffer = $N0o3H.Buffer;\n// alternative to using Object.keys for old browsers\nfunction $b4f0e7985342bd1b$var$copyProps(src, dst) {\n    for(var key in src)dst[key] = src[key];\n}\nif ($b4f0e7985342bd1b$var$Buffer.from && $b4f0e7985342bd1b$var$Buffer.alloc && $b4f0e7985342bd1b$var$Buffer.allocUnsafe && $b4f0e7985342bd1b$var$Buffer.allocUnsafeSlow) module.exports = $N0o3H;\nelse {\n    // Copy properties from require('buffer')\n    $b4f0e7985342bd1b$var$copyProps($N0o3H, module.exports);\n    module.exports.Buffer = $b4f0e7985342bd1b$var$SafeBuffer;\n}\nfunction $b4f0e7985342bd1b$var$SafeBuffer(arg, encodingOrOffset, length) {\n    return $b4f0e7985342bd1b$var$Buffer(arg, encodingOrOffset, length);\n}\n$b4f0e7985342bd1b$var$SafeBuffer.prototype = Object.create($b4f0e7985342bd1b$var$Buffer.prototype);\n// Copy static methods from Buffer\n$b4f0e7985342bd1b$var$copyProps($b4f0e7985342bd1b$var$Buffer, $b4f0e7985342bd1b$var$SafeBuffer);\n$b4f0e7985342bd1b$var$SafeBuffer.from = function(arg, encodingOrOffset, length) {\n    if (typeof arg === 'number') throw new TypeError('Argument must not be a number');\n    return $b4f0e7985342bd1b$var$Buffer(arg, encodingOrOffset, length);\n};\n$b4f0e7985342bd1b$var$SafeBuffer.alloc = function(size, fill, encoding) {\n    if (typeof size !== 'number') throw new TypeError('Argument must be a number');\n    var buf = $b4f0e7985342bd1b$var$Buffer(size);\n    if (fill !== undefined) {\n        if (typeof encoding === 'string') buf.fill(fill, encoding);\n        else buf.fill(fill);\n    } else buf.fill(0);\n    return buf;\n};\n$b4f0e7985342bd1b$var$SafeBuffer.allocUnsafe = function(size) {\n    if (typeof size !== 'number') throw new TypeError('Argument must be a number');\n    return $b4f0e7985342bd1b$var$Buffer(size);\n};\n$b4f0e7985342bd1b$var$SafeBuffer.allocUnsafeSlow = function(size) {\n    if (typeof size !== 'number') throw new TypeError('Argument must be a number');\n    return $N0o3H.SlowBuffer(size);\n};\n\n});\n\n\nparcelRegister(\"ixzpt\", function(module, exports) {\n'use strict';\n\nvar $ibaza = parcelRequire(\"ibaza\");\n\nvar $1by5F = parcelRequire(\"1by5F\");\nvar $d7f6c6b749ec0909$require$PromisePrototypeThen = $1by5F.PromisePrototypeThen;\nvar $d7f6c6b749ec0909$require$SymbolAsyncIterator = $1by5F.SymbolAsyncIterator;\nvar $d7f6c6b749ec0909$require$SymbolIterator = $1by5F.SymbolIterator;\n\nvar $N0o3H = parcelRequire(\"N0o3H\");\nvar $d7f6c6b749ec0909$require$Buffer = $N0o3H.Buffer;\n\nvar $7ynhX = parcelRequire(\"7ynhX\");\nconst { ERR_INVALID_ARG_TYPE: $d7f6c6b749ec0909$var$ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES: $d7f6c6b749ec0909$var$ERR_STREAM_NULL_VALUES } = $7ynhX.codes;\nfunction $d7f6c6b749ec0909$var$from(Readable, iterable, opts) {\n    let iterator;\n    if (typeof iterable === 'string' || iterable instanceof $d7f6c6b749ec0909$require$Buffer) return new Readable({\n        objectMode: true,\n        ...opts,\n        read () {\n            this.push(iterable);\n            this.push(null);\n        }\n    });\n    let isAsync;\n    if (iterable && iterable[$d7f6c6b749ec0909$require$SymbolAsyncIterator]) {\n        isAsync = true;\n        iterator = iterable[$d7f6c6b749ec0909$require$SymbolAsyncIterator]();\n    } else if (iterable && iterable[$d7f6c6b749ec0909$require$SymbolIterator]) {\n        isAsync = false;\n        iterator = iterable[$d7f6c6b749ec0909$require$SymbolIterator]();\n    } else throw new $d7f6c6b749ec0909$var$ERR_INVALID_ARG_TYPE('iterable', [\n        'Iterable'\n    ], iterable);\n    const readable = new Readable({\n        objectMode: true,\n        highWaterMark: 1,\n        // TODO(ronag): What options should be allowed?\n        ...opts\n    });\n    // Flag to protect against _read\n    // being called before last iteration completion.\n    let reading = false;\n    readable._read = function() {\n        if (!reading) {\n            reading = true;\n            next();\n        }\n    };\n    readable._destroy = function(error, cb) {\n        $d7f6c6b749ec0909$require$PromisePrototypeThen(close(error), ()=>$ibaza.nextTick(cb, error), // nextTick is here in case cb throws\n        (e)=>$ibaza.nextTick(cb, e || error));\n    };\n    async function close(error) {\n        const hadError = error !== undefined && error !== null;\n        const hasThrow = typeof iterator.throw === 'function';\n        if (hadError && hasThrow) {\n            const { value: value, done: done } = await iterator.throw(error);\n            await value;\n            if (done) return;\n        }\n        if (typeof iterator.return === 'function') {\n            const { value: value } = await iterator.return();\n            await value;\n        }\n    }\n    async function next() {\n        for(;;){\n            try {\n                const { value: value, done: done } = isAsync ? await iterator.next() : iterator.next();\n                if (done) readable.push(null);\n                else {\n                    const res = value && typeof value.then === 'function' ? await value : value;\n                    if (res === null) {\n                        reading = false;\n                        throw new $d7f6c6b749ec0909$var$ERR_STREAM_NULL_VALUES();\n                    } else if (readable.push(res)) continue;\n                    else reading = false;\n                }\n            } catch (err) {\n                readable.destroy(err);\n            }\n            break;\n        }\n    }\n    return readable;\n}\nmodule.exports = $d7f6c6b749ec0909$var$from;\n\n});\n\n\nparcelRegister(\"95yXm\", function(module, exports) {\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n'use strict';\n\nvar $ibaza = parcelRequire(\"ibaza\");\n\nvar $1by5F = parcelRequire(\"1by5F\");\nvar $69dfb24d6ccdeaaf$require$ArrayPrototypeSlice = $1by5F.ArrayPrototypeSlice;\nvar $69dfb24d6ccdeaaf$require$Error = $1by5F.Error;\nvar $69dfb24d6ccdeaaf$require$FunctionPrototypeSymbolHasInstance = $1by5F.FunctionPrototypeSymbolHasInstance;\nvar $69dfb24d6ccdeaaf$require$ObjectDefineProperty = $1by5F.ObjectDefineProperty;\nvar $69dfb24d6ccdeaaf$require$ObjectDefineProperties = $1by5F.ObjectDefineProperties;\nvar $69dfb24d6ccdeaaf$require$ObjectSetPrototypeOf = $1by5F.ObjectSetPrototypeOf;\nvar $69dfb24d6ccdeaaf$require$StringPrototypeToLowerCase = $1by5F.StringPrototypeToLowerCase;\nvar $69dfb24d6ccdeaaf$require$Symbol = $1by5F.Symbol;\nvar $69dfb24d6ccdeaaf$require$SymbolHasInstance = $1by5F.SymbolHasInstance;\nmodule.exports = $69dfb24d6ccdeaaf$var$Writable;\n$69dfb24d6ccdeaaf$var$Writable.WritableState = $69dfb24d6ccdeaaf$var$WritableState;\n\nvar $9sqfU = parcelRequire(\"9sqfU\");\nvar $69dfb24d6ccdeaaf$require$EE = $9sqfU.EventEmitter;\n\nvar $1Tt4D = parcelRequire(\"1Tt4D\");\nvar $69dfb24d6ccdeaaf$require$Stream = $1Tt4D.Stream;\n\nvar $N0o3H = parcelRequire(\"N0o3H\");\nvar $69dfb24d6ccdeaaf$require$Buffer = $N0o3H.Buffer;\n\nvar $7CELW = parcelRequire(\"7CELW\");\n\nvar $6ASt2 = parcelRequire(\"6ASt2\");\nvar $69dfb24d6ccdeaaf$require$addAbortSignal = $6ASt2.addAbortSignal;\n\nvar $bKeTG = parcelRequire(\"bKeTG\");\nvar $69dfb24d6ccdeaaf$require$getHighWaterMark = $bKeTG.getHighWaterMark;\nvar $69dfb24d6ccdeaaf$require$getDefaultHighWaterMark = $bKeTG.getDefaultHighWaterMark;\n\nvar $7ynhX = parcelRequire(\"7ynhX\");\nconst { ERR_INVALID_ARG_TYPE: $69dfb24d6ccdeaaf$var$ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED: $69dfb24d6ccdeaaf$var$ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK: $69dfb24d6ccdeaaf$var$ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE: $69dfb24d6ccdeaaf$var$ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED: $69dfb24d6ccdeaaf$var$ERR_STREAM_DESTROYED, ERR_STREAM_ALREADY_FINISHED: $69dfb24d6ccdeaaf$var$ERR_STREAM_ALREADY_FINISHED, ERR_STREAM_NULL_VALUES: $69dfb24d6ccdeaaf$var$ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END: $69dfb24d6ccdeaaf$var$ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING: $69dfb24d6ccdeaaf$var$ERR_UNKNOWN_ENCODING } = $7ynhX.codes;\nconst { errorOrDestroy: $69dfb24d6ccdeaaf$var$errorOrDestroy } = $7CELW;\n$69dfb24d6ccdeaaf$require$ObjectSetPrototypeOf($69dfb24d6ccdeaaf$var$Writable.prototype, $69dfb24d6ccdeaaf$require$Stream.prototype);\n$69dfb24d6ccdeaaf$require$ObjectSetPrototypeOf($69dfb24d6ccdeaaf$var$Writable, $69dfb24d6ccdeaaf$require$Stream);\nfunction $69dfb24d6ccdeaaf$var$nop() {}\nconst $69dfb24d6ccdeaaf$var$kOnFinished = $69dfb24d6ccdeaaf$require$Symbol('kOnFinished');\n\nfunction $69dfb24d6ccdeaaf$var$WritableState(options, stream, isDuplex) {\n    // Duplex streams are both readable and writable, but share\n    // the same options object.\n    // However, some cases require setting options to different\n    // values for the readable and the writable sides of the duplex stream,\n    // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n    if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof (parcelRequire(\"lyuEd\"));\n    // Object stream flag to indicate whether or not this stream\n    // contains buffers or objects.\n    this.objectMode = !!(options && options.objectMode);\n    if (isDuplex) this.objectMode = this.objectMode || !!(options && options.writableObjectMode);\n    // The point at which write() starts returning false\n    // Note: 0 is a valid value, means that we always return false if\n    // the entire buffer is not flushed immediately on write().\n    this.highWaterMark = options ? $69dfb24d6ccdeaaf$require$getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex) : $69dfb24d6ccdeaaf$require$getDefaultHighWaterMark(false);\n    // if _final has been called.\n    this.finalCalled = false;\n    // drain event flag.\n    this.needDrain = false;\n    // At the start of calling end()\n    this.ending = false;\n    // When end() has been called, and returned.\n    this.ended = false;\n    // When 'finish' is emitted.\n    this.finished = false;\n    // Has it been destroyed\n    this.destroyed = false;\n    // Should we decode strings into buffers before passing to _write?\n    // this is here so that some node-core streams can optimize string\n    // handling at a lower level.\n    const noDecode = !!(options && options.decodeStrings === false);\n    this.decodeStrings = !noDecode;\n    // Crypto is kind of old and crusty.  Historically, its default string\n    // encoding is 'binary' so we have to make this configurable.\n    // Everything else in the universe uses 'utf8', though.\n    this.defaultEncoding = options && options.defaultEncoding || 'utf8';\n    // Not an actual buffer we keep track of, but a measurement\n    // of how much we're waiting to get pushed to some underlying\n    // socket or file.\n    this.length = 0;\n    // A flag to see when we're in the middle of a write.\n    this.writing = false;\n    // When true all writes will be buffered until .uncork() call.\n    this.corked = 0;\n    // A flag to be able to tell if the onwrite cb is called immediately,\n    // or on a later tick.  We set this to true at first, because any\n    // actions that shouldn't happen until \"later\" should generally also\n    // not happen before the first write call.\n    this.sync = true;\n    // A flag to know if we're processing previously buffered items, which\n    // may call the _write() callback in the same tick, so that we don't\n    // end up in an overlapped onwrite situation.\n    this.bufferProcessing = false;\n    // The callback that's passed to _write(chunk, cb).\n    this.onwrite = $69dfb24d6ccdeaaf$var$onwrite.bind(undefined, stream);\n    // The callback that the user supplies to write(chunk, encoding, cb).\n    this.writecb = null;\n    // The amount that is being written when _write is called.\n    this.writelen = 0;\n    // Storage for data passed to the afterWrite() callback in case of\n    // synchronous _write() completion.\n    this.afterWriteTickInfo = null;\n    $69dfb24d6ccdeaaf$var$resetBuffer(this);\n    // Number of pending user-supplied write callbacks\n    // this must be 0 before 'finish' can be emitted.\n    this.pendingcb = 0;\n    // Stream is still being constructed and cannot be\n    // destroyed until construction finished or failed.\n    // Async construction is opt in, therefore we start as\n    // constructed.\n    this.constructed = true;\n    // Emit prefinish if the only thing we're waiting for is _write cbs\n    // This is relevant for synchronous Transform streams.\n    this.prefinished = false;\n    // True if the error was already emitted and should not be thrown again.\n    this.errorEmitted = false;\n    // Should close be emitted on destroy. Defaults to true.\n    this.emitClose = !options || options.emitClose !== false;\n    // Should .destroy() be called after 'finish' (and potentially 'end').\n    this.autoDestroy = !options || options.autoDestroy !== false;\n    // Indicates whether the stream has errored. When true all write() calls\n    // should return false. This is needed since when autoDestroy\n    // is disabled we need a way to tell whether the stream has failed.\n    this.errored = null;\n    // Indicates whether the stream has finished destroying.\n    this.closed = false;\n    // True if close has been emitted or would have been emitted\n    // depending on emitClose.\n    this.closeEmitted = false;\n    this[$69dfb24d6ccdeaaf$var$kOnFinished] = [];\n}\nfunction $69dfb24d6ccdeaaf$var$resetBuffer(state) {\n    state.buffered = [];\n    state.bufferedIndex = 0;\n    state.allBuffers = true;\n    state.allNoop = true;\n}\n$69dfb24d6ccdeaaf$var$WritableState.prototype.getBuffer = function getBuffer() {\n    return $69dfb24d6ccdeaaf$require$ArrayPrototypeSlice(this.buffered, this.bufferedIndex);\n};\n$69dfb24d6ccdeaaf$require$ObjectDefineProperty($69dfb24d6ccdeaaf$var$WritableState.prototype, 'bufferedRequestCount', {\n    __proto__: null,\n    get () {\n        return this.buffered.length - this.bufferedIndex;\n    }\n});\n\nfunction $69dfb24d6ccdeaaf$var$Writable(options) {\n    // Writable ctor is applied to Duplexes, too.\n    // `realHasInstance` is necessary because using plain `instanceof`\n    // would return false, as no `_writableState` property is attached.\n    // Trying to use the custom `instanceof` for Writable here will also break the\n    // Node.js LazyTransform implementation, which has a non-trivial getter for\n    // `_writableState` that would lead to infinite recursion.\n    // Checking for a Stream.Duplex instance is faster here instead of inside\n    // the WritableState constructor, at least with V8 6.5.\n    const isDuplex = this instanceof (parcelRequire(\"lyuEd\"));\n    if (!isDuplex && !$69dfb24d6ccdeaaf$require$FunctionPrototypeSymbolHasInstance($69dfb24d6ccdeaaf$var$Writable, this)) return new $69dfb24d6ccdeaaf$var$Writable(options);\n    this._writableState = new $69dfb24d6ccdeaaf$var$WritableState(options, this, isDuplex);\n    if (options) {\n        if (typeof options.write === 'function') this._write = options.write;\n        if (typeof options.writev === 'function') this._writev = options.writev;\n        if (typeof options.destroy === 'function') this._destroy = options.destroy;\n        if (typeof options.final === 'function') this._final = options.final;\n        if (typeof options.construct === 'function') this._construct = options.construct;\n        if (options.signal) $69dfb24d6ccdeaaf$require$addAbortSignal(options.signal, this);\n    }\n    $69dfb24d6ccdeaaf$require$Stream.call(this, options);\n    $7CELW.construct(this, ()=>{\n        const state = this._writableState;\n        if (!state.writing) $69dfb24d6ccdeaaf$var$clearBuffer(this, state);\n        $69dfb24d6ccdeaaf$var$finishMaybe(this, state);\n    });\n}\n$69dfb24d6ccdeaaf$require$ObjectDefineProperty($69dfb24d6ccdeaaf$var$Writable, $69dfb24d6ccdeaaf$require$SymbolHasInstance, {\n    __proto__: null,\n    value: function(object) {\n        if ($69dfb24d6ccdeaaf$require$FunctionPrototypeSymbolHasInstance(this, object)) return true;\n        if (this !== $69dfb24d6ccdeaaf$var$Writable) return false;\n        return object && object._writableState instanceof $69dfb24d6ccdeaaf$var$WritableState;\n    }\n});\n// Otherwise people can pipe Writable streams, which is just wrong.\n$69dfb24d6ccdeaaf$var$Writable.prototype.pipe = function() {\n    $69dfb24d6ccdeaaf$var$errorOrDestroy(this, new $69dfb24d6ccdeaaf$var$ERR_STREAM_CANNOT_PIPE());\n};\nfunction $69dfb24d6ccdeaaf$var$_write(stream, chunk, encoding, cb) {\n    const state = stream._writableState;\n    if (typeof encoding === 'function') {\n        cb = encoding;\n        encoding = state.defaultEncoding;\n    } else {\n        if (!encoding) encoding = state.defaultEncoding;\n        else if (encoding !== 'buffer' && !$69dfb24d6ccdeaaf$require$Buffer.isEncoding(encoding)) throw new $69dfb24d6ccdeaaf$var$ERR_UNKNOWN_ENCODING(encoding);\n        if (typeof cb !== 'function') cb = $69dfb24d6ccdeaaf$var$nop;\n    }\n    if (chunk === null) throw new $69dfb24d6ccdeaaf$var$ERR_STREAM_NULL_VALUES();\n    else if (!state.objectMode) {\n        if (typeof chunk === 'string') {\n            if (state.decodeStrings !== false) {\n                chunk = $69dfb24d6ccdeaaf$require$Buffer.from(chunk, encoding);\n                encoding = 'buffer';\n            }\n        } else if (chunk instanceof $69dfb24d6ccdeaaf$require$Buffer) encoding = 'buffer';\n        else if ($69dfb24d6ccdeaaf$require$Stream._isUint8Array(chunk)) {\n            chunk = $69dfb24d6ccdeaaf$require$Stream._uint8ArrayToBuffer(chunk);\n            encoding = 'buffer';\n        } else throw new $69dfb24d6ccdeaaf$var$ERR_INVALID_ARG_TYPE('chunk', [\n            'string',\n            'Buffer',\n            'Uint8Array'\n        ], chunk);\n    }\n    let err;\n    if (state.ending) err = new $69dfb24d6ccdeaaf$var$ERR_STREAM_WRITE_AFTER_END();\n    else if (state.destroyed) err = new $69dfb24d6ccdeaaf$var$ERR_STREAM_DESTROYED('write');\n    if (err) {\n        $ibaza.nextTick(cb, err);\n        $69dfb24d6ccdeaaf$var$errorOrDestroy(stream, err, true);\n        return err;\n    }\n    state.pendingcb++;\n    return $69dfb24d6ccdeaaf$var$writeOrBuffer(stream, state, chunk, encoding, cb);\n}\n$69dfb24d6ccdeaaf$var$Writable.prototype.write = function(chunk, encoding, cb) {\n    return $69dfb24d6ccdeaaf$var$_write(this, chunk, encoding, cb) === true;\n};\n$69dfb24d6ccdeaaf$var$Writable.prototype.cork = function() {\n    this._writableState.corked++;\n};\n$69dfb24d6ccdeaaf$var$Writable.prototype.uncork = function() {\n    const state = this._writableState;\n    if (state.corked) {\n        state.corked--;\n        if (!state.writing) $69dfb24d6ccdeaaf$var$clearBuffer(this, state);\n    }\n};\n$69dfb24d6ccdeaaf$var$Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n    // node::ParseEncoding() requires lower case.\n    if (typeof encoding === 'string') encoding = $69dfb24d6ccdeaaf$require$StringPrototypeToLowerCase(encoding);\n    if (!$69dfb24d6ccdeaaf$require$Buffer.isEncoding(encoding)) throw new $69dfb24d6ccdeaaf$var$ERR_UNKNOWN_ENCODING(encoding);\n    this._writableState.defaultEncoding = encoding;\n    return this;\n};\n// If we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction $69dfb24d6ccdeaaf$var$writeOrBuffer(stream, state, chunk, encoding, callback) {\n    const len = state.objectMode ? 1 : chunk.length;\n    state.length += len;\n    // stream._write resets state.length\n    const ret = state.length < state.highWaterMark;\n    // We must ensure that previous needDrain will not be reset to false.\n    if (!ret) state.needDrain = true;\n    if (state.writing || state.corked || state.errored || !state.constructed) {\n        state.buffered.push({\n            chunk: chunk,\n            encoding: encoding,\n            callback: callback\n        });\n        if (state.allBuffers && encoding !== 'buffer') state.allBuffers = false;\n        if (state.allNoop && callback !== $69dfb24d6ccdeaaf$var$nop) state.allNoop = false;\n    } else {\n        state.writelen = len;\n        state.writecb = callback;\n        state.writing = true;\n        state.sync = true;\n        stream._write(chunk, encoding, state.onwrite);\n        state.sync = false;\n    }\n    // Return false if errored or destroyed in order to break\n    // any synchronous while(stream.write(data)) loops.\n    return ret && !state.errored && !state.destroyed;\n}\nfunction $69dfb24d6ccdeaaf$var$doWrite(stream, state, writev, len, chunk, encoding, cb) {\n    state.writelen = len;\n    state.writecb = cb;\n    state.writing = true;\n    state.sync = true;\n    if (state.destroyed) state.onwrite(new $69dfb24d6ccdeaaf$var$ERR_STREAM_DESTROYED('write'));\n    else if (writev) stream._writev(chunk, state.onwrite);\n    else stream._write(chunk, encoding, state.onwrite);\n    state.sync = false;\n}\nfunction $69dfb24d6ccdeaaf$var$onwriteError(stream, state, er, cb) {\n    --state.pendingcb;\n    cb(er);\n    // Ensure callbacks are invoked even when autoDestroy is\n    // not enabled. Passing `er` here doesn't make sense since\n    // it's related to one specific write, not to the buffered\n    // writes.\n    $69dfb24d6ccdeaaf$var$errorBuffer(state);\n    // This can emit error, but error must always follow cb.\n    $69dfb24d6ccdeaaf$var$errorOrDestroy(stream, er);\n}\nfunction $69dfb24d6ccdeaaf$var$onwrite(stream, er) {\n    const state = stream._writableState;\n    const sync = state.sync;\n    const cb = state.writecb;\n    if (typeof cb !== 'function') {\n        $69dfb24d6ccdeaaf$var$errorOrDestroy(stream, new $69dfb24d6ccdeaaf$var$ERR_MULTIPLE_CALLBACK());\n        return;\n    }\n    state.writing = false;\n    state.writecb = null;\n    state.length -= state.writelen;\n    state.writelen = 0;\n    if (er) {\n        // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n        er.stack // eslint-disable-line no-unused-expressions\n        ;\n        if (!state.errored) state.errored = er;\n        // In case of duplex streams we need to notify the readable side of the\n        // error.\n        if (stream._readableState && !stream._readableState.errored) stream._readableState.errored = er;\n        if (sync) $ibaza.nextTick($69dfb24d6ccdeaaf$var$onwriteError, stream, state, er, cb);\n        else $69dfb24d6ccdeaaf$var$onwriteError(stream, state, er, cb);\n    } else {\n        if (state.buffered.length > state.bufferedIndex) $69dfb24d6ccdeaaf$var$clearBuffer(stream, state);\n        if (sync) {\n            // It is a common case that the callback passed to .write() is always\n            // the same. In that case, we do not schedule a new nextTick(), but\n            // rather just increase a counter, to improve performance and avoid\n            // memory allocations.\n            if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) state.afterWriteTickInfo.count++;\n            else {\n                state.afterWriteTickInfo = {\n                    count: 1,\n                    cb: cb,\n                    stream: stream,\n                    state: state\n                };\n                $ibaza.nextTick($69dfb24d6ccdeaaf$var$afterWriteTick, state.afterWriteTickInfo);\n            }\n        } else $69dfb24d6ccdeaaf$var$afterWrite(stream, state, 1, cb);\n    }\n}\nfunction $69dfb24d6ccdeaaf$var$afterWriteTick({ stream: stream, state: state, count: count, cb: cb }) {\n    state.afterWriteTickInfo = null;\n    return $69dfb24d6ccdeaaf$var$afterWrite(stream, state, count, cb);\n}\nfunction $69dfb24d6ccdeaaf$var$afterWrite(stream, state, count, cb) {\n    const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;\n    if (needDrain) {\n        state.needDrain = false;\n        stream.emit('drain');\n    }\n    while(count-- > 0){\n        state.pendingcb--;\n        cb();\n    }\n    if (state.destroyed) $69dfb24d6ccdeaaf$var$errorBuffer(state);\n    $69dfb24d6ccdeaaf$var$finishMaybe(stream, state);\n}\n// If there's something in the buffer waiting, then invoke callbacks.\nfunction $69dfb24d6ccdeaaf$var$errorBuffer(state) {\n    if (state.writing) return;\n    for(let n = state.bufferedIndex; n < state.buffered.length; ++n){\n        var _state$errored;\n        const { chunk: chunk, callback: callback } = state.buffered[n];\n        const len = state.objectMode ? 1 : chunk.length;\n        state.length -= len;\n        callback((_state$errored = state.errored) !== null && _state$errored !== undefined ? _state$errored : new $69dfb24d6ccdeaaf$var$ERR_STREAM_DESTROYED('write'));\n    }\n    const onfinishCallbacks = state[$69dfb24d6ccdeaaf$var$kOnFinished].splice(0);\n    for(let i = 0; i < onfinishCallbacks.length; i++){\n        var _state$errored2;\n        onfinishCallbacks[i]((_state$errored2 = state.errored) !== null && _state$errored2 !== undefined ? _state$errored2 : new $69dfb24d6ccdeaaf$var$ERR_STREAM_DESTROYED('end'));\n    }\n    $69dfb24d6ccdeaaf$var$resetBuffer(state);\n}\n// If there's something in the buffer waiting, then process it.\nfunction $69dfb24d6ccdeaaf$var$clearBuffer(stream, state) {\n    if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) return;\n    const { buffered: buffered, bufferedIndex: bufferedIndex, objectMode: objectMode } = state;\n    const bufferedLength = buffered.length - bufferedIndex;\n    if (!bufferedLength) return;\n    let i = bufferedIndex;\n    state.bufferProcessing = true;\n    if (bufferedLength > 1 && stream._writev) {\n        state.pendingcb -= bufferedLength - 1;\n        const callback = state.allNoop ? $69dfb24d6ccdeaaf$var$nop : (err)=>{\n            for(let n = i; n < buffered.length; ++n)buffered[n].callback(err);\n        };\n        // Make a copy of `buffered` if it's going to be used by `callback` above,\n        // since `doWrite` will mutate the array.\n        const chunks = state.allNoop && i === 0 ? buffered : $69dfb24d6ccdeaaf$require$ArrayPrototypeSlice(buffered, i);\n        chunks.allBuffers = state.allBuffers;\n        $69dfb24d6ccdeaaf$var$doWrite(stream, state, true, state.length, chunks, '', callback);\n        $69dfb24d6ccdeaaf$var$resetBuffer(state);\n    } else {\n        do {\n            const { chunk: chunk, encoding: encoding, callback: callback } = buffered[i];\n            buffered[i++] = null;\n            const len = objectMode ? 1 : chunk.length;\n            $69dfb24d6ccdeaaf$var$doWrite(stream, state, false, len, chunk, encoding, callback);\n        }while (i < buffered.length && !state.writing);\n        if (i === buffered.length) $69dfb24d6ccdeaaf$var$resetBuffer(state);\n        else if (i > 256) {\n            buffered.splice(0, i);\n            state.bufferedIndex = 0;\n        } else state.bufferedIndex = i;\n    }\n    state.bufferProcessing = false;\n}\n$69dfb24d6ccdeaaf$var$Writable.prototype._write = function(chunk, encoding, cb) {\n    if (this._writev) this._writev([\n        {\n            chunk: chunk,\n            encoding: encoding\n        }\n    ], cb);\n    else throw new $69dfb24d6ccdeaaf$var$ERR_METHOD_NOT_IMPLEMENTED('_write()');\n};\n$69dfb24d6ccdeaaf$var$Writable.prototype._writev = null;\n$69dfb24d6ccdeaaf$var$Writable.prototype.end = function(chunk, encoding, cb) {\n    const state = this._writableState;\n    if (typeof chunk === 'function') {\n        cb = chunk;\n        chunk = null;\n        encoding = null;\n    } else if (typeof encoding === 'function') {\n        cb = encoding;\n        encoding = null;\n    }\n    let err;\n    if (chunk !== null && chunk !== undefined) {\n        const ret = $69dfb24d6ccdeaaf$var$_write(this, chunk, encoding);\n        if (ret instanceof $69dfb24d6ccdeaaf$require$Error) err = ret;\n    }\n    // .end() fully uncorks.\n    if (state.corked) {\n        state.corked = 1;\n        this.uncork();\n    }\n    if (err) ;\n    else if (!state.errored && !state.ending) {\n        // This is forgiving in terms of unnecessary calls to end() and can hide\n        // logic errors. However, usually such errors are harmless and causing a\n        // hard error can be disproportionately destructive. It is not always\n        // trivial for the user to determine whether end() needs to be called\n        // or not.\n        state.ending = true;\n        $69dfb24d6ccdeaaf$var$finishMaybe(this, state, true);\n        state.ended = true;\n    } else if (state.finished) err = new $69dfb24d6ccdeaaf$var$ERR_STREAM_ALREADY_FINISHED('end');\n    else if (state.destroyed) err = new $69dfb24d6ccdeaaf$var$ERR_STREAM_DESTROYED('end');\n    if (typeof cb === 'function') {\n        if (err || state.finished) $ibaza.nextTick(cb, err);\n        else state[$69dfb24d6ccdeaaf$var$kOnFinished].push(cb);\n    }\n    return this;\n};\nfunction $69dfb24d6ccdeaaf$var$needFinish(state) {\n    return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;\n}\nfunction $69dfb24d6ccdeaaf$var$callFinal(stream, state) {\n    let called = false;\n    function onFinish(err) {\n        if (called) {\n            $69dfb24d6ccdeaaf$var$errorOrDestroy(stream, err !== null && err !== undefined ? err : $69dfb24d6ccdeaaf$var$ERR_MULTIPLE_CALLBACK());\n            return;\n        }\n        called = true;\n        state.pendingcb--;\n        if (err) {\n            const onfinishCallbacks = state[$69dfb24d6ccdeaaf$var$kOnFinished].splice(0);\n            for(let i = 0; i < onfinishCallbacks.length; i++)onfinishCallbacks[i](err);\n            $69dfb24d6ccdeaaf$var$errorOrDestroy(stream, err, state.sync);\n        } else if ($69dfb24d6ccdeaaf$var$needFinish(state)) {\n            state.prefinished = true;\n            stream.emit('prefinish');\n            // Backwards compat. Don't check state.sync here.\n            // Some streams assume 'finish' will be emitted\n            // asynchronously relative to _final callback.\n            state.pendingcb++;\n            $ibaza.nextTick($69dfb24d6ccdeaaf$var$finish, stream, state);\n        }\n    }\n    state.sync = true;\n    state.pendingcb++;\n    try {\n        stream._final(onFinish);\n    } catch (err) {\n        onFinish(err);\n    }\n    state.sync = false;\n}\nfunction $69dfb24d6ccdeaaf$var$prefinish(stream, state) {\n    if (!state.prefinished && !state.finalCalled) {\n        if (typeof stream._final === 'function' && !state.destroyed) {\n            state.finalCalled = true;\n            $69dfb24d6ccdeaaf$var$callFinal(stream, state);\n        } else {\n            state.prefinished = true;\n            stream.emit('prefinish');\n        }\n    }\n}\nfunction $69dfb24d6ccdeaaf$var$finishMaybe(stream, state, sync) {\n    if ($69dfb24d6ccdeaaf$var$needFinish(state)) {\n        $69dfb24d6ccdeaaf$var$prefinish(stream, state);\n        if (state.pendingcb === 0) {\n            if (sync) {\n                state.pendingcb++;\n                $ibaza.nextTick((stream, state)=>{\n                    if ($69dfb24d6ccdeaaf$var$needFinish(state)) $69dfb24d6ccdeaaf$var$finish(stream, state);\n                    else state.pendingcb--;\n                }, stream, state);\n            } else if ($69dfb24d6ccdeaaf$var$needFinish(state)) {\n                state.pendingcb++;\n                $69dfb24d6ccdeaaf$var$finish(stream, state);\n            }\n        }\n    }\n}\nfunction $69dfb24d6ccdeaaf$var$finish(stream, state) {\n    state.pendingcb--;\n    state.finished = true;\n    const onfinishCallbacks = state[$69dfb24d6ccdeaaf$var$kOnFinished].splice(0);\n    for(let i = 0; i < onfinishCallbacks.length; i++)onfinishCallbacks[i]();\n    stream.emit('finish');\n    if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well.\n        const rState = stream._readableState;\n        const autoDestroy = !rState || rState.autoDestroy && // We don't expect the readable to ever 'end'\n        // if readable is explicitly set to false.\n        (rState.endEmitted || rState.readable === false);\n        if (autoDestroy) stream.destroy();\n    }\n}\n$69dfb24d6ccdeaaf$require$ObjectDefineProperties($69dfb24d6ccdeaaf$var$Writable.prototype, {\n    closed: {\n        __proto__: null,\n        get () {\n            return this._writableState ? this._writableState.closed : false;\n        }\n    },\n    destroyed: {\n        __proto__: null,\n        get () {\n            return this._writableState ? this._writableState.destroyed : false;\n        },\n        set (value) {\n            // Backward compatibility, the user is explicitly managing destroyed.\n            if (this._writableState) this._writableState.destroyed = value;\n        }\n    },\n    writable: {\n        __proto__: null,\n        get () {\n            const w = this._writableState;\n            // w.writable === false means that this is part of a Duplex stream\n            // where the writable side was disabled upon construction.\n            // Compat. The user might manually disable writable side through\n            // deprecated setter.\n            return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;\n        },\n        set (val) {\n            // Backwards compatible.\n            if (this._writableState) this._writableState.writable = !!val;\n        }\n    },\n    writableFinished: {\n        __proto__: null,\n        get () {\n            return this._writableState ? this._writableState.finished : false;\n        }\n    },\n    writableObjectMode: {\n        __proto__: null,\n        get () {\n            return this._writableState ? this._writableState.objectMode : false;\n        }\n    },\n    writableBuffer: {\n        __proto__: null,\n        get () {\n            return this._writableState && this._writableState.getBuffer();\n        }\n    },\n    writableEnded: {\n        __proto__: null,\n        get () {\n            return this._writableState ? this._writableState.ending : false;\n        }\n    },\n    writableNeedDrain: {\n        __proto__: null,\n        get () {\n            const wState = this._writableState;\n            if (!wState) return false;\n            return !wState.destroyed && !wState.ending && wState.needDrain;\n        }\n    },\n    writableHighWaterMark: {\n        __proto__: null,\n        get () {\n            return this._writableState && this._writableState.highWaterMark;\n        }\n    },\n    writableCorked: {\n        __proto__: null,\n        get () {\n            return this._writableState ? this._writableState.corked : 0;\n        }\n    },\n    writableLength: {\n        __proto__: null,\n        get () {\n            return this._writableState && this._writableState.length;\n        }\n    },\n    errored: {\n        __proto__: null,\n        enumerable: false,\n        get () {\n            return this._writableState ? this._writableState.errored : null;\n        }\n    },\n    writableAborted: {\n        __proto__: null,\n        enumerable: false,\n        get: function() {\n            return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);\n        }\n    }\n});\nconst $69dfb24d6ccdeaaf$var$destroy = $7CELW.destroy;\n$69dfb24d6ccdeaaf$var$Writable.prototype.destroy = function(err, cb) {\n    const state = this._writableState;\n    // Invoke pending callbacks.\n    if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[$69dfb24d6ccdeaaf$var$kOnFinished].length)) $ibaza.nextTick($69dfb24d6ccdeaaf$var$errorBuffer, state);\n    $69dfb24d6ccdeaaf$var$destroy.call(this, err, cb);\n    return this;\n};\n$69dfb24d6ccdeaaf$var$Writable.prototype._undestroy = $7CELW.undestroy;\n$69dfb24d6ccdeaaf$var$Writable.prototype._destroy = function(err, cb) {\n    cb(err);\n};\n$69dfb24d6ccdeaaf$var$Writable.prototype[$69dfb24d6ccdeaaf$require$EE.captureRejectionSymbol] = function(err) {\n    this.destroy(err);\n};\nlet $69dfb24d6ccdeaaf$var$webStreamsAdapters;\n// Lazy to avoid circular references\nfunction $69dfb24d6ccdeaaf$var$lazyWebStreams() {\n    if ($69dfb24d6ccdeaaf$var$webStreamsAdapters === undefined) $69dfb24d6ccdeaaf$var$webStreamsAdapters = {};\n    return $69dfb24d6ccdeaaf$var$webStreamsAdapters;\n}\n$69dfb24d6ccdeaaf$var$Writable.fromWeb = function(writableStream, options) {\n    return $69dfb24d6ccdeaaf$var$lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);\n};\n$69dfb24d6ccdeaaf$var$Writable.toWeb = function(streamWritable) {\n    return $69dfb24d6ccdeaaf$var$lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);\n};\n\n});\n\nparcelRegister(\"kUcKi\", function(module, exports) {\n/* replacement start */ \nvar $ibaza = parcelRequire(\"ibaza\");\n'use strict';\n\nvar $N0o3H = parcelRequire(\"N0o3H\");\n\nvar $eY1Gs = parcelRequire(\"eY1Gs\");\nvar $f382eca2b5a16cc3$require$isReadable = $eY1Gs.isReadable;\nvar $f382eca2b5a16cc3$require$isWritable = $eY1Gs.isWritable;\nvar $f382eca2b5a16cc3$require$isIterable = $eY1Gs.isIterable;\nvar $f382eca2b5a16cc3$require$isNodeStream = $eY1Gs.isNodeStream;\nvar $f382eca2b5a16cc3$require$isReadableNodeStream = $eY1Gs.isReadableNodeStream;\nvar $f382eca2b5a16cc3$require$isWritableNodeStream = $eY1Gs.isWritableNodeStream;\nvar $f382eca2b5a16cc3$require$isDuplexNodeStream = $eY1Gs.isDuplexNodeStream;\nvar $f382eca2b5a16cc3$require$isReadableStream = $eY1Gs.isReadableStream;\nvar $f382eca2b5a16cc3$require$isWritableStream = $eY1Gs.isWritableStream;\n\nvar $9RUbc = parcelRequire(\"9RUbc\");\n\nvar $7ynhX = parcelRequire(\"7ynhX\");\nconst { AbortError: $f382eca2b5a16cc3$var$AbortError, codes: { ERR_INVALID_ARG_TYPE: $f382eca2b5a16cc3$var$ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE: $f382eca2b5a16cc3$var$ERR_INVALID_RETURN_VALUE } } = $7ynhX;\n\nvar $7CELW = parcelRequire(\"7CELW\");\nvar $f382eca2b5a16cc3$require$destroyer = $7CELW.destroyer;\n\nvar $lyuEd = parcelRequire(\"lyuEd\");\n\nvar $c6GJA = parcelRequire(\"c6GJA\");\n\nvar $95yXm = parcelRequire(\"95yXm\");\n\nvar $kDFyU = parcelRequire(\"kDFyU\");\nvar $f382eca2b5a16cc3$require$createDeferredPromise = $kDFyU.createDeferredPromise;\n\nvar $ixzpt = parcelRequire(\"ixzpt\");\nconst $f382eca2b5a16cc3$var$Blob = globalThis.Blob || $N0o3H.Blob;\nconst $f382eca2b5a16cc3$var$isBlob = typeof $f382eca2b5a16cc3$var$Blob !== 'undefined' ? function isBlob(b) {\n    return b instanceof $f382eca2b5a16cc3$var$Blob;\n} : function isBlob(b) {\n    return false;\n};\n\nconst $f382eca2b5a16cc3$var$AbortController = globalThis.AbortController || (parcelRequire(\"5zWM9\")).AbortController;\n\nvar $1by5F = parcelRequire(\"1by5F\");\nvar $f382eca2b5a16cc3$require$FunctionPrototypeCall = $1by5F.FunctionPrototypeCall;\n// This is needed for pre node 17.\nclass $f382eca2b5a16cc3$var$Duplexify extends $lyuEd {\n    constructor(options){\n        super(options);\n        // https://github.com/nodejs/node/pull/34385\n        if ((options === null || options === undefined ? undefined : options.readable) === false) {\n            this._readableState.readable = false;\n            this._readableState.ended = true;\n            this._readableState.endEmitted = true;\n        }\n        if ((options === null || options === undefined ? undefined : options.writable) === false) {\n            this._writableState.writable = false;\n            this._writableState.ending = true;\n            this._writableState.ended = true;\n            this._writableState.finished = true;\n        }\n    }\n}\nmodule.exports = function duplexify(body, name) {\n    if ($f382eca2b5a16cc3$require$isDuplexNodeStream(body)) return body;\n    if ($f382eca2b5a16cc3$require$isReadableNodeStream(body)) return $f382eca2b5a16cc3$var$_duplexify({\n        readable: body\n    });\n    if ($f382eca2b5a16cc3$require$isWritableNodeStream(body)) return $f382eca2b5a16cc3$var$_duplexify({\n        writable: body\n    });\n    if ($f382eca2b5a16cc3$require$isNodeStream(body)) return $f382eca2b5a16cc3$var$_duplexify({\n        writable: false,\n        readable: false\n    });\n    if ($f382eca2b5a16cc3$require$isReadableStream(body)) return $f382eca2b5a16cc3$var$_duplexify({\n        readable: $c6GJA.fromWeb(body)\n    });\n    if ($f382eca2b5a16cc3$require$isWritableStream(body)) return $f382eca2b5a16cc3$var$_duplexify({\n        writable: $95yXm.fromWeb(body)\n    });\n    if (typeof body === 'function') {\n        const { value: value, write: write, final: final, destroy: destroy } = $f382eca2b5a16cc3$var$fromAsyncGen(body);\n        if ($f382eca2b5a16cc3$require$isIterable(value)) return $ixzpt($f382eca2b5a16cc3$var$Duplexify, value, {\n            // TODO (ronag): highWaterMark?\n            objectMode: true,\n            write: write,\n            final: final,\n            destroy: destroy\n        });\n        const then = value === null || value === undefined ? undefined : value.then;\n        if (typeof then === 'function') {\n            let d;\n            const promise = $f382eca2b5a16cc3$require$FunctionPrototypeCall(then, value, (val)=>{\n                if (val != null) throw new $f382eca2b5a16cc3$var$ERR_INVALID_RETURN_VALUE('nully', 'body', val);\n            }, (err)=>{\n                $f382eca2b5a16cc3$require$destroyer(d, err);\n            });\n            return d = new $f382eca2b5a16cc3$var$Duplexify({\n                // TODO (ronag): highWaterMark?\n                objectMode: true,\n                readable: false,\n                write: write,\n                final (cb) {\n                    final(async ()=>{\n                        try {\n                            await promise;\n                            $ibaza.nextTick(cb, null);\n                        } catch (err) {\n                            $ibaza.nextTick(cb, err);\n                        }\n                    });\n                },\n                destroy: destroy\n            });\n        }\n        throw new $f382eca2b5a16cc3$var$ERR_INVALID_RETURN_VALUE('Iterable, AsyncIterable or AsyncFunction', name, value);\n    }\n    if ($f382eca2b5a16cc3$var$isBlob(body)) return duplexify(body.arrayBuffer());\n    if ($f382eca2b5a16cc3$require$isIterable(body)) return $ixzpt($f382eca2b5a16cc3$var$Duplexify, body, {\n        // TODO (ronag): highWaterMark?\n        objectMode: true,\n        writable: false\n    });\n    if ($f382eca2b5a16cc3$require$isReadableStream(body === null || body === undefined ? undefined : body.readable) && $f382eca2b5a16cc3$require$isWritableStream(body === null || body === undefined ? undefined : body.writable)) return $f382eca2b5a16cc3$var$Duplexify.fromWeb(body);\n    if (typeof (body === null || body === undefined ? undefined : body.writable) === 'object' || typeof (body === null || body === undefined ? undefined : body.readable) === 'object') {\n        const readable = body !== null && body !== undefined && body.readable ? $f382eca2b5a16cc3$require$isReadableNodeStream(body === null || body === undefined ? undefined : body.readable) ? body === null || body === undefined ? undefined : body.readable : duplexify(body.readable) : undefined;\n        const writable = body !== null && body !== undefined && body.writable ? $f382eca2b5a16cc3$require$isWritableNodeStream(body === null || body === undefined ? undefined : body.writable) ? body === null || body === undefined ? undefined : body.writable : duplexify(body.writable) : undefined;\n        return $f382eca2b5a16cc3$var$_duplexify({\n            readable: readable,\n            writable: writable\n        });\n    }\n    const then = body === null || body === undefined ? undefined : body.then;\n    if (typeof then === 'function') {\n        let d;\n        $f382eca2b5a16cc3$require$FunctionPrototypeCall(then, body, (val)=>{\n            if (val != null) d.push(val);\n            d.push(null);\n        }, (err)=>{\n            $f382eca2b5a16cc3$require$destroyer(d, err);\n        });\n        return d = new $f382eca2b5a16cc3$var$Duplexify({\n            objectMode: true,\n            writable: false,\n            read () {}\n        });\n    }\n    throw new $f382eca2b5a16cc3$var$ERR_INVALID_ARG_TYPE(name, [\n        'Blob',\n        'ReadableStream',\n        'WritableStream',\n        'Stream',\n        'Iterable',\n        'AsyncIterable',\n        'Function',\n        '{ readable, writable } pair',\n        'Promise'\n    ], body);\n};\nfunction $f382eca2b5a16cc3$var$fromAsyncGen(fn) {\n    let { promise: promise, resolve: resolve } = $f382eca2b5a16cc3$require$createDeferredPromise();\n    const ac = new $f382eca2b5a16cc3$var$AbortController();\n    const signal = ac.signal;\n    const value = fn(async function*() {\n        while(true){\n            const _promise = promise;\n            promise = null;\n            const { chunk: chunk, done: done, cb: cb } = await _promise;\n            $ibaza.nextTick(cb);\n            if (done) return;\n            if (signal.aborted) throw new $f382eca2b5a16cc3$var$AbortError(undefined, {\n                cause: signal.reason\n            });\n            ({ promise: promise, resolve: resolve } = $f382eca2b5a16cc3$require$createDeferredPromise());\n            yield chunk;\n        }\n    }(), {\n        signal: signal\n    });\n    return {\n        value: value,\n        write (chunk, encoding, cb) {\n            const _resolve = resolve;\n            resolve = null;\n            _resolve({\n                chunk: chunk,\n                done: false,\n                cb: cb\n            });\n        },\n        final (cb) {\n            const _resolve = resolve;\n            resolve = null;\n            _resolve({\n                done: true,\n                cb: cb\n            });\n        },\n        destroy (err, cb) {\n            ac.abort();\n            cb(err);\n        }\n    };\n}\nfunction $f382eca2b5a16cc3$var$_duplexify(pair) {\n    const r = pair.readable && typeof pair.readable.read !== 'function' ? $c6GJA.wrap(pair.readable) : pair.readable;\n    const w = pair.writable;\n    let readable = !!$f382eca2b5a16cc3$require$isReadable(r);\n    let writable = !!$f382eca2b5a16cc3$require$isWritable(w);\n    let ondrain;\n    let onfinish;\n    let onreadable;\n    let onclose;\n    let d;\n    function onfinished(err) {\n        const cb = onclose;\n        onclose = null;\n        if (cb) cb(err);\n        else if (err) d.destroy(err);\n    }\n    // TODO(ronag): Avoid double buffering.\n    // Implement Writable/Readable/Duplex traits.\n    // See, https://github.com/nodejs/node/pull/33515.\n    d = new $f382eca2b5a16cc3$var$Duplexify({\n        // TODO (ronag): highWaterMark?\n        readableObjectMode: !!(r !== null && r !== undefined && r.readableObjectMode),\n        writableObjectMode: !!(w !== null && w !== undefined && w.writableObjectMode),\n        readable: readable,\n        writable: writable\n    });\n    if (writable) {\n        $9RUbc(w, (err)=>{\n            writable = false;\n            if (err) $f382eca2b5a16cc3$require$destroyer(r, err);\n            onfinished(err);\n        });\n        d._write = function(chunk, encoding, callback) {\n            if (w.write(chunk, encoding)) callback();\n            else ondrain = callback;\n        };\n        d._final = function(callback) {\n            w.end();\n            onfinish = callback;\n        };\n        w.on('drain', function() {\n            if (ondrain) {\n                const cb = ondrain;\n                ondrain = null;\n                cb();\n            }\n        });\n        w.on('finish', function() {\n            if (onfinish) {\n                const cb = onfinish;\n                onfinish = null;\n                cb();\n            }\n        });\n    }\n    if (readable) {\n        $9RUbc(r, (err)=>{\n            readable = false;\n            if (err) $f382eca2b5a16cc3$require$destroyer(r, err);\n            onfinished(err);\n        });\n        r.on('readable', function() {\n            if (onreadable) {\n                const cb = onreadable;\n                onreadable = null;\n                cb();\n            }\n        });\n        r.on('end', function() {\n            d.push(null);\n        });\n        d._read = function() {\n            while(true){\n                const buf = r.read();\n                if (buf === null) {\n                    onreadable = d._read;\n                    return;\n                }\n                if (!d.push(buf)) return;\n            }\n        };\n    }\n    d._destroy = function(err, callback) {\n        if (!err && onclose !== null) err = new $f382eca2b5a16cc3$var$AbortError();\n        onreadable = null;\n        ondrain = null;\n        onfinish = null;\n        if (onclose === null) callback(err);\n        else {\n            onclose = callback;\n            $f382eca2b5a16cc3$require$destroyer(w, err);\n            $f382eca2b5a16cc3$require$destroyer(r, err);\n        }\n    };\n    return d;\n}\n\n});\n\n\nparcelRegister(\"kFz2c\", function(module, exports) {\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n'use strict';\n\nvar $1by5F = parcelRequire(\"1by5F\");\nvar $f0c2d01a397db093$require$ObjectSetPrototypeOf = $1by5F.ObjectSetPrototypeOf;\nmodule.exports = $f0c2d01a397db093$var$PassThrough;\n\nvar $eI51J = parcelRequire(\"eI51J\");\n$f0c2d01a397db093$require$ObjectSetPrototypeOf($f0c2d01a397db093$var$PassThrough.prototype, $eI51J.prototype);\n$f0c2d01a397db093$require$ObjectSetPrototypeOf($f0c2d01a397db093$var$PassThrough, $eI51J);\nfunction $f0c2d01a397db093$var$PassThrough(options) {\n    if (!(this instanceof $f0c2d01a397db093$var$PassThrough)) return new $f0c2d01a397db093$var$PassThrough(options);\n    $eI51J.call(this, options);\n}\n$f0c2d01a397db093$var$PassThrough.prototype._transform = function(chunk, encoding, cb) {\n    cb(null, chunk);\n};\n\n});\nparcelRegister(\"eI51J\", function(module, exports) {\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n'use strict';\n\nvar $1by5F = parcelRequire(\"1by5F\");\nvar $ab59130290515076$require$ObjectSetPrototypeOf = $1by5F.ObjectSetPrototypeOf;\nvar $ab59130290515076$require$Symbol = $1by5F.Symbol;\nmodule.exports = $ab59130290515076$var$Transform;\n\nvar $7ynhX = parcelRequire(\"7ynhX\");\nconst { ERR_METHOD_NOT_IMPLEMENTED: $ab59130290515076$var$ERR_METHOD_NOT_IMPLEMENTED } = $7ynhX.codes;\n\nvar $lyuEd = parcelRequire(\"lyuEd\");\n\nvar $bKeTG = parcelRequire(\"bKeTG\");\nvar $ab59130290515076$require$getHighWaterMark = $bKeTG.getHighWaterMark;\n$ab59130290515076$require$ObjectSetPrototypeOf($ab59130290515076$var$Transform.prototype, $lyuEd.prototype);\n$ab59130290515076$require$ObjectSetPrototypeOf($ab59130290515076$var$Transform, $lyuEd);\nconst $ab59130290515076$var$kCallback = $ab59130290515076$require$Symbol('kCallback');\nfunction $ab59130290515076$var$Transform(options) {\n    if (!(this instanceof $ab59130290515076$var$Transform)) return new $ab59130290515076$var$Transform(options);\n    // TODO (ronag): This should preferably always be\n    // applied but would be semver-major. Or even better;\n    // make Transform a Readable with the Writable interface.\n    const readableHighWaterMark = options ? $ab59130290515076$require$getHighWaterMark(this, options, 'readableHighWaterMark', true) : null;\n    if (readableHighWaterMark === 0) // A Duplex will buffer both on the writable and readable side while\n    // a Transform just wants to buffer hwm number of elements. To avoid\n    // buffering twice we disable buffering on the writable side.\n    options = {\n        ...options,\n        highWaterMark: null,\n        readableHighWaterMark: readableHighWaterMark,\n        // TODO (ronag): 0 is not optimal since we have\n        // a \"bug\" where we check needDrain before calling _write and not after.\n        // Refs: https://github.com/nodejs/node/pull/32887\n        // Refs: https://github.com/nodejs/node/pull/35941\n        writableHighWaterMark: options.writableHighWaterMark || 0\n    };\n    $lyuEd.call(this, options);\n    // We have implemented the _read method, and done the other things\n    // that Readable wants before the first _read call, so unset the\n    // sync guard flag.\n    this._readableState.sync = false;\n    this[$ab59130290515076$var$kCallback] = null;\n    if (options) {\n        if (typeof options.transform === 'function') this._transform = options.transform;\n        if (typeof options.flush === 'function') this._flush = options.flush;\n    }\n    // When the writable side finishes, then flush out anything remaining.\n    // Backwards compat. Some Transform streams incorrectly implement _final\n    // instead of or in addition to _flush. By using 'prefinish' instead of\n    // implementing _final we continue supporting this unfortunate use case.\n    this.on('prefinish', $ab59130290515076$var$prefinish);\n}\nfunction $ab59130290515076$var$final(cb) {\n    if (typeof this._flush === 'function' && !this.destroyed) this._flush((er, data)=>{\n        if (er) {\n            if (cb) cb(er);\n            else this.destroy(er);\n            return;\n        }\n        if (data != null) this.push(data);\n        this.push(null);\n        if (cb) cb();\n    });\n    else {\n        this.push(null);\n        if (cb) cb();\n    }\n}\nfunction $ab59130290515076$var$prefinish() {\n    if (this._final !== $ab59130290515076$var$final) $ab59130290515076$var$final.call(this);\n}\n$ab59130290515076$var$Transform.prototype._final = $ab59130290515076$var$final;\n$ab59130290515076$var$Transform.prototype._transform = function(chunk, encoding, callback) {\n    throw new $ab59130290515076$var$ERR_METHOD_NOT_IMPLEMENTED('_transform()');\n};\n$ab59130290515076$var$Transform.prototype._write = function(chunk, encoding, callback) {\n    const rState = this._readableState;\n    const wState = this._writableState;\n    const length = rState.length;\n    this._transform(chunk, encoding, (err, val)=>{\n        if (err) {\n            callback(err);\n            return;\n        }\n        if (val != null) this.push(val);\n        if (wState.ended || // Backwards compat.\n        length === rState.length || // Backwards compat.\n        rState.length < rState.highWaterMark) callback();\n        else this[$ab59130290515076$var$kCallback] = callback;\n    });\n};\n$ab59130290515076$var$Transform.prototype._read = function() {\n    if (this[$ab59130290515076$var$kCallback]) {\n        const callback = this[$ab59130290515076$var$kCallback];\n        this[$ab59130290515076$var$kCallback] = null;\n        callback();\n    }\n};\n\n});\n\n\nvar $858c50017c7e043d$exports = {};\n\n$parcel$defineInteropFlag($858c50017c7e043d$exports);\n\n$parcel$export($858c50017c7e043d$exports, \"default\", () => $858c50017c7e043d$export$2e2bcd8739ae039);\n$parcel$export($858c50017c7e043d$exports, \"Lexer\", () => $ddaccca9a53aa58d$export$2e2bcd8739ae039);\n$parcel$export($858c50017c7e043d$exports, \"Parser\", () => $bcb493474cb21cf3$export$2e2bcd8739ae039);\n$parcel$export($858c50017c7e043d$exports, \"Writer\", () => $33fd654882eefc25$export$2e2bcd8739ae039);\n$parcel$export($858c50017c7e043d$exports, \"Store\", () => $36d531372a4b28ea$export$2e2bcd8739ae039);\n$parcel$export($858c50017c7e043d$exports, \"StoreFactory\", () => $4d0027ecfd24bd04$export$2e2bcd8739ae039);\n$parcel$export($858c50017c7e043d$exports, \"EntityIndex\", () => $36d531372a4b28ea$export$4e0df93146cafeaf);\n$parcel$export($858c50017c7e043d$exports, \"StreamParser\", () => $10e0b72da560a634$export$2e2bcd8739ae039);\n$parcel$export($858c50017c7e043d$exports, \"StreamWriter\", () => $20ba4d3d17382691$export$2e2bcd8739ae039);\n$parcel$export($858c50017c7e043d$exports, \"Util\", () => $d6cb6627f0e6b6dd$exports);\n$parcel$export($858c50017c7e043d$exports, \"Reasoner\", () => $def31a84d5beabde$export$2e2bcd8739ae039);\n$parcel$export($858c50017c7e043d$exports, \"BaseIRI\", () => $10447076e5190544$export$2e2bcd8739ae039);\n$parcel$export($858c50017c7e043d$exports, \"DataFactory\", () => $7b385df8cba0e42c$export$2e2bcd8739ae039);\n$parcel$export($858c50017c7e043d$exports, \"Term\", () => $7b385df8cba0e42c$export$656c1e606ad06131);\n$parcel$export($858c50017c7e043d$exports, \"NamedNode\", () => $7b385df8cba0e42c$export$e55689a56c4c92c2);\n$parcel$export($858c50017c7e043d$exports, \"Literal\", () => $7b385df8cba0e42c$export$e175ae9e414693bc);\n$parcel$export($858c50017c7e043d$exports, \"BlankNode\", () => $7b385df8cba0e42c$export$1a8019c085269883);\n$parcel$export($858c50017c7e043d$exports, \"Variable\", () => $7b385df8cba0e42c$export$c867a5c9595a1350);\n$parcel$export($858c50017c7e043d$exports, \"DefaultGraph\", () => $7b385df8cba0e42c$export$4383f89a7161b240);\n$parcel$export($858c50017c7e043d$exports, \"Quad\", () => $7b385df8cba0e42c$export$7005c9eb6671414d);\n$parcel$export($858c50017c7e043d$exports, \"Triple\", () => $7b385df8cba0e42c$export$7005c9eb6671414d);\n$parcel$export($858c50017c7e043d$exports, \"termFromId\", () => $7b385df8cba0e42c$export$85285e91bbd99cf);\n$parcel$export($858c50017c7e043d$exports, \"termToId\", () => $7b385df8cba0e42c$export$fbf03d1179c9227e);\n$parcel$export($858c50017c7e043d$exports, \"getRulesFromDataset\", () => $def31a84d5beabde$export$d4c7b9e4255161a);\n// **N3Lexer** tokenizes N3 documents.\n\nvar $N0o3H = parcelRequire(\"N0o3H\");\nconst $09690bd0f6e8ba27$var$RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#', $09690bd0f6e8ba27$var$XSD = 'http://www.w3.org/2001/XMLSchema#', $09690bd0f6e8ba27$var$SWAP = 'http://www.w3.org/2000/10/swap/';\nvar $09690bd0f6e8ba27$export$2e2bcd8739ae039 = {\n    xsd: {\n        decimal: `${$09690bd0f6e8ba27$var$XSD}decimal`,\n        boolean: `${$09690bd0f6e8ba27$var$XSD}boolean`,\n        double: `${$09690bd0f6e8ba27$var$XSD}double`,\n        integer: `${$09690bd0f6e8ba27$var$XSD}integer`,\n        string: `${$09690bd0f6e8ba27$var$XSD}string`\n    },\n    rdf: {\n        type: `${$09690bd0f6e8ba27$var$RDF}type`,\n        nil: `${$09690bd0f6e8ba27$var$RDF}nil`,\n        first: `${$09690bd0f6e8ba27$var$RDF}first`,\n        rest: `${$09690bd0f6e8ba27$var$RDF}rest`,\n        langString: `${$09690bd0f6e8ba27$var$RDF}langString`\n    },\n    owl: {\n        sameAs: 'http://www.w3.org/2002/07/owl#sameAs'\n    },\n    r: {\n        forSome: `${$09690bd0f6e8ba27$var$SWAP}reify#forSome`,\n        forAll: `${$09690bd0f6e8ba27$var$SWAP}reify#forAll`\n    },\n    log: {\n        implies: `${$09690bd0f6e8ba27$var$SWAP}log#implies`,\n        isImpliedBy: `${$09690bd0f6e8ba27$var$SWAP}log#isImpliedBy`\n    }\n};\n\n\nconst { xsd: $ddaccca9a53aa58d$var$xsd } = (0, $09690bd0f6e8ba27$export$2e2bcd8739ae039);\n// Regular expression and replacement string to escape N3 strings\nconst $ddaccca9a53aa58d$var$escapeSequence = /\\\\u([a-fA-F0-9]{4})|\\\\U([a-fA-F0-9]{8})|\\\\([^])/g;\nconst $ddaccca9a53aa58d$var$escapeReplacements = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '\"': '\"',\n    'n': '\\n',\n    'r': '\\r',\n    't': '\\t',\n    'f': '\\f',\n    'b': '\\b',\n    '_': '_',\n    '~': '~',\n    '.': '.',\n    '-': '-',\n    '!': '!',\n    '$': '$',\n    '&': '&',\n    '(': '(',\n    ')': ')',\n    '*': '*',\n    '+': '+',\n    ',': ',',\n    ';': ';',\n    '=': '=',\n    '/': '/',\n    '?': '?',\n    '#': '#',\n    '@': '@',\n    '%': '%'\n};\nconst $ddaccca9a53aa58d$var$illegalIriChars = /[\\x00-\\x20<>\\\\\"\\{\\}\\|\\^\\`]/;\nconst $ddaccca9a53aa58d$var$lineModeRegExps = {\n    _iri: true,\n    _unescapedIri: true,\n    _simpleQuotedString: true,\n    _langcode: true,\n    _blank: true,\n    _newline: true,\n    _comment: true,\n    _whitespace: true,\n    _endOfFile: true\n};\nconst $ddaccca9a53aa58d$var$invalidRegExp = /$0^/;\nclass $ddaccca9a53aa58d$export$2e2bcd8739ae039 {\n    constructor(options){\n        // ## Regular expressions\n        // It's slightly faster to have these as properties than as in-scope variables\n        this._iri = /^<((?:[^ <>{}\\\\]|\\\\[uU])+)>[ \\t]*/; // IRI with escape sequences; needs sanity check after unescaping\n        this._unescapedIri = /^<([^\\x00-\\x20<>\\\\\"\\{\\}\\|\\^\\`]*)>[ \\t]*/; // IRI without escape sequences; no unescaping\n        this._simpleQuotedString = /^\"([^\"\\\\\\r\\n]*)\"(?=[^\"])/; // string without escape sequences\n        this._simpleApostropheString = /^'([^'\\\\\\r\\n]*)'(?=[^'])/;\n        this._langcode = /^@([a-z]+(?:-[a-z0-9]+)*)(?=[^a-z0-9\\-])/i;\n        this._prefix = /^((?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)?:(?=[#\\s<])/;\n        this._prefixed = /^((?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)?:((?:(?:[0-:A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~])(?:(?:[\\.\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~])*(?:[\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~]))?)?)(?:[ \\t]+|(?=\\.?[,;!\\^\\s#()\\[\\]\\{\\}\"'<>]))/;\n        this._variable = /^\\?(?:(?:[A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:[\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)(?=[.,;!\\^\\s#()\\[\\]\\{\\}\"'<>])/;\n        this._blank = /^_:((?:[0-9A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)(?:[ \\t]+|(?=\\.?[,;:\\s#()\\[\\]\\{\\}\"'<>]))/;\n        this._number = /^[\\-+]?(?:(\\d+\\.\\d*|\\.?\\d+)[eE][\\-+]?|\\d*(\\.)?)\\d+(?=\\.?[,;:\\s#()\\[\\]\\{\\}\"'<>])/;\n        this._boolean = /^(?:true|false)(?=[.,;\\s#()\\[\\]\\{\\}\"'<>])/;\n        this._keyword = /^@[a-z]+(?=[\\s#<:])/i;\n        this._sparqlKeyword = /^(?:PREFIX|BASE|GRAPH)(?=[\\s#<])/i;\n        this._shortPredicates = /^a(?=[\\s#()\\[\\]\\{\\}\"'<>])/;\n        this._newline = /^[ \\t]*(?:#[^\\n\\r]*)?(?:\\r\\n|\\n|\\r)[ \\t]*/;\n        this._comment = /#([^\\n\\r]*)/;\n        this._whitespace = /^[ \\t]+/;\n        this._endOfFile = /^(?:#[^\\n\\r]*)?$/;\n        options = options || {};\n        // Whether the log:isImpliedBy predicate is supported\n        this._isImpliedBy = options.isImpliedBy;\n        // In line mode (N-Triples or N-Quads), only simple features may be parsed\n        if (this._lineMode = !!options.lineMode) {\n            this._n3Mode = false;\n            // Don't tokenize special literals\n            for(const key in this)if (!(key in $ddaccca9a53aa58d$var$lineModeRegExps) && this[key] instanceof RegExp) this[key] = $ddaccca9a53aa58d$var$invalidRegExp;\n        } else this._n3Mode = options.n3 !== false;\n        // Don't output comment tokens by default\n        this.comments = !!options.comments;\n        // Cache the last tested closing position of long literals\n        this._literalClosingPos = 0;\n    }\n    // ## Private methods\n    // ### `_tokenizeToEnd` tokenizes as for as possible, emitting tokens through the callback\n    _tokenizeToEnd(callback, inputFinished) {\n        // Continue parsing as far as possible; the loop will return eventually\n        let input = this._input;\n        let currentLineLength = input.length;\n        while(true){\n            // Count and skip whitespace lines\n            let whiteSpaceMatch, comment;\n            while(whiteSpaceMatch = this._newline.exec(input)){\n                // Try to find a comment\n                if (this.comments && (comment = this._comment.exec(whiteSpaceMatch[0]))) emitToken('comment', comment[1], '', this._line, whiteSpaceMatch[0].length);\n                // Advance the input\n                input = input.substr(whiteSpaceMatch[0].length, input.length);\n                currentLineLength = input.length;\n                this._line++;\n            }\n            // Skip whitespace on current line\n            if (!whiteSpaceMatch && (whiteSpaceMatch = this._whitespace.exec(input))) input = input.substr(whiteSpaceMatch[0].length, input.length);\n            // Stop for now if we're at the end\n            if (this._endOfFile.test(input)) {\n                // If the input is finished, emit EOF\n                if (inputFinished) {\n                    // Try to find a final comment\n                    if (this.comments && (comment = this._comment.exec(input))) emitToken('comment', comment[1], '', this._line, input.length);\n                    input = null;\n                    emitToken('eof', '', '', this._line, 0);\n                }\n                return this._input = input;\n            }\n            // Look for specific token types based on the first character\n            const line = this._line, firstChar = input[0];\n            let type = '', value = '', prefix = '', match = null, matchLength = 0, inconclusive = false;\n            switch(firstChar){\n                case '^':\n                    // We need at least 3 tokens lookahead to distinguish ^^<IRI> and ^^pre:fixed\n                    if (input.length < 3) break;\n                    else if (input[1] === '^') {\n                        this._previousMarker = '^^';\n                        // Move to type IRI or prefixed name\n                        input = input.substr(2);\n                        if (input[0] !== '<') {\n                            inconclusive = true;\n                            break;\n                        }\n                    } else {\n                        if (this._n3Mode) {\n                            matchLength = 1;\n                            type = '^';\n                        }\n                        break;\n                    }\n                // Fall through in case the type is an IRI\n                case '<':\n                    // Try to find a full IRI without escape sequences\n                    if (match = this._unescapedIri.exec(input)) type = 'IRI', value = match[1];\n                    else if (match = this._iri.exec(input)) {\n                        value = this._unescape(match[1]);\n                        if (value === null || $ddaccca9a53aa58d$var$illegalIriChars.test(value)) return reportSyntaxError(this);\n                        type = 'IRI';\n                    } else if (input.length > 1 && input[1] === '<') type = '<<', matchLength = 2;\n                    else if (this._n3Mode && input.length > 1 && input[1] === '=') {\n                        matchLength = 2;\n                        if (this._isImpliedBy) type = 'abbreviation', value = '<';\n                        else type = 'inverse', value = '>';\n                    }\n                    break;\n                case '>':\n                    if (input.length > 1 && input[1] === '>') type = '>>', matchLength = 2;\n                    break;\n                case '_':\n                    // Try to find a blank node. Since it can contain (but not end with) a dot,\n                    // we always need a non-dot character before deciding it is a blank node.\n                    // Therefore, try inserting a space if we're at the end of the input.\n                    if ((match = this._blank.exec(input)) || inputFinished && (match = this._blank.exec(`${input} `))) type = 'blank', prefix = '_', value = match[1];\n                    break;\n                case '\"':\n                    // Try to find a literal without escape sequences\n                    if (match = this._simpleQuotedString.exec(input)) value = match[1];\n                    else {\n                        ({ value: value, matchLength: matchLength } = this._parseLiteral(input));\n                        if (value === null) return reportSyntaxError(this);\n                    }\n                    if (match !== null || matchLength !== 0) {\n                        type = 'literal';\n                        this._literalClosingPos = 0;\n                    }\n                    break;\n                case \"'\":\n                    if (!this._lineMode) {\n                        // Try to find a literal without escape sequences\n                        if (match = this._simpleApostropheString.exec(input)) value = match[1];\n                        else {\n                            ({ value: value, matchLength: matchLength } = this._parseLiteral(input));\n                            if (value === null) return reportSyntaxError(this);\n                        }\n                        if (match !== null || matchLength !== 0) {\n                            type = 'literal';\n                            this._literalClosingPos = 0;\n                        }\n                    }\n                    break;\n                case '?':\n                    // Try to find a variable\n                    if (this._n3Mode && (match = this._variable.exec(input))) type = 'var', value = match[0];\n                    break;\n                case '@':\n                    // Try to find a language code\n                    if (this._previousMarker === 'literal' && (match = this._langcode.exec(input))) type = 'langcode', value = match[1];\n                    else if (match = this._keyword.exec(input)) type = match[0];\n                    break;\n                case '.':\n                    // Try to find a dot as punctuation\n                    if (input.length === 1 ? inputFinished : input[1] < '0' || input[1] > '9') {\n                        type = '.';\n                        matchLength = 1;\n                        break;\n                    }\n                // Fall through to numerical case (could be a decimal dot)\n                case '0':\n                case '1':\n                case '2':\n                case '3':\n                case '4':\n                case '5':\n                case '6':\n                case '7':\n                case '8':\n                case '9':\n                case '+':\n                case '-':\n                    // Try to find a number. Since it can contain (but not end with) a dot,\n                    // we always need a non-dot character before deciding it is a number.\n                    // Therefore, try inserting a space if we're at the end of the input.\n                    if (match = this._number.exec(input) || inputFinished && (match = this._number.exec(`${input} `))) {\n                        type = 'literal', value = match[0];\n                        prefix = typeof match[1] === 'string' ? $ddaccca9a53aa58d$var$xsd.double : typeof match[2] === 'string' ? $ddaccca9a53aa58d$var$xsd.decimal : $ddaccca9a53aa58d$var$xsd.integer;\n                    }\n                    break;\n                case 'B':\n                case 'b':\n                case 'p':\n                case 'P':\n                case 'G':\n                case 'g':\n                    // Try to find a SPARQL-style keyword\n                    if (match = this._sparqlKeyword.exec(input)) type = match[0].toUpperCase();\n                    else inconclusive = true;\n                    break;\n                case 'f':\n                case 't':\n                    // Try to match a boolean\n                    if (match = this._boolean.exec(input)) type = 'literal', value = match[0], prefix = $ddaccca9a53aa58d$var$xsd.boolean;\n                    else inconclusive = true;\n                    break;\n                case 'a':\n                    // Try to find an abbreviated predicate\n                    if (match = this._shortPredicates.exec(input)) type = 'abbreviation', value = 'a';\n                    else inconclusive = true;\n                    break;\n                case '=':\n                    // Try to find an implication arrow or equals sign\n                    if (this._n3Mode && input.length > 1) {\n                        type = 'abbreviation';\n                        if (input[1] !== '>') matchLength = 1, value = '=';\n                        else matchLength = 2, value = '>';\n                    }\n                    break;\n                case '!':\n                    if (!this._n3Mode) break;\n                case ',':\n                case ';':\n                case '[':\n                case ']':\n                case '(':\n                case ')':\n                case '}':\n                    if (!this._lineMode) {\n                        matchLength = 1;\n                        type = firstChar;\n                    }\n                    break;\n                case '{':\n                    // We need at least 2 tokens lookahead to distinguish \"{|\" and \"{ \"\n                    if (!this._lineMode && input.length >= 2) {\n                        // Try to find a quoted triple annotation start\n                        if (input[1] === '|') type = '{|', matchLength = 2;\n                        else type = firstChar, matchLength = 1;\n                    }\n                    break;\n                case '|':\n                    // We need 2 tokens lookahead to parse \"|}\"\n                    // Try to find a quoted triple annotation end\n                    if (input.length >= 2 && input[1] === '}') type = '|}', matchLength = 2;\n                    break;\n                default:\n                    inconclusive = true;\n            }\n            // Some first characters do not allow an immediate decision, so inspect more\n            if (inconclusive) {\n                // Try to find a prefix\n                if ((this._previousMarker === '@prefix' || this._previousMarker === 'PREFIX') && (match = this._prefix.exec(input))) type = 'prefix', value = match[1] || '';\n                else if ((match = this._prefixed.exec(input)) || inputFinished && (match = this._prefixed.exec(`${input} `))) type = 'prefixed', prefix = match[1] || '', value = this._unescape(match[2]);\n            }\n            // A type token is special: it can only be emitted after an IRI or prefixed name is read\n            if (this._previousMarker === '^^') switch(type){\n                case 'prefixed':\n                    type = 'type';\n                    break;\n                case 'IRI':\n                    type = 'typeIRI';\n                    break;\n                default:\n                    type = '';\n            }\n            // What if nothing of the above was found?\n            if (!type) {\n                // We could be in streaming mode, and then we just wait for more input to arrive.\n                // Otherwise, a syntax error has occurred in the input.\n                // One exception: error on an unaccounted linebreak (= not inside a triple-quoted literal).\n                if (inputFinished || !/^'''|^\"\"\"/.test(input) && /\\n|\\r/.test(input)) return reportSyntaxError(this);\n                else return this._input = input;\n            }\n            // Emit the parsed token\n            const length = matchLength || match[0].length;\n            const token = emitToken(type, value, prefix, line, length);\n            this.previousToken = token;\n            this._previousMarker = type;\n            // Advance to next part to tokenize\n            input = input.substr(length, input.length);\n        }\n        // Emits the token through the callback\n        function emitToken(type, value, prefix, line, length) {\n            const start = input ? currentLineLength - input.length : currentLineLength;\n            const end = start + length;\n            const token = {\n                type: type,\n                value: value,\n                prefix: prefix,\n                line: line,\n                start: start,\n                end: end\n            };\n            callback(null, token);\n            return token;\n        }\n        // Signals the syntax error through the callback\n        function reportSyntaxError(self) {\n            callback(self._syntaxError(/^\\S*/.exec(input)[0]));\n        }\n    }\n    // ### `_unescape` replaces N3 escape codes by their corresponding characters\n    _unescape(item) {\n        let invalid = false;\n        const replaced = item.replace($ddaccca9a53aa58d$var$escapeSequence, (sequence, unicode4, unicode8, escapedChar)=>{\n            // 4-digit unicode character\n            if (typeof unicode4 === 'string') return String.fromCharCode(Number.parseInt(unicode4, 16));\n            // 8-digit unicode character\n            if (typeof unicode8 === 'string') {\n                let charCode = Number.parseInt(unicode8, 16);\n                return charCode <= 0xFFFF ? String.fromCharCode(Number.parseInt(unicode8, 16)) : String.fromCharCode(0xD800 + ((charCode -= 0x10000) >> 10), 0xDC00 + (charCode & 0x3FF));\n            }\n            // fixed escape sequence\n            if (escapedChar in $ddaccca9a53aa58d$var$escapeReplacements) return $ddaccca9a53aa58d$var$escapeReplacements[escapedChar];\n            // invalid escape sequence\n            invalid = true;\n            return '';\n        });\n        return invalid ? null : replaced;\n    }\n    // ### `_parseLiteral` parses a literal into an unescaped value\n    _parseLiteral(input) {\n        // Ensure we have enough lookahead to identify triple-quoted strings\n        if (input.length >= 3) {\n            // Identify the opening quote(s)\n            const opening = input.match(/^(?:\"\"\"|\"|'''|'|)/)[0];\n            const openingLength = opening.length;\n            // Find the next candidate closing quotes\n            let closingPos = Math.max(this._literalClosingPos, openingLength);\n            while((closingPos = input.indexOf(opening, closingPos)) > 0){\n                // Count backslashes right before the closing quotes\n                let backslashCount = 0;\n                while(input[closingPos - backslashCount - 1] === '\\\\')backslashCount++;\n                // An even number of backslashes (in particular 0)\n                // means these are actual, non-escaped closing quotes\n                if (backslashCount % 2 === 0) {\n                    // Extract and unescape the value\n                    const raw = input.substring(openingLength, closingPos);\n                    const lines = raw.split(/\\r\\n|\\r|\\n/).length - 1;\n                    const matchLength = closingPos + openingLength;\n                    // Only triple-quoted strings can be multi-line\n                    if (openingLength === 1 && lines !== 0 || openingLength === 3 && this._lineMode) break;\n                    this._line += lines;\n                    return {\n                        value: this._unescape(raw),\n                        matchLength: matchLength\n                    };\n                }\n                closingPos++;\n            }\n            this._literalClosingPos = input.length - openingLength + 1;\n        }\n        return {\n            value: '',\n            matchLength: 0\n        };\n    }\n    // ### `_syntaxError` creates a syntax error for the given issue\n    _syntaxError(issue) {\n        this._input = null;\n        const err = new Error(`Unexpected \"${issue}\" on line ${this._line}.`);\n        err.context = {\n            token: undefined,\n            line: this._line,\n            previousToken: this.previousToken\n        };\n        return err;\n    }\n    // ### Strips off any starting UTF BOM mark.\n    _readStartingBom(input) {\n        return input.startsWith('\\ufeff') ? input.substr(1) : input;\n    }\n    // ## Public methods\n    // ### `tokenize` starts the transformation of an N3 document into an array of tokens.\n    // The input can be a string or a stream.\n    tokenize(input, callback) {\n        this._line = 1;\n        // If the input is a string, continuously emit tokens through the callback until the end\n        if (typeof input === 'string') {\n            this._input = this._readStartingBom(input);\n            // If a callback was passed, asynchronously call it\n            if (typeof callback === 'function') queueMicrotask(()=>this._tokenizeToEnd(callback, true));\n            else {\n                const tokens = [];\n                let error;\n                this._tokenizeToEnd((e, t)=>e ? error = e : tokens.push(t), true);\n                if (error) throw error;\n                return tokens;\n            }\n        } else {\n            this._pendingBuffer = null;\n            if (typeof input.setEncoding === 'function') input.setEncoding('utf8');\n            // Adds the data chunk to the buffer and parses as far as possible\n            input.on('data', (data)=>{\n                if (this._input !== null && data.length !== 0) {\n                    // Prepend any previous pending writes\n                    if (this._pendingBuffer) {\n                        data = (0, $N0o3H.Buffer).concat([\n                            this._pendingBuffer,\n                            data\n                        ]);\n                        this._pendingBuffer = null;\n                    }\n                    // Hold if the buffer ends in an incomplete unicode sequence\n                    if (data[data.length - 1] & 0x80) this._pendingBuffer = data;\n                    else {\n                        // Only read a BOM at the start\n                        if (typeof this._input === 'undefined') this._input = this._readStartingBom(typeof data === 'string' ? data : data.toString());\n                        else this._input += data;\n                        this._tokenizeToEnd(callback, false);\n                    }\n                }\n            });\n            // Parses until the end\n            input.on('end', ()=>{\n                if (typeof this._input === 'string') this._tokenizeToEnd(callback, true);\n            });\n            input.on('error', callback);\n        }\n    }\n}\n\n\n// **N3Parser** parses N3 documents.\n\n// N3.js implementations of the RDF/JS core data types\n// See http://rdf.js.org/data-model-spec/\n\nconst { rdf: $7b385df8cba0e42c$var$rdf, xsd: $7b385df8cba0e42c$var$xsd } = (0, $09690bd0f6e8ba27$export$2e2bcd8739ae039);\n// eslint-disable-next-line prefer-const\nlet $7b385df8cba0e42c$var$DEFAULTGRAPH;\nlet $7b385df8cba0e42c$var$_blankNodeCounter = 0;\nconst $7b385df8cba0e42c$var$escapedLiteral = /^\"(.*\".*)(?=\"[^\"]*$)/;\n// ## DataFactory singleton\nconst $7b385df8cba0e42c$var$DataFactory = {\n    namedNode: $7b385df8cba0e42c$var$namedNode,\n    blankNode: $7b385df8cba0e42c$var$blankNode,\n    variable: $7b385df8cba0e42c$var$variable,\n    literal: $7b385df8cba0e42c$var$literal,\n    defaultGraph: $7b385df8cba0e42c$var$defaultGraph,\n    quad: $7b385df8cba0e42c$var$quad,\n    triple: $7b385df8cba0e42c$var$quad,\n    fromTerm: $7b385df8cba0e42c$export$5f4f0fc25db47ca3,\n    fromQuad: $7b385df8cba0e42c$export$10a0669b95c12803\n};\nvar $7b385df8cba0e42c$export$2e2bcd8739ae039 = $7b385df8cba0e42c$var$DataFactory;\nclass $7b385df8cba0e42c$export$656c1e606ad06131 {\n    constructor(id){\n        this.id = id;\n    }\n    // ### The value of this term\n    get value() {\n        return this.id;\n    }\n    // ### Returns whether this object represents the same term as the other\n    equals(other) {\n        // If both terms were created by this library,\n        // equality can be computed through ids\n        if (other instanceof $7b385df8cba0e42c$export$656c1e606ad06131) return this.id === other.id;\n        // Otherwise, compare term type and value\n        return !!other && this.termType === other.termType && this.value === other.value;\n    }\n    // ### Implement hashCode for Immutable.js, since we implement `equals`\n    // https://immutable-js.com/docs/v4.0.0/ValueObject/#hashCode()\n    hashCode() {\n        return 0;\n    }\n    // ### Returns a plain object representation of this term\n    toJSON() {\n        return {\n            termType: this.termType,\n            value: this.value\n        };\n    }\n}\nclass $7b385df8cba0e42c$export$e55689a56c4c92c2 extends $7b385df8cba0e42c$export$656c1e606ad06131 {\n    // ### The term type of this term\n    get termType() {\n        return 'NamedNode';\n    }\n}\nclass $7b385df8cba0e42c$export$e175ae9e414693bc extends $7b385df8cba0e42c$export$656c1e606ad06131 {\n    // ### The term type of this term\n    get termType() {\n        return 'Literal';\n    }\n    // ### The text value of this literal\n    get value() {\n        return this.id.substring(1, this.id.lastIndexOf('\"'));\n    }\n    // ### The language of this literal\n    get language() {\n        // Find the last quotation mark (e.g., '\"abc\"@en-us')\n        const id = this.id;\n        let atPos = id.lastIndexOf('\"') + 1;\n        // If \"@\" it follows, return the remaining substring; empty otherwise\n        return atPos < id.length && id[atPos++] === '@' ? id.substr(atPos).toLowerCase() : '';\n    }\n    // ### The datatype IRI of this literal\n    get datatype() {\n        return new $7b385df8cba0e42c$export$e55689a56c4c92c2(this.datatypeString);\n    }\n    // ### The datatype string of this literal\n    get datatypeString() {\n        // Find the last quotation mark (e.g., '\"abc\"^^http://ex.org/types#t')\n        const id = this.id, dtPos = id.lastIndexOf('\"') + 1;\n        const char = dtPos < id.length ? id[dtPos] : '';\n        // If \"^\" it follows, return the remaining substring\n        return char === '^' ? id.substr(dtPos + 2) : // If \"@\" follows, return rdf:langString; xsd:string otherwise\n        char !== '@' ? $7b385df8cba0e42c$var$xsd.string : $7b385df8cba0e42c$var$rdf.langString;\n    }\n    // ### Returns whether this object represents the same term as the other\n    equals(other) {\n        // If both literals were created by this library,\n        // equality can be computed through ids\n        if (other instanceof $7b385df8cba0e42c$export$e175ae9e414693bc) return this.id === other.id;\n        // Otherwise, compare term type, value, language, and datatype\n        return !!other && !!other.datatype && this.termType === other.termType && this.value === other.value && this.language === other.language && this.datatype.value === other.datatype.value;\n    }\n    toJSON() {\n        return {\n            termType: this.termType,\n            value: this.value,\n            language: this.language,\n            datatype: {\n                termType: 'NamedNode',\n                value: this.datatypeString\n            }\n        };\n    }\n}\nclass $7b385df8cba0e42c$export$1a8019c085269883 extends $7b385df8cba0e42c$export$656c1e606ad06131 {\n    constructor(name){\n        super(`_:${name}`);\n    }\n    // ### The term type of this term\n    get termType() {\n        return 'BlankNode';\n    }\n    // ### The name of this blank node\n    get value() {\n        return this.id.substr(2);\n    }\n}\nclass $7b385df8cba0e42c$export$c867a5c9595a1350 extends $7b385df8cba0e42c$export$656c1e606ad06131 {\n    constructor(name){\n        super(`?${name}`);\n    }\n    // ### The term type of this term\n    get termType() {\n        return 'Variable';\n    }\n    // ### The name of this variable\n    get value() {\n        return this.id.substr(1);\n    }\n}\nclass $7b385df8cba0e42c$export$4383f89a7161b240 extends $7b385df8cba0e42c$export$656c1e606ad06131 {\n    constructor(){\n        super('');\n        return $7b385df8cba0e42c$var$DEFAULTGRAPH || this;\n    }\n    // ### The term type of this term\n    get termType() {\n        return 'DefaultGraph';\n    }\n    // ### Returns whether this object represents the same term as the other\n    equals(other) {\n        // If both terms were created by this library,\n        // equality can be computed through strict equality;\n        // otherwise, compare term types.\n        return this === other || !!other && this.termType === other.termType;\n    }\n}\n// ## DefaultGraph singleton\n$7b385df8cba0e42c$var$DEFAULTGRAPH = new $7b385df8cba0e42c$export$4383f89a7161b240();\nfunction $7b385df8cba0e42c$export$85285e91bbd99cf(id, factory, nested) {\n    factory = factory || $7b385df8cba0e42c$var$DataFactory;\n    // Falsy value or empty string indicate the default graph\n    if (!id) return factory.defaultGraph();\n    // Identify the term type based on the first character\n    switch(id[0]){\n        case '?':\n            return factory.variable(id.substr(1));\n        case '_':\n            return factory.blankNode(id.substr(2));\n        case '\"':\n            // Shortcut for internal literals\n            if (factory === $7b385df8cba0e42c$var$DataFactory) return new $7b385df8cba0e42c$export$e175ae9e414693bc(id);\n            // Literal without datatype or language\n            if (id[id.length - 1] === '\"') return factory.literal(id.substr(1, id.length - 2));\n            // Literal with datatype or language\n            const endPos = id.lastIndexOf('\"', id.length - 1);\n            return factory.literal(id.substr(1, endPos - 1), id[endPos + 1] === '@' ? id.substr(endPos + 2) : factory.namedNode(id.substr(endPos + 3)));\n        case '[':\n            id = JSON.parse(id);\n            break;\n        default:\n            if (!nested || !Array.isArray(id)) return factory.namedNode(id);\n    }\n    return factory.quad($7b385df8cba0e42c$export$85285e91bbd99cf(id[0], factory, true), $7b385df8cba0e42c$export$85285e91bbd99cf(id[1], factory, true), $7b385df8cba0e42c$export$85285e91bbd99cf(id[2], factory, true), id[3] && $7b385df8cba0e42c$export$85285e91bbd99cf(id[3], factory, true));\n}\nfunction $7b385df8cba0e42c$export$fbf03d1179c9227e(term, nested) {\n    if (typeof term === 'string') return term;\n    if (term instanceof $7b385df8cba0e42c$export$656c1e606ad06131 && term.termType !== 'Quad') return term.id;\n    if (!term) return $7b385df8cba0e42c$var$DEFAULTGRAPH.id;\n    // Term instantiated with another library\n    switch(term.termType){\n        case 'NamedNode':\n            return term.value;\n        case 'BlankNode':\n            return `_:${term.value}`;\n        case 'Variable':\n            return `?${term.value}`;\n        case 'DefaultGraph':\n            return '';\n        case 'Literal':\n            return `\"${term.value}\"${term.language ? `@${term.language}` : term.datatype && term.datatype.value !== $7b385df8cba0e42c$var$xsd.string ? `^^${term.datatype.value}` : ''}`;\n        case 'Quad':\n            const res = [\n                $7b385df8cba0e42c$export$fbf03d1179c9227e(term.subject, true),\n                $7b385df8cba0e42c$export$fbf03d1179c9227e(term.predicate, true),\n                $7b385df8cba0e42c$export$fbf03d1179c9227e(term.object, true)\n            ];\n            if (term.graph && term.graph.termType !== 'DefaultGraph') res.push($7b385df8cba0e42c$export$fbf03d1179c9227e(term.graph, true));\n            return nested ? res : JSON.stringify(res);\n        default:\n            throw new Error(`Unexpected termType: ${term.termType}`);\n    }\n}\nclass $7b385df8cba0e42c$export$7005c9eb6671414d extends $7b385df8cba0e42c$export$656c1e606ad06131 {\n    constructor(subject, predicate, object, graph){\n        super('');\n        this._subject = subject;\n        this._predicate = predicate;\n        this._object = object;\n        this._graph = graph || $7b385df8cba0e42c$var$DEFAULTGRAPH;\n    }\n    // ### The term type of this term\n    get termType() {\n        return 'Quad';\n    }\n    get subject() {\n        return this._subject;\n    }\n    get predicate() {\n        return this._predicate;\n    }\n    get object() {\n        return this._object;\n    }\n    get graph() {\n        return this._graph;\n    }\n    // ### Returns a plain object representation of this quad\n    toJSON() {\n        return {\n            termType: this.termType,\n            subject: this._subject.toJSON(),\n            predicate: this._predicate.toJSON(),\n            object: this._object.toJSON(),\n            graph: this._graph.toJSON()\n        };\n    }\n    // ### Returns whether this object represents the same quad as the other\n    equals(other) {\n        return !!other && this._subject.equals(other.subject) && this._predicate.equals(other.predicate) && this._object.equals(other.object) && this._graph.equals(other.graph);\n    }\n}\nfunction $7b385df8cba0e42c$export$3ff8cecf0aa87c28(id) {\n    return id.replace($7b385df8cba0e42c$var$escapedLiteral, (_, quoted)=>`\"${quoted.replace(/\"/g, '\"\"')}`);\n}\nfunction $7b385df8cba0e42c$export$7cedbcd33d1bf915(id) {\n    return id.replace($7b385df8cba0e42c$var$escapedLiteral, (_, quoted)=>`\"${quoted.replace(/\"\"/g, '\"')}`);\n}\n// ### Creates an IRI\nfunction $7b385df8cba0e42c$var$namedNode(iri) {\n    return new $7b385df8cba0e42c$export$e55689a56c4c92c2(iri);\n}\n// ### Creates a blank node\nfunction $7b385df8cba0e42c$var$blankNode(name) {\n    return new $7b385df8cba0e42c$export$1a8019c085269883(name || `n3-${$7b385df8cba0e42c$var$_blankNodeCounter++}`);\n}\n// ### Creates a literal\nfunction $7b385df8cba0e42c$var$literal(value, languageOrDataType) {\n    // Create a language-tagged string\n    if (typeof languageOrDataType === 'string') return new $7b385df8cba0e42c$export$e175ae9e414693bc(`\"${value}\"@${languageOrDataType.toLowerCase()}`);\n    // Automatically determine datatype for booleans and numbers\n    let datatype = languageOrDataType ? languageOrDataType.value : '';\n    if (datatype === '') {\n        // Convert a boolean\n        if (typeof value === 'boolean') datatype = $7b385df8cba0e42c$var$xsd.boolean;\n        else if (typeof value === 'number') {\n            if (Number.isFinite(value)) datatype = Number.isInteger(value) ? $7b385df8cba0e42c$var$xsd.integer : $7b385df8cba0e42c$var$xsd.double;\n            else {\n                datatype = $7b385df8cba0e42c$var$xsd.double;\n                if (!Number.isNaN(value)) value = value > 0 ? 'INF' : '-INF';\n            }\n        }\n    }\n    // Create a datatyped literal\n    return datatype === '' || datatype === $7b385df8cba0e42c$var$xsd.string ? new $7b385df8cba0e42c$export$e175ae9e414693bc(`\"${value}\"`) : new $7b385df8cba0e42c$export$e175ae9e414693bc(`\"${value}\"^^${datatype}`);\n}\n// ### Creates a variable\nfunction $7b385df8cba0e42c$var$variable(name) {\n    return new $7b385df8cba0e42c$export$c867a5c9595a1350(name);\n}\n// ### Returns the default graph\nfunction $7b385df8cba0e42c$var$defaultGraph() {\n    return $7b385df8cba0e42c$var$DEFAULTGRAPH;\n}\n// ### Creates a quad\nfunction $7b385df8cba0e42c$var$quad(subject, predicate, object, graph) {\n    return new $7b385df8cba0e42c$export$7005c9eb6671414d(subject, predicate, object, graph);\n}\nfunction $7b385df8cba0e42c$export$5f4f0fc25db47ca3(term) {\n    if (term instanceof $7b385df8cba0e42c$export$656c1e606ad06131) return term;\n    // Term instantiated with another library\n    switch(term.termType){\n        case 'NamedNode':\n            return $7b385df8cba0e42c$var$namedNode(term.value);\n        case 'BlankNode':\n            return $7b385df8cba0e42c$var$blankNode(term.value);\n        case 'Variable':\n            return $7b385df8cba0e42c$var$variable(term.value);\n        case 'DefaultGraph':\n            return $7b385df8cba0e42c$var$DEFAULTGRAPH;\n        case 'Literal':\n            return $7b385df8cba0e42c$var$literal(term.value, term.language || term.datatype);\n        case 'Quad':\n            return $7b385df8cba0e42c$export$10a0669b95c12803(term);\n        default:\n            throw new Error(`Unexpected termType: ${term.termType}`);\n    }\n}\nfunction $7b385df8cba0e42c$export$10a0669b95c12803(inQuad) {\n    if (inQuad instanceof $7b385df8cba0e42c$export$7005c9eb6671414d) return inQuad;\n    if (inQuad.termType !== 'Quad') throw new Error(`Unexpected termType: ${inQuad.termType}`);\n    return $7b385df8cba0e42c$var$quad($7b385df8cba0e42c$export$5f4f0fc25db47ca3(inQuad.subject), $7b385df8cba0e42c$export$5f4f0fc25db47ca3(inQuad.predicate), $7b385df8cba0e42c$export$5f4f0fc25db47ca3(inQuad.object), $7b385df8cba0e42c$export$5f4f0fc25db47ca3(inQuad.graph));\n}\n\n\n\nlet $bcb493474cb21cf3$var$blankNodePrefix = 0;\nclass $bcb493474cb21cf3$export$2e2bcd8739ae039 {\n    constructor(options){\n        this._contextStack = [];\n        this._graph = null;\n        // Set the document IRI\n        options = options || {};\n        this._setBase(options.baseIRI);\n        options.factory && $bcb493474cb21cf3$var$initDataFactory(this, options.factory);\n        // Set supported features depending on the format\n        const format = typeof options.format === 'string' ? options.format.match(/\\w*$/)[0].toLowerCase() : '', isTurtle = /turtle/.test(format), isTriG = /trig/.test(format), isNTriples = /triple/.test(format), isNQuads = /quad/.test(format), isN3 = this._n3Mode = /n3/.test(format), isLineMode = isNTriples || isNQuads;\n        if (!(this._supportsNamedGraphs = !(isTurtle || isN3))) this._readPredicateOrNamedGraph = this._readPredicate;\n        // Support triples in other graphs\n        this._supportsQuads = !(isTurtle || isTriG || isNTriples || isN3);\n        // Whether the log:isImpliedBy predicate is supported\n        this._isImpliedBy = options.isImpliedBy;\n        // Support nesting of triples\n        this._supportsRDFStar = format === '' || /star|\\*$/.test(format);\n        // Disable relative IRIs in N-Triples or N-Quads mode\n        if (isLineMode) this._resolveRelativeIRI = (iri)=>{\n            return null;\n        };\n        this._blankNodePrefix = typeof options.blankNodePrefix !== 'string' ? '' : options.blankNodePrefix.replace(/^(?!_:)/, '_:');\n        this._lexer = options.lexer || new (0, $ddaccca9a53aa58d$export$2e2bcd8739ae039)({\n            lineMode: isLineMode,\n            n3: isN3,\n            isImpliedBy: this._isImpliedBy\n        });\n        // Disable explicit quantifiers by default\n        this._explicitQuantifiers = !!options.explicitQuantifiers;\n    }\n    // ## Static class methods\n    // ### `_resetBlankNodePrefix` restarts blank node prefix identification\n    static _resetBlankNodePrefix() {\n        $bcb493474cb21cf3$var$blankNodePrefix = 0;\n    }\n    // ## Private methods\n    // ### `_setBase` sets the base IRI to resolve relative IRIs\n    _setBase(baseIRI) {\n        if (!baseIRI) {\n            this._base = '';\n            this._basePath = '';\n        } else {\n            // Remove fragment if present\n            const fragmentPos = baseIRI.indexOf('#');\n            if (fragmentPos >= 0) baseIRI = baseIRI.substr(0, fragmentPos);\n            // Set base IRI and its components\n            this._base = baseIRI;\n            this._basePath = baseIRI.indexOf('/') < 0 ? baseIRI : baseIRI.replace(/[^\\/?]*(?:\\?.*)?$/, '');\n            baseIRI = baseIRI.match(/^(?:([a-z][a-z0-9+.-]*:))?(?:\\/\\/[^\\/]*)?/i);\n            this._baseRoot = baseIRI[0];\n            this._baseScheme = baseIRI[1];\n        }\n    }\n    // ### `_saveContext` stores the current parsing context\n    // when entering a new scope (list, blank node, formula)\n    _saveContext(type, graph, subject, predicate, object) {\n        const n3Mode = this._n3Mode;\n        this._contextStack.push({\n            type: type,\n            subject: subject,\n            predicate: predicate,\n            object: object,\n            graph: graph,\n            inverse: n3Mode ? this._inversePredicate : false,\n            blankPrefix: n3Mode ? this._prefixes._ : '',\n            quantified: n3Mode ? this._quantified : null\n        });\n        // The settings below only apply to N3 streams\n        if (n3Mode) {\n            // Every new scope resets the predicate direction\n            this._inversePredicate = false;\n            // In N3, blank nodes are scoped to a formula\n            // (using a dot as separator, as a blank node label cannot start with it)\n            this._prefixes._ = this._graph ? `${this._graph.value}.` : '.';\n            // Quantifiers are scoped to a formula\n            this._quantified = Object.create(this._quantified);\n        }\n    }\n    // ### `_restoreContext` restores the parent context\n    // when leaving a scope (list, blank node, formula)\n    _restoreContext(type, token) {\n        // Obtain the previous context\n        const context = this._contextStack.pop();\n        if (!context || context.type !== type) return this._error(`Unexpected ${token.type}`, token);\n        // Restore the quad of the previous context\n        this._subject = context.subject;\n        this._predicate = context.predicate;\n        this._object = context.object;\n        this._graph = context.graph;\n        // Restore N3 context settings\n        if (this._n3Mode) {\n            this._inversePredicate = context.inverse;\n            this._prefixes._ = context.blankPrefix;\n            this._quantified = context.quantified;\n        }\n    }\n    // ### `_readInTopContext` reads a token when in the top context\n    _readInTopContext(token) {\n        switch(token.type){\n            // If an EOF token arrives in the top context, signal that we're done\n            case 'eof':\n                if (this._graph !== null) return this._error('Unclosed graph', token);\n                delete this._prefixes._;\n                return this._callback(null, null, this._prefixes);\n            // It could be a prefix declaration\n            case 'PREFIX':\n                this._sparqlStyle = true;\n            case '@prefix':\n                return this._readPrefix;\n            // It could be a base declaration\n            case 'BASE':\n                this._sparqlStyle = true;\n            case '@base':\n                return this._readBaseIRI;\n            // It could be a graph\n            case '{':\n                if (this._supportsNamedGraphs) {\n                    this._graph = '';\n                    this._subject = null;\n                    return this._readSubject;\n                }\n            case 'GRAPH':\n                if (this._supportsNamedGraphs) return this._readNamedGraphLabel;\n            // Otherwise, the next token must be a subject\n            default:\n                return this._readSubject(token);\n        }\n    }\n    // ### `_readEntity` reads an IRI, prefixed name, blank node, or variable\n    _readEntity(token, quantifier) {\n        let value;\n        switch(token.type){\n            // Read a relative or absolute IRI\n            case 'IRI':\n            case 'typeIRI':\n                const iri = this._resolveIRI(token.value);\n                if (iri === null) return this._error('Invalid IRI', token);\n                value = this._factory.namedNode(iri);\n                break;\n            // Read a prefixed name\n            case 'type':\n            case 'prefixed':\n                const prefix = this._prefixes[token.prefix];\n                if (prefix === undefined) return this._error(`Undefined prefix \"${token.prefix}:\"`, token);\n                value = this._factory.namedNode(prefix + token.value);\n                break;\n            // Read a blank node\n            case 'blank':\n                value = this._factory.blankNode(this._prefixes[token.prefix] + token.value);\n                break;\n            // Read a variable\n            case 'var':\n                value = this._factory.variable(token.value.substr(1));\n                break;\n            // Everything else is not an entity\n            default:\n                return this._error(`Expected entity but got ${token.type}`, token);\n        }\n        // In N3 mode, replace the entity if it is quantified\n        if (!quantifier && this._n3Mode && value.id in this._quantified) value = this._quantified[value.id];\n        return value;\n    }\n    // ### `_readSubject` reads a quad's subject\n    _readSubject(token) {\n        this._predicate = null;\n        switch(token.type){\n            case '[':\n                // Start a new quad with a new blank node as subject\n                this._saveContext('blank', this._graph, this._subject = this._factory.blankNode(), null, null);\n                return this._readBlankNodeHead;\n            case '(':\n                // Start a new list\n                this._saveContext('list', this._graph, this.RDF_NIL, null, null);\n                this._subject = null;\n                return this._readListItem;\n            case '{':\n                // Start a new formula\n                if (!this._n3Mode) return this._error('Unexpected graph', token);\n                this._saveContext('formula', this._graph, this._graph = this._factory.blankNode(), null, null);\n                return this._readSubject;\n            case '}':\n                // No subject; the graph in which we are reading is closed instead\n                return this._readPunctuation(token);\n            case '@forSome':\n                if (!this._n3Mode) return this._error('Unexpected \"@forSome\"', token);\n                this._subject = null;\n                this._predicate = this.N3_FORSOME;\n                this._quantifier = 'blankNode';\n                return this._readQuantifierList;\n            case '@forAll':\n                if (!this._n3Mode) return this._error('Unexpected \"@forAll\"', token);\n                this._subject = null;\n                this._predicate = this.N3_FORALL;\n                this._quantifier = 'variable';\n                return this._readQuantifierList;\n            case 'literal':\n                if (!this._n3Mode) return this._error('Unexpected literal', token);\n                if (token.prefix.length === 0) {\n                    this._literalValue = token.value;\n                    return this._completeSubjectLiteral;\n                } else this._subject = this._factory.literal(token.value, this._factory.namedNode(token.prefix));\n                break;\n            case '<<':\n                if (!this._supportsRDFStar) return this._error('Unexpected RDF-star syntax', token);\n                this._saveContext('<<', this._graph, null, null, null);\n                this._graph = null;\n                return this._readSubject;\n            default:\n                // Read the subject entity\n                if ((this._subject = this._readEntity(token)) === undefined) return;\n                // In N3 mode, the subject might be a path\n                if (this._n3Mode) return this._getPathReader(this._readPredicateOrNamedGraph);\n        }\n        // The next token must be a predicate,\n        // or, if the subject was actually a graph IRI, a named graph\n        return this._readPredicateOrNamedGraph;\n    }\n    // ### `_readPredicate` reads a quad's predicate\n    _readPredicate(token) {\n        const type = token.type;\n        switch(type){\n            case 'inverse':\n                this._inversePredicate = true;\n            case 'abbreviation':\n                this._predicate = this.ABBREVIATIONS[token.value];\n                break;\n            case '.':\n            case ']':\n            case '}':\n                // Expected predicate didn't come, must have been trailing semicolon\n                if (this._predicate === null) return this._error(`Unexpected ${type}`, token);\n                this._subject = null;\n                return type === ']' ? this._readBlankNodeTail(token) : this._readPunctuation(token);\n            case ';':\n                // Additional semicolons can be safely ignored\n                return this._predicate !== null ? this._readPredicate : this._error('Expected predicate but got ;', token);\n            case '[':\n                if (this._n3Mode) {\n                    // Start a new quad with a new blank node as subject\n                    this._saveContext('blank', this._graph, this._subject, this._subject = this._factory.blankNode(), null);\n                    return this._readBlankNodeHead;\n                }\n            case 'blank':\n                if (!this._n3Mode) return this._error('Disallowed blank node as predicate', token);\n            default:\n                if ((this._predicate = this._readEntity(token)) === undefined) return;\n        }\n        // The next token must be an object\n        return this._readObject;\n    }\n    // ### `_readObject` reads a quad's object\n    _readObject(token) {\n        switch(token.type){\n            case 'literal':\n                // Regular literal, can still get a datatype or language\n                if (token.prefix.length === 0) {\n                    this._literalValue = token.value;\n                    return this._readDataTypeOrLang;\n                } else this._object = this._factory.literal(token.value, this._factory.namedNode(token.prefix));\n                break;\n            case '[':\n                // Start a new quad with a new blank node as subject\n                this._saveContext('blank', this._graph, this._subject, this._predicate, this._subject = this._factory.blankNode());\n                return this._readBlankNodeHead;\n            case '(':\n                // Start a new list\n                this._saveContext('list', this._graph, this._subject, this._predicate, this.RDF_NIL);\n                this._subject = null;\n                return this._readListItem;\n            case '{':\n                // Start a new formula\n                if (!this._n3Mode) return this._error('Unexpected graph', token);\n                this._saveContext('formula', this._graph, this._subject, this._predicate, this._graph = this._factory.blankNode());\n                return this._readSubject;\n            case '<<':\n                if (!this._supportsRDFStar) return this._error('Unexpected RDF-star syntax', token);\n                this._saveContext('<<', this._graph, this._subject, this._predicate, null);\n                this._graph = null;\n                return this._readSubject;\n            default:\n                // Read the object entity\n                if ((this._object = this._readEntity(token)) === undefined) return;\n                // In N3 mode, the object might be a path\n                if (this._n3Mode) return this._getPathReader(this._getContextEndReader());\n        }\n        return this._getContextEndReader();\n    }\n    // ### `_readPredicateOrNamedGraph` reads a quad's predicate, or a named graph\n    _readPredicateOrNamedGraph(token) {\n        return token.type === '{' ? this._readGraph(token) : this._readPredicate(token);\n    }\n    // ### `_readGraph` reads a graph\n    _readGraph(token) {\n        if (token.type !== '{') return this._error(`Expected graph but got ${token.type}`, token);\n        // The \"subject\" we read is actually the GRAPH's label\n        this._graph = this._subject, this._subject = null;\n        return this._readSubject;\n    }\n    // ### `_readBlankNodeHead` reads the head of a blank node\n    _readBlankNodeHead(token) {\n        if (token.type === ']') {\n            this._subject = null;\n            return this._readBlankNodeTail(token);\n        } else {\n            this._predicate = null;\n            return this._readPredicate(token);\n        }\n    }\n    // ### `_readBlankNodeTail` reads the end of a blank node\n    _readBlankNodeTail(token) {\n        if (token.type !== ']') return this._readBlankNodePunctuation(token);\n        // Store blank node quad\n        if (this._subject !== null) this._emit(this._subject, this._predicate, this._object, this._graph);\n        // Restore the parent context containing this blank node\n        const empty = this._predicate === null;\n        this._restoreContext('blank', token);\n        // If the blank node was the object, restore previous context and read punctuation\n        if (this._object !== null) return this._getContextEndReader();\n        else if (this._predicate !== null) return this._readObject;\n        else // If the blank node was empty, it could be a named graph label\n        return empty ? this._readPredicateOrNamedGraph : this._readPredicateAfterBlank;\n    }\n    // ### `_readPredicateAfterBlank` reads a predicate after an anonymous blank node\n    _readPredicateAfterBlank(token) {\n        switch(token.type){\n            case '.':\n            case '}':\n                // No predicate is coming if the triple is terminated here\n                this._subject = null;\n                return this._readPunctuation(token);\n            default:\n                return this._readPredicate(token);\n        }\n    }\n    // ### `_readListItem` reads items from a list\n    _readListItem(token) {\n        let item = null, list = null, next = this._readListItem; // The next function to execute\n        const previousList = this._subject, stack = this._contextStack, parent = stack[stack.length - 1]; // The parent containing the current list\n        switch(token.type){\n            case '[':\n                // Stack the current list quad and start a new quad with a blank node as subject\n                this._saveContext('blank', this._graph, list = this._factory.blankNode(), this.RDF_FIRST, this._subject = item = this._factory.blankNode());\n                next = this._readBlankNodeHead;\n                break;\n            case '(':\n                // Stack the current list quad and start a new list\n                this._saveContext('list', this._graph, list = this._factory.blankNode(), this.RDF_FIRST, this.RDF_NIL);\n                this._subject = null;\n                break;\n            case ')':\n                // Closing the list; restore the parent context\n                this._restoreContext('list', token);\n                // If this list is contained within a parent list, return the membership quad here.\n                // This will be `<parent list element> rdf:first <this list>.`.\n                if (stack.length !== 0 && stack[stack.length - 1].type === 'list') this._emit(this._subject, this._predicate, this._object, this._graph);\n                // Was this list the parent's subject?\n                if (this._predicate === null) {\n                    // The next token is the predicate\n                    next = this._readPredicate;\n                    // No list tail if this was an empty list\n                    if (this._subject === this.RDF_NIL) return next;\n                } else {\n                    next = this._getContextEndReader();\n                    // No list tail if this was an empty list\n                    if (this._object === this.RDF_NIL) return next;\n                }\n                // Close the list by making the head nil\n                list = this.RDF_NIL;\n                break;\n            case 'literal':\n                // Regular literal, can still get a datatype or language\n                if (token.prefix.length === 0) {\n                    this._literalValue = token.value;\n                    next = this._readListItemDataTypeOrLang;\n                } else {\n                    item = this._factory.literal(token.value, this._factory.namedNode(token.prefix));\n                    next = this._getContextEndReader();\n                }\n                break;\n            case '{':\n                // Start a new formula\n                if (!this._n3Mode) return this._error('Unexpected graph', token);\n                this._saveContext('formula', this._graph, this._subject, this._predicate, this._graph = this._factory.blankNode());\n                return this._readSubject;\n            default:\n                if ((item = this._readEntity(token)) === undefined) return;\n        }\n        // Create a new blank node if no item head was assigned yet\n        if (list === null) this._subject = list = this._factory.blankNode();\n        // Is this the first element of the list?\n        if (previousList === null) {\n            // This list is either the subject or the object of its parent\n            if (parent.predicate === null) parent.subject = list;\n            else parent.object = list;\n        } else // Continue the previous list with the current list\n        this._emit(previousList, this.RDF_REST, list, this._graph);\n        // If an item was read, add it to the list\n        if (item !== null) {\n            // In N3 mode, the item might be a path\n            if (this._n3Mode && (token.type === 'IRI' || token.type === 'prefixed')) {\n                // Create a new context to add the item's path\n                this._saveContext('item', this._graph, list, this.RDF_FIRST, item);\n                this._subject = item, this._predicate = null;\n                // _readPath will restore the context and output the item\n                return this._getPathReader(this._readListItem);\n            }\n            // Output the item\n            this._emit(list, this.RDF_FIRST, item, this._graph);\n        }\n        return next;\n    }\n    // ### `_readDataTypeOrLang` reads an _optional_ datatype or language\n    _readDataTypeOrLang(token) {\n        return this._completeObjectLiteral(token, false);\n    }\n    // ### `_readListItemDataTypeOrLang` reads an _optional_ datatype or language in a list\n    _readListItemDataTypeOrLang(token) {\n        return this._completeObjectLiteral(token, true);\n    }\n    // ### `_completeLiteral` completes a literal with an optional datatype or language\n    _completeLiteral(token) {\n        // Create a simple string literal by default\n        let literal = this._factory.literal(this._literalValue);\n        switch(token.type){\n            // Create a datatyped literal\n            case 'type':\n            case 'typeIRI':\n                const datatype = this._readEntity(token);\n                if (datatype === undefined) return; // No datatype means an error occurred\n                literal = this._factory.literal(this._literalValue, datatype);\n                token = null;\n                break;\n            // Create a language-tagged string\n            case 'langcode':\n                literal = this._factory.literal(this._literalValue, token.value);\n                token = null;\n                break;\n        }\n        return {\n            token: token,\n            literal: literal\n        };\n    }\n    // Completes a literal in subject position\n    _completeSubjectLiteral(token) {\n        this._subject = this._completeLiteral(token).literal;\n        return this._readPredicateOrNamedGraph;\n    }\n    // Completes a literal in object position\n    _completeObjectLiteral(token, listItem) {\n        const completed = this._completeLiteral(token);\n        if (!completed) return;\n        this._object = completed.literal;\n        // If this literal was part of a list, write the item\n        // (we could also check the context stack, but passing in a flag is faster)\n        if (listItem) this._emit(this._subject, this.RDF_FIRST, this._object, this._graph);\n        // If the token was consumed, continue with the rest of the input\n        if (completed.token === null) return this._getContextEndReader();\n        else {\n            this._readCallback = this._getContextEndReader();\n            return this._readCallback(completed.token);\n        }\n    }\n    // ### `_readFormulaTail` reads the end of a formula\n    _readFormulaTail(token) {\n        if (token.type !== '}') return this._readPunctuation(token);\n        // Store the last quad of the formula\n        if (this._subject !== null) this._emit(this._subject, this._predicate, this._object, this._graph);\n        // Restore the parent context containing this formula\n        this._restoreContext('formula', token);\n        // If the formula was the subject, continue reading the predicate.\n        // If the formula was the object, read punctuation.\n        return this._object === null ? this._readPredicate : this._getContextEndReader();\n    }\n    // ### `_readPunctuation` reads punctuation between quads or quad parts\n    _readPunctuation(token) {\n        let next, graph = this._graph;\n        const subject = this._subject, inversePredicate = this._inversePredicate;\n        switch(token.type){\n            // A closing brace ends a graph\n            case '}':\n                if (this._graph === null) return this._error('Unexpected graph closing', token);\n                if (this._n3Mode) return this._readFormulaTail(token);\n                this._graph = null;\n            // A dot just ends the statement, without sharing anything with the next\n            case '.':\n                this._subject = null;\n                next = this._contextStack.length ? this._readSubject : this._readInTopContext;\n                if (inversePredicate) this._inversePredicate = false;\n                break;\n            // Semicolon means the subject is shared; predicate and object are different\n            case ';':\n                next = this._readPredicate;\n                break;\n            // Comma means both the subject and predicate are shared; the object is different\n            case ',':\n                next = this._readObject;\n                break;\n            // {| means that the current triple is annotated with predicate-object pairs.\n            case '{|':\n                if (!this._supportsRDFStar) return this._error('Unexpected RDF-star syntax', token);\n                // Continue using the last triple as quoted triple subject for the predicate-object pairs.\n                const predicate = this._predicate, object = this._object;\n                this._subject = this._factory.quad(subject, predicate, object, this.DEFAULTGRAPH);\n                next = this._readPredicate;\n                break;\n            // |} means that the current quoted triple in annotation syntax is finalized.\n            case '|}':\n                if (this._subject.termType !== 'Quad') return this._error('Unexpected asserted triple closing', token);\n                this._subject = null;\n                next = this._readPunctuation;\n                break;\n            default:\n                // An entity means this is a quad (only allowed if not already inside a graph)\n                if (this._supportsQuads && this._graph === null && (graph = this._readEntity(token)) !== undefined) {\n                    next = this._readQuadPunctuation;\n                    break;\n                }\n                return this._error(`Expected punctuation to follow \"${this._object.id}\"`, token);\n        }\n        // A quad has been completed now, so return it\n        if (subject !== null) {\n            const predicate = this._predicate, object = this._object;\n            if (!inversePredicate) this._emit(subject, predicate, object, graph);\n            else this._emit(object, predicate, subject, graph);\n        }\n        return next;\n    }\n    // ### `_readBlankNodePunctuation` reads punctuation in a blank node\n    _readBlankNodePunctuation(token) {\n        let next;\n        switch(token.type){\n            // Semicolon means the subject is shared; predicate and object are different\n            case ';':\n                next = this._readPredicate;\n                break;\n            // Comma means both the subject and predicate are shared; the object is different\n            case ',':\n                next = this._readObject;\n                break;\n            default:\n                return this._error(`Expected punctuation to follow \"${this._object.id}\"`, token);\n        }\n        // A quad has been completed now, so return it\n        this._emit(this._subject, this._predicate, this._object, this._graph);\n        return next;\n    }\n    // ### `_readQuadPunctuation` reads punctuation after a quad\n    _readQuadPunctuation(token) {\n        if (token.type !== '.') return this._error('Expected dot to follow quad', token);\n        return this._readInTopContext;\n    }\n    // ### `_readPrefix` reads the prefix of a prefix declaration\n    _readPrefix(token) {\n        if (token.type !== 'prefix') return this._error('Expected prefix to follow @prefix', token);\n        this._prefix = token.value;\n        return this._readPrefixIRI;\n    }\n    // ### `_readPrefixIRI` reads the IRI of a prefix declaration\n    _readPrefixIRI(token) {\n        if (token.type !== 'IRI') return this._error(`Expected IRI to follow prefix \"${this._prefix}:\"`, token);\n        const prefixNode = this._readEntity(token);\n        this._prefixes[this._prefix] = prefixNode.value;\n        this._prefixCallback(this._prefix, prefixNode);\n        return this._readDeclarationPunctuation;\n    }\n    // ### `_readBaseIRI` reads the IRI of a base declaration\n    _readBaseIRI(token) {\n        const iri = token.type === 'IRI' && this._resolveIRI(token.value);\n        if (!iri) return this._error('Expected valid IRI to follow base declaration', token);\n        this._setBase(iri);\n        return this._readDeclarationPunctuation;\n    }\n    // ### `_readNamedGraphLabel` reads the label of a named graph\n    _readNamedGraphLabel(token) {\n        switch(token.type){\n            case 'IRI':\n            case 'blank':\n            case 'prefixed':\n                return this._readSubject(token), this._readGraph;\n            case '[':\n                return this._readNamedGraphBlankLabel;\n            default:\n                return this._error('Invalid graph label', token);\n        }\n    }\n    // ### `_readNamedGraphLabel` reads a blank node label of a named graph\n    _readNamedGraphBlankLabel(token) {\n        if (token.type !== ']') return this._error('Invalid graph label', token);\n        this._subject = this._factory.blankNode();\n        return this._readGraph;\n    }\n    // ### `_readDeclarationPunctuation` reads the punctuation of a declaration\n    _readDeclarationPunctuation(token) {\n        // SPARQL-style declarations don't have punctuation\n        if (this._sparqlStyle) {\n            this._sparqlStyle = false;\n            return this._readInTopContext(token);\n        }\n        if (token.type !== '.') return this._error('Expected declaration to end with a dot', token);\n        return this._readInTopContext;\n    }\n    // Reads a list of quantified symbols from a @forSome or @forAll statement\n    _readQuantifierList(token) {\n        let entity;\n        switch(token.type){\n            case 'IRI':\n            case 'prefixed':\n                if ((entity = this._readEntity(token, true)) !== undefined) break;\n            default:\n                return this._error(`Unexpected ${token.type}`, token);\n        }\n        // Without explicit quantifiers, map entities to a quantified entity\n        if (!this._explicitQuantifiers) this._quantified[entity.id] = this._factory[this._quantifier](this._factory.blankNode().value);\n        else {\n            // If this is the first item, start a new quantifier list\n            if (this._subject === null) this._emit(this._graph || this.DEFAULTGRAPH, this._predicate, this._subject = this._factory.blankNode(), this.QUANTIFIERS_GRAPH);\n            else this._emit(this._subject, this.RDF_REST, this._subject = this._factory.blankNode(), this.QUANTIFIERS_GRAPH);\n            // Output the list item\n            this._emit(this._subject, this.RDF_FIRST, entity, this.QUANTIFIERS_GRAPH);\n        }\n        return this._readQuantifierPunctuation;\n    }\n    // Reads punctuation from a @forSome or @forAll statement\n    _readQuantifierPunctuation(token) {\n        // Read more quantifiers\n        if (token.type === ',') return this._readQuantifierList;\n        else {\n            // With explicit quantifiers, close the quantifier list\n            if (this._explicitQuantifiers) {\n                this._emit(this._subject, this.RDF_REST, this.RDF_NIL, this.QUANTIFIERS_GRAPH);\n                this._subject = null;\n            }\n            // Read a dot\n            this._readCallback = this._getContextEndReader();\n            return this._readCallback(token);\n        }\n    }\n    // ### `_getPathReader` reads a potential path and then resumes with the given function\n    _getPathReader(afterPath) {\n        this._afterPath = afterPath;\n        return this._readPath;\n    }\n    // ### `_readPath` reads a potential path\n    _readPath(token) {\n        switch(token.type){\n            // Forward path\n            case '!':\n                return this._readForwardPath;\n            // Backward path\n            case '^':\n                return this._readBackwardPath;\n            // Not a path; resume reading where we left off\n            default:\n                const stack = this._contextStack, parent = stack.length && stack[stack.length - 1];\n                // If we were reading a list item, we still need to output it\n                if (parent && parent.type === 'item') {\n                    // The list item is the remaining subejct after reading the path\n                    const item = this._subject;\n                    // Switch back to the context of the list\n                    this._restoreContext('item', token);\n                    // Output the list item\n                    this._emit(this._subject, this.RDF_FIRST, item, this._graph);\n                }\n                return this._afterPath(token);\n        }\n    }\n    // ### `_readForwardPath` reads a '!' path\n    _readForwardPath(token) {\n        let subject, predicate;\n        const object = this._factory.blankNode();\n        // The next token is the predicate\n        if ((predicate = this._readEntity(token)) === undefined) return;\n        // If we were reading a subject, replace the subject by the path's object\n        if (this._predicate === null) subject = this._subject, this._subject = object;\n        else subject = this._object, this._object = object;\n        // Emit the path's current quad and read its next section\n        this._emit(subject, predicate, object, this._graph);\n        return this._readPath;\n    }\n    // ### `_readBackwardPath` reads a '^' path\n    _readBackwardPath(token) {\n        const subject = this._factory.blankNode();\n        let predicate, object;\n        // The next token is the predicate\n        if ((predicate = this._readEntity(token)) === undefined) return;\n        // If we were reading a subject, replace the subject by the path's subject\n        if (this._predicate === null) object = this._subject, this._subject = subject;\n        else object = this._object, this._object = subject;\n        // Emit the path's current quad and read its next section\n        this._emit(subject, predicate, object, this._graph);\n        return this._readPath;\n    }\n    // ### `_readRDFStarTailOrGraph` reads the graph of a nested RDF-star quad or the end of a nested RDF-star triple\n    _readRDFStarTailOrGraph(token) {\n        if (token.type !== '>>') {\n            // An entity means this is a quad (only allowed if not already inside a graph)\n            if (this._supportsQuads && this._graph === null && (this._graph = this._readEntity(token)) !== undefined) return this._readRDFStarTail;\n            return this._error(`Expected >> to follow \"${this._object.id}\"`, token);\n        }\n        return this._readRDFStarTail(token);\n    }\n    // ### `_readRDFStarTail` reads the end of a nested RDF-star triple\n    _readRDFStarTail(token) {\n        if (token.type !== '>>') return this._error(`Expected >> but got ${token.type}`, token);\n        // Read the quad and restore the previous context\n        const quad = this._factory.quad(this._subject, this._predicate, this._object, this._graph || this.DEFAULTGRAPH);\n        this._restoreContext('<<', token);\n        // If the triple was the subject, continue by reading the predicate.\n        if (this._subject === null) {\n            this._subject = quad;\n            return this._readPredicate;\n        } else {\n            this._object = quad;\n            return this._getContextEndReader();\n        }\n    }\n    // ### `_getContextEndReader` gets the next reader function at the end of a context\n    _getContextEndReader() {\n        const contextStack = this._contextStack;\n        if (!contextStack.length) return this._readPunctuation;\n        switch(contextStack[contextStack.length - 1].type){\n            case 'blank':\n                return this._readBlankNodeTail;\n            case 'list':\n                return this._readListItem;\n            case 'formula':\n                return this._readFormulaTail;\n            case '<<':\n                return this._readRDFStarTailOrGraph;\n        }\n    }\n    // ### `_emit` sends a quad through the callback\n    _emit(subject, predicate, object, graph) {\n        this._callback(null, this._factory.quad(subject, predicate, object, graph || this.DEFAULTGRAPH));\n    }\n    // ### `_error` emits an error message through the callback\n    _error(message, token) {\n        const err = new Error(`${message} on line ${token.line}.`);\n        err.context = {\n            token: token,\n            line: token.line,\n            previousToken: this._lexer.previousToken\n        };\n        this._callback(err);\n        this._callback = $bcb493474cb21cf3$var$noop;\n    }\n    // ### `_resolveIRI` resolves an IRI against the base path\n    _resolveIRI(iri) {\n        return /^[a-z][a-z0-9+.-]*:/i.test(iri) ? iri : this._resolveRelativeIRI(iri);\n    }\n    // ### `_resolveRelativeIRI` resolves an IRI against the base path,\n    // assuming that a base path has been set and that the IRI is indeed relative\n    _resolveRelativeIRI(iri) {\n        // An empty relative IRI indicates the base IRI\n        if (!iri.length) return this._base;\n        // Decide resolving strategy based in the first character\n        switch(iri[0]){\n            // Resolve relative fragment IRIs against the base IRI\n            case '#':\n                return this._base + iri;\n            // Resolve relative query string IRIs by replacing the query string\n            case '?':\n                return this._base.replace(/(?:\\?.*)?$/, iri);\n            // Resolve root-relative IRIs at the root of the base IRI\n            case '/':\n                // Resolve scheme-relative IRIs to the scheme\n                return (iri[1] === '/' ? this._baseScheme : this._baseRoot) + this._removeDotSegments(iri);\n            // Resolve all other IRIs at the base IRI's path\n            default:\n                // Relative IRIs cannot contain a colon in the first path segment\n                return /^[^/:]*:/.test(iri) ? null : this._removeDotSegments(this._basePath + iri);\n        }\n    }\n    // ### `_removeDotSegments` resolves './' and '../' path segments in an IRI as per RFC3986\n    _removeDotSegments(iri) {\n        // Don't modify the IRI if it does not contain any dot segments\n        if (!/(^|\\/)\\.\\.?($|[/#?])/.test(iri)) return iri;\n        // Start with an imaginary slash before the IRI in order to resolve trailing './' and '../'\n        const length = iri.length;\n        let result = '', i = -1, pathStart = -1, segmentStart = 0, next = '/';\n        while(i < length){\n            switch(next){\n                // The path starts with the first slash after the authority\n                case ':':\n                    if (pathStart < 0) {\n                        // Skip two slashes before the authority\n                        if (iri[++i] === '/' && iri[++i] === '/') // Skip to slash after the authority\n                        while((pathStart = i + 1) < length && iri[pathStart] !== '/')i = pathStart;\n                    }\n                    break;\n                // Don't modify a query string or fragment\n                case '?':\n                case '#':\n                    i = length;\n                    break;\n                // Handle '/.' or '/..' path segments\n                case '/':\n                    if (iri[i + 1] === '.') {\n                        next = iri[++i + 1];\n                        switch(next){\n                            // Remove a '/.' segment\n                            case '/':\n                                result += iri.substring(segmentStart, i - 1);\n                                segmentStart = i + 1;\n                                break;\n                            // Remove a trailing '/.' segment\n                            case undefined:\n                            case '?':\n                            case '#':\n                                return result + iri.substring(segmentStart, i) + iri.substr(i + 1);\n                            // Remove a '/..' segment\n                            case '.':\n                                next = iri[++i + 1];\n                                if (next === undefined || next === '/' || next === '?' || next === '#') {\n                                    result += iri.substring(segmentStart, i - 2);\n                                    // Try to remove the parent path from result\n                                    if ((segmentStart = result.lastIndexOf('/')) >= pathStart) result = result.substr(0, segmentStart);\n                                    // Remove a trailing '/..' segment\n                                    if (next !== '/') return `${result}/${iri.substr(i + 1)}`;\n                                    segmentStart = i + 1;\n                                }\n                        }\n                    }\n            }\n            next = iri[++i];\n        }\n        return result + iri.substring(segmentStart);\n    }\n    // ## Public methods\n    // ### `parse` parses the N3 input and emits each parsed quad through the onQuad callback.\n    parse(input, quadCallback, prefixCallback) {\n        // The second parameter accepts an object { onQuad: ..., onPrefix: ..., onComment: ...}\n        // As a second and third parameter it still accepts a separate quadCallback and prefixCallback for backward compatibility as well\n        let onQuad, onPrefix, onComment;\n        if (quadCallback && (quadCallback.onQuad || quadCallback.onPrefix || quadCallback.onComment)) {\n            onQuad = quadCallback.onQuad;\n            onPrefix = quadCallback.onPrefix;\n            onComment = quadCallback.onComment;\n        } else {\n            onQuad = quadCallback;\n            onPrefix = prefixCallback;\n        }\n        // The read callback is the next function to be executed when a token arrives.\n        // We start reading in the top context.\n        this._readCallback = this._readInTopContext;\n        this._sparqlStyle = false;\n        this._prefixes = Object.create(null);\n        this._prefixes._ = this._blankNodePrefix ? this._blankNodePrefix.substr(2) : `b${$bcb493474cb21cf3$var$blankNodePrefix++}_`;\n        this._prefixCallback = onPrefix || $bcb493474cb21cf3$var$noop;\n        this._inversePredicate = false;\n        this._quantified = Object.create(null);\n        // Parse synchronously if no quad callback is given\n        if (!onQuad) {\n            const quads = [];\n            let error;\n            this._callback = (e, t)=>{\n                e ? error = e : t && quads.push(t);\n            };\n            this._lexer.tokenize(input).every((token)=>{\n                return this._readCallback = this._readCallback(token);\n            });\n            if (error) throw error;\n            return quads;\n        }\n        let processNextToken = (error, token)=>{\n            if (error !== null) this._callback(error), this._callback = $bcb493474cb21cf3$var$noop;\n            else if (this._readCallback) this._readCallback = this._readCallback(token);\n        };\n        // Enable checking for comments on every token when a commentCallback has been set\n        if (onComment) {\n            // Enable the lexer to return comments as tokens first (disabled by default)\n            this._lexer.comments = true;\n            // Patch the processNextToken function\n            processNextToken = (error, token)=>{\n                if (error !== null) this._callback(error), this._callback = $bcb493474cb21cf3$var$noop;\n                else if (this._readCallback) {\n                    if (token.type === 'comment') onComment(token.value);\n                    else this._readCallback = this._readCallback(token);\n                }\n            };\n        }\n        // Parse asynchronously otherwise, executing the read callback when a token arrives\n        this._callback = onQuad;\n        this._lexer.tokenize(input, processNextToken);\n    }\n}\n// The empty function\nfunction $bcb493474cb21cf3$var$noop() {}\n// Initializes the parser with the given data factory\nfunction $bcb493474cb21cf3$var$initDataFactory(parser, factory) {\n    parser._factory = factory;\n    parser.DEFAULTGRAPH = factory.defaultGraph();\n    // Set common named nodes\n    parser.RDF_FIRST = factory.namedNode((0, $09690bd0f6e8ba27$export$2e2bcd8739ae039).rdf.first);\n    parser.RDF_REST = factory.namedNode((0, $09690bd0f6e8ba27$export$2e2bcd8739ae039).rdf.rest);\n    parser.RDF_NIL = factory.namedNode((0, $09690bd0f6e8ba27$export$2e2bcd8739ae039).rdf.nil);\n    parser.N3_FORALL = factory.namedNode((0, $09690bd0f6e8ba27$export$2e2bcd8739ae039).r.forAll);\n    parser.N3_FORSOME = factory.namedNode((0, $09690bd0f6e8ba27$export$2e2bcd8739ae039).r.forSome);\n    parser.ABBREVIATIONS = {\n        'a': factory.namedNode((0, $09690bd0f6e8ba27$export$2e2bcd8739ae039).rdf.type),\n        '=': factory.namedNode((0, $09690bd0f6e8ba27$export$2e2bcd8739ae039).owl.sameAs),\n        '>': factory.namedNode((0, $09690bd0f6e8ba27$export$2e2bcd8739ae039).log.implies),\n        '<': factory.namedNode((0, $09690bd0f6e8ba27$export$2e2bcd8739ae039).log.isImpliedBy)\n    };\n    parser.QUANTIFIERS_GRAPH = factory.namedNode('urn:n3:quantifiers');\n}\n$bcb493474cb21cf3$var$initDataFactory($bcb493474cb21cf3$export$2e2bcd8739ae039.prototype, (0, $7b385df8cba0e42c$export$2e2bcd8739ae039));\n\n\n// **N3Writer** writes N3 documents.\n\n\nvar $d6cb6627f0e6b6dd$exports = {};\n\n$parcel$export($d6cb6627f0e6b6dd$exports, \"isNamedNode\", () => $d6cb6627f0e6b6dd$export$10490ce738f72284);\n$parcel$export($d6cb6627f0e6b6dd$exports, \"isBlankNode\", () => $d6cb6627f0e6b6dd$export$7b5b4967656acaac);\n$parcel$export($d6cb6627f0e6b6dd$exports, \"isLiteral\", () => $d6cb6627f0e6b6dd$export$899158ea22bb4609);\n$parcel$export($d6cb6627f0e6b6dd$exports, \"isVariable\", () => $d6cb6627f0e6b6dd$export$670a0c046e2ed227);\n$parcel$export($d6cb6627f0e6b6dd$exports, \"isDefaultGraph\", () => $d6cb6627f0e6b6dd$export$1a29e0fa6b36b0c8);\n$parcel$export($d6cb6627f0e6b6dd$exports, \"inDefaultGraph\", () => $d6cb6627f0e6b6dd$export$be8c4434e9c7c90b);\n$parcel$export($d6cb6627f0e6b6dd$exports, \"prefix\", () => $d6cb6627f0e6b6dd$export$82e9f45cca5ba907);\n$parcel$export($d6cb6627f0e6b6dd$exports, \"prefixes\", () => $d6cb6627f0e6b6dd$export$5d3c3f85c29a375);\n// **N3Util** provides N3 utility functions.\n\nfunction $d6cb6627f0e6b6dd$export$10490ce738f72284(term) {\n    return !!term && term.termType === 'NamedNode';\n}\nfunction $d6cb6627f0e6b6dd$export$7b5b4967656acaac(term) {\n    return !!term && term.termType === 'BlankNode';\n}\nfunction $d6cb6627f0e6b6dd$export$899158ea22bb4609(term) {\n    return !!term && term.termType === 'Literal';\n}\nfunction $d6cb6627f0e6b6dd$export$670a0c046e2ed227(term) {\n    return !!term && term.termType === 'Variable';\n}\nfunction $d6cb6627f0e6b6dd$export$1a29e0fa6b36b0c8(term) {\n    return !!term && term.termType === 'DefaultGraph';\n}\nfunction $d6cb6627f0e6b6dd$export$be8c4434e9c7c90b(quad) {\n    return $d6cb6627f0e6b6dd$export$1a29e0fa6b36b0c8(quad.graph);\n}\nfunction $d6cb6627f0e6b6dd$export$82e9f45cca5ba907(iri, factory) {\n    return $d6cb6627f0e6b6dd$export$5d3c3f85c29a375({\n        '': iri.value || iri\n    }, factory)('');\n}\nfunction $d6cb6627f0e6b6dd$export$5d3c3f85c29a375(defaultPrefixes, factory) {\n    // Add all of the default prefixes\n    const prefixes = Object.create(null);\n    for(const prefix in defaultPrefixes)processPrefix(prefix, defaultPrefixes[prefix]);\n    // Set the default factory if none was specified\n    factory = factory || (0, $7b385df8cba0e42c$export$2e2bcd8739ae039);\n    // Registers a new prefix (if an IRI was specified)\n    // or retrieves a function that expands an existing prefix (if no IRI was specified)\n    function processPrefix(prefix, iri) {\n        // Create a new prefix if an IRI is specified or the prefix doesn't exist\n        if (typeof iri === 'string') {\n            // Create a function that expands the prefix\n            const cache = Object.create(null);\n            prefixes[prefix] = (local)=>{\n                return cache[local] || (cache[local] = factory.namedNode(iri + local));\n            };\n        } else if (!(prefix in prefixes)) throw new Error(`Unknown prefix: ${prefix}`);\n        return prefixes[prefix];\n    }\n    return processPrefix;\n}\n\n\nfunction $a6348d508b0956c5$export$104ed90cc1a13451(regex) {\n    return regex.replace(/[\\]\\/\\(\\)\\*\\+\\?\\.\\\\\\$]/g, '\\\\$&');\n}\n\n\n// Do not handle base IRIs without scheme, and currently unsupported cases:\n// - file: IRIs (which could also use backslashes)\n// - IRIs containing /. or /.. or //\nconst $10447076e5190544$var$BASE_UNSUPPORTED = /^:?[^:?#]*(?:[?#]|$)|^file:|^[^:]*:\\/*[^?#]+?\\/(?:\\.\\.?(?:\\/|$)|\\/)/i;\nconst $10447076e5190544$var$SUFFIX_SUPPORTED = /^(?:(?:[^/?#]{3,}|\\.?[^/?#.]\\.?)(?:\\/[^/?#]{3,}|\\.?[^/?#.]\\.?)*\\/?)?(?:[?#]|$)/;\nconst $10447076e5190544$var$CURRENT = './';\nconst $10447076e5190544$var$PARENT = '../';\nconst $10447076e5190544$var$QUERY = '?';\nconst $10447076e5190544$var$FRAGMENT = '#';\nclass $10447076e5190544$export$2e2bcd8739ae039 {\n    constructor(base){\n        this.base = base;\n        this._baseLength = 0;\n        this._baseMatcher = null;\n        this._pathReplacements = new Array(base.length + 1);\n    }\n    static supports(base) {\n        return !$10447076e5190544$var$BASE_UNSUPPORTED.test(base);\n    }\n    _getBaseMatcher() {\n        if (this._baseMatcher) return this._baseMatcher;\n        if (!$10447076e5190544$export$2e2bcd8739ae039.supports(this.base)) return this._baseMatcher = /.^/;\n        // Extract the scheme\n        const scheme = /^[^:]*:\\/*/.exec(this.base)[0];\n        const regexHead = [\n            '^',\n            (0, $a6348d508b0956c5$export$104ed90cc1a13451)(scheme)\n        ];\n        const regexTail = [];\n        // Generate a regex for every path segment\n        const segments = [], segmenter = /[^/?#]*([/?#])/y;\n        let segment, query = 0, fragment = 0, last = segmenter.lastIndex = scheme.length;\n        while(!query && !fragment && (segment = segmenter.exec(this.base)))// Truncate base resolution path at fragment start\n        if (segment[1] === $10447076e5190544$var$FRAGMENT) fragment = segmenter.lastIndex - 1;\n        else {\n            // Create regex that matches the segment\n            regexHead.push((0, $a6348d508b0956c5$export$104ed90cc1a13451)(segment[0]), '(?:');\n            regexTail.push(')?');\n            // Create dedicated query string replacement\n            if (segment[1] !== $10447076e5190544$var$QUERY) segments.push(last = segmenter.lastIndex);\n            else {\n                query = last = segmenter.lastIndex;\n                fragment = this.base.indexOf($10447076e5190544$var$FRAGMENT, query);\n                this._pathReplacements[query] = $10447076e5190544$var$QUERY;\n            }\n        }\n        // Precalculate parent path substitutions\n        for(let i = 0; i < segments.length; i++)this._pathReplacements[segments[i]] = $10447076e5190544$var$PARENT.repeat(segments.length - i - 1);\n        this._pathReplacements[segments[segments.length - 1]] = $10447076e5190544$var$CURRENT;\n        // Add the remainder of the base IRI (without fragment) to the regex\n        this._baseLength = fragment > 0 ? fragment : this.base.length;\n        regexHead.push((0, $a6348d508b0956c5$export$104ed90cc1a13451)(this.base.substring(last, this._baseLength)), query ? '(?:#|$)' : '(?:[?#]|$)');\n        return this._baseMatcher = new RegExp([\n            ...regexHead,\n            ...regexTail\n        ].join(''));\n    }\n    toRelative(iri) {\n        // Unsupported or non-matching base IRI\n        const match = this._getBaseMatcher().exec(iri);\n        if (!match) return iri;\n        // Exact base IRI match\n        const length = match[0].length;\n        if (length === this._baseLength && length === iri.length) return '';\n        // Parent path match\n        const parentPath = this._pathReplacements[length];\n        if (parentPath) {\n            const suffix = iri.substring(length);\n            // Don't abbreviate unsupported path\n            if (parentPath !== $10447076e5190544$var$QUERY && !$10447076e5190544$var$SUFFIX_SUPPORTED.test(suffix)) return iri;\n            // Omit ./ with fragment or query string\n            if (parentPath === $10447076e5190544$var$CURRENT && /^[^?#]/.test(suffix)) return suffix;\n            // Append suffix to relative parent path\n            return parentPath + suffix;\n        }\n        // Fragment or query string, so include delimiter\n        return iri.substring(length - 1);\n    }\n}\n\n\n\nconst $33fd654882eefc25$var$DEFAULTGRAPH = (0, $7b385df8cba0e42c$export$2e2bcd8739ae039).defaultGraph();\nconst { rdf: $33fd654882eefc25$var$rdf, xsd: $33fd654882eefc25$var$xsd } = (0, $09690bd0f6e8ba27$export$2e2bcd8739ae039);\n// Characters in literals that require escaping\nconst $33fd654882eefc25$var$escape = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019\\ud800-\\udbff]/, $33fd654882eefc25$var$escapeAll = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019]|[\\ud800-\\udbff][\\udc00-\\udfff]/g, $33fd654882eefc25$var$escapedCharacters = {\n    '\\\\': '\\\\\\\\',\n    '\"': '\\\\\"',\n    '\\t': '\\\\t',\n    '\\n': '\\\\n',\n    '\\r': '\\\\r',\n    '\\b': '\\\\b',\n    '\\f': '\\\\f'\n};\n// ## Placeholder class to represent already pretty-printed terms\nclass $33fd654882eefc25$var$SerializedTerm extends (0, $7b385df8cba0e42c$export$656c1e606ad06131) {\n    // Pretty-printed nodes are not equal to any other node\n    // (e.g., [] does not equal [])\n    equals(other) {\n        return other === this;\n    }\n}\nclass $33fd654882eefc25$export$2e2bcd8739ae039 {\n    constructor(outputStream, options){\n        // ### `_prefixRegex` matches a prefixed name or IRI that begins with one of the added prefixes\n        this._prefixRegex = /$0^/;\n        // Shift arguments if the first argument is not a stream\n        if (outputStream && typeof outputStream.write !== 'function') options = outputStream, outputStream = null;\n        options = options || {};\n        this._lists = options.lists;\n        // If no output stream given, send the output as string through the end callback\n        if (!outputStream) {\n            let output = '';\n            this._outputStream = {\n                write (chunk, encoding, done) {\n                    output += chunk;\n                    done && done();\n                },\n                end: (done)=>{\n                    done && done(null, output);\n                }\n            };\n            this._endStream = true;\n        } else {\n            this._outputStream = outputStream;\n            this._endStream = options.end === undefined ? true : !!options.end;\n        }\n        // Initialize writer, depending on the format\n        this._subject = null;\n        if (!/triple|quad/i.test(options.format)) {\n            this._lineMode = false;\n            this._graph = $33fd654882eefc25$var$DEFAULTGRAPH;\n            this._prefixIRIs = Object.create(null);\n            options.prefixes && this.addPrefixes(options.prefixes);\n            if (options.baseIRI) this._baseIri = new (0, $10447076e5190544$export$2e2bcd8739ae039)(options.baseIRI);\n        } else {\n            this._lineMode = true;\n            this._writeQuad = this._writeQuadLine;\n        }\n    }\n    // ## Private methods\n    // ### Whether the current graph is the default graph\n    get _inDefaultGraph() {\n        return $33fd654882eefc25$var$DEFAULTGRAPH.equals(this._graph);\n    }\n    // ### `_write` writes the argument to the output stream\n    _write(string, callback) {\n        this._outputStream.write(string, 'utf8', callback);\n    }\n    // ### `_writeQuad` writes the quad to the output stream\n    _writeQuad(subject, predicate, object, graph, done) {\n        try {\n            // Write the graph's label if it has changed\n            if (!graph.equals(this._graph)) {\n                // Close the previous graph and start the new one\n                this._write((this._subject === null ? '' : this._inDefaultGraph ? '.\\n' : '\\n}\\n') + ($33fd654882eefc25$var$DEFAULTGRAPH.equals(graph) ? '' : `${this._encodeIriOrBlank(graph)} {\\n`));\n                this._graph = graph;\n                this._subject = null;\n            }\n            // Don't repeat the subject if it's the same\n            if (subject.equals(this._subject)) {\n                // Don't repeat the predicate if it's the same\n                if (predicate.equals(this._predicate)) this._write(`, ${this._encodeObject(object)}`, done);\n                else this._write(`;\\n    ${this._encodePredicate(this._predicate = predicate)} ${this._encodeObject(object)}`, done);\n            } else this._write(`${(this._subject === null ? '' : '.\\n') + this._encodeSubject(this._subject = subject)} ${this._encodePredicate(this._predicate = predicate)} ${this._encodeObject(object)}`, done);\n        } catch (error) {\n            done && done(error);\n        }\n    }\n    // ### `_writeQuadLine` writes the quad to the output stream as a single line\n    _writeQuadLine(subject, predicate, object, graph, done) {\n        // Write the quad without prefixes\n        delete this._prefixMatch;\n        this._write(this.quadToString(subject, predicate, object, graph), done);\n    }\n    // ### `quadToString` serializes a quad as a string\n    quadToString(subject, predicate, object, graph) {\n        return `${this._encodeSubject(subject)} ${this._encodeIriOrBlank(predicate)} ${this._encodeObject(object)}${graph && graph.value ? ` ${this._encodeIriOrBlank(graph)} .\\n` : ' .\\n'}`;\n    }\n    // ### `quadsToString` serializes an array of quads as a string\n    quadsToString(quads) {\n        let quadsString = '';\n        for (const quad of quads)quadsString += this.quadToString(quad.subject, quad.predicate, quad.object, quad.graph);\n        return quadsString;\n    }\n    // ### `_encodeSubject` represents a subject\n    _encodeSubject(entity) {\n        return entity.termType === 'Quad' ? this._encodeQuad(entity) : this._encodeIriOrBlank(entity);\n    }\n    // ### `_encodeIriOrBlank` represents an IRI or blank node\n    _encodeIriOrBlank(entity) {\n        // A blank node or list is represented as-is\n        if (entity.termType !== 'NamedNode') {\n            // If it is a list head, pretty-print it\n            if (this._lists && entity.value in this._lists) entity = this.list(this._lists[entity.value]);\n            return 'id' in entity ? entity.id : `_:${entity.value}`;\n        }\n        let iri = entity.value;\n        // Use relative IRIs if requested and possible\n        if (this._baseIri) iri = this._baseIri.toRelative(iri);\n        // Escape special characters\n        if ($33fd654882eefc25$var$escape.test(iri)) iri = iri.replace($33fd654882eefc25$var$escapeAll, $33fd654882eefc25$var$characterReplacer);\n        // Try to represent the IRI as prefixed name\n        const prefixMatch = this._prefixRegex.exec(iri);\n        return !prefixMatch ? `<${iri}>` : !prefixMatch[1] ? iri : this._prefixIRIs[prefixMatch[1]] + prefixMatch[2];\n    }\n    // ### `_encodeLiteral` represents a literal\n    _encodeLiteral(literal) {\n        // Escape special characters\n        let value = literal.value;\n        if ($33fd654882eefc25$var$escape.test(value)) value = value.replace($33fd654882eefc25$var$escapeAll, $33fd654882eefc25$var$characterReplacer);\n        // Write a language-tagged literal\n        if (literal.language) return `\"${value}\"@${literal.language}`;\n        // Write dedicated literals per data type\n        if (this._lineMode) {\n            // Only abbreviate strings in N-Triples or N-Quads\n            if (literal.datatype.value === $33fd654882eefc25$var$xsd.string) return `\"${value}\"`;\n        } else // Use common datatype abbreviations in Turtle or TriG\n        switch(literal.datatype.value){\n            case $33fd654882eefc25$var$xsd.string:\n                return `\"${value}\"`;\n            case $33fd654882eefc25$var$xsd.boolean:\n                if (value === 'true' || value === 'false') return value;\n                break;\n            case $33fd654882eefc25$var$xsd.integer:\n                if (/^[+-]?\\d+$/.test(value)) return value;\n                break;\n            case $33fd654882eefc25$var$xsd.decimal:\n                if (/^[+-]?\\d*\\.\\d+$/.test(value)) return value;\n                break;\n            case $33fd654882eefc25$var$xsd.double:\n                if (/^[+-]?(?:\\d+\\.\\d*|\\.?\\d+)[eE][+-]?\\d+$/.test(value)) return value;\n                break;\n        }\n        // Write a regular datatyped literal\n        return `\"${value}\"^^${this._encodeIriOrBlank(literal.datatype)}`;\n    }\n    // ### `_encodePredicate` represents a predicate\n    _encodePredicate(predicate) {\n        return predicate.value === $33fd654882eefc25$var$rdf.type ? 'a' : this._encodeIriOrBlank(predicate);\n    }\n    // ### `_encodeObject` represents an object\n    _encodeObject(object) {\n        switch(object.termType){\n            case 'Quad':\n                return this._encodeQuad(object);\n            case 'Literal':\n                return this._encodeLiteral(object);\n            default:\n                return this._encodeIriOrBlank(object);\n        }\n    }\n    // ### `_encodeQuad` encodes an RDF-star quad\n    _encodeQuad({ subject: subject, predicate: predicate, object: object, graph: graph }) {\n        return `<<${this._encodeSubject(subject)} ${this._encodePredicate(predicate)} ${this._encodeObject(object)}${(0, $d6cb6627f0e6b6dd$export$1a29e0fa6b36b0c8)(graph) ? '' : ` ${this._encodeIriOrBlank(graph)}`}>>`;\n    }\n    // ### `_blockedWrite` replaces `_write` after the writer has been closed\n    _blockedWrite() {\n        throw new Error('Cannot write because the writer has been closed.');\n    }\n    // ### `addQuad` adds the quad to the output stream\n    addQuad(subject, predicate, object, graph, done) {\n        // The quad was given as an object, so shift parameters\n        if (object === undefined) this._writeQuad(subject.subject, subject.predicate, subject.object, subject.graph, predicate);\n        else if (typeof graph === 'function') this._writeQuad(subject, predicate, object, $33fd654882eefc25$var$DEFAULTGRAPH, graph);\n        else this._writeQuad(subject, predicate, object, graph || $33fd654882eefc25$var$DEFAULTGRAPH, done);\n    }\n    // ### `addQuads` adds the quads to the output stream\n    addQuads(quads) {\n        for(let i = 0; i < quads.length; i++)this.addQuad(quads[i]);\n    }\n    // ### `addPrefix` adds the prefix to the output stream\n    addPrefix(prefix, iri, done) {\n        const prefixes = {};\n        prefixes[prefix] = iri;\n        this.addPrefixes(prefixes, done);\n    }\n    // ### `addPrefixes` adds the prefixes to the output stream\n    addPrefixes(prefixes, done) {\n        // Ignore prefixes if not supported by the serialization\n        if (!this._prefixIRIs) return done && done();\n        // Write all new prefixes\n        let hasPrefixes = false;\n        for(let prefix in prefixes){\n            let iri = prefixes[prefix];\n            if (typeof iri !== 'string') iri = iri.value;\n            hasPrefixes = true;\n            // Finish a possible pending quad\n            if (this._subject !== null) {\n                this._write(this._inDefaultGraph ? '.\\n' : '\\n}\\n');\n                this._subject = null, this._graph = '';\n            }\n            // Store and write the prefix\n            this._prefixIRIs[iri] = prefix += ':';\n            this._write(`@prefix ${prefix} <${iri}>.\\n`);\n        }\n        // Recreate the prefix matcher\n        if (hasPrefixes) {\n            let IRIlist = '', prefixList = '';\n            for(const prefixIRI in this._prefixIRIs){\n                IRIlist += IRIlist ? `|${prefixIRI}` : prefixIRI;\n                prefixList += (prefixList ? '|' : '') + this._prefixIRIs[prefixIRI];\n            }\n            IRIlist = (0, $a6348d508b0956c5$export$104ed90cc1a13451)(IRIlist, /[\\]\\/\\(\\)\\*\\+\\?\\.\\\\\\$]/g, '\\\\$&');\n            this._prefixRegex = new RegExp(`^(?:${prefixList})[^\\/]*$|` + `^(${IRIlist})([_a-zA-Z0-9][\\\\-_a-zA-Z0-9]*)$`);\n        }\n        // End a prefix block with a newline\n        this._write(hasPrefixes ? '\\n' : '', done);\n    }\n    // ### `blank` creates a blank node with the given content\n    blank(predicate, object) {\n        let children = predicate, child, length;\n        // Empty blank node\n        if (predicate === undefined) children = [];\n        else if (predicate.termType) children = [\n            {\n                predicate: predicate,\n                object: object\n            }\n        ];\n        else if (!('length' in predicate)) children = [\n            predicate\n        ];\n        switch(length = children.length){\n            // Generate an empty blank node\n            case 0:\n                return new $33fd654882eefc25$var$SerializedTerm('[]');\n            // Generate a non-nested one-triple blank node\n            case 1:\n                child = children[0];\n                if (!(child.object instanceof $33fd654882eefc25$var$SerializedTerm)) return new $33fd654882eefc25$var$SerializedTerm(`[ ${this._encodePredicate(child.predicate)} ${this._encodeObject(child.object)} ]`);\n            // Generate a multi-triple or nested blank node\n            default:\n                let contents = '[';\n                // Write all triples in order\n                for(let i = 0; i < length; i++){\n                    child = children[i];\n                    // Write only the object is the predicate is the same as the previous\n                    if (child.predicate.equals(predicate)) contents += `, ${this._encodeObject(child.object)}`;\n                    else {\n                        contents += `${(i ? ';\\n  ' : '\\n  ') + this._encodePredicate(child.predicate)} ${this._encodeObject(child.object)}`;\n                        predicate = child.predicate;\n                    }\n                }\n                return new $33fd654882eefc25$var$SerializedTerm(`${contents}\\n]`);\n        }\n    }\n    // ### `list` creates a list node with the given content\n    list(elements) {\n        const length = elements && elements.length || 0, contents = new Array(length);\n        for(let i = 0; i < length; i++)contents[i] = this._encodeObject(elements[i]);\n        return new $33fd654882eefc25$var$SerializedTerm(`(${contents.join(' ')})`);\n    }\n    // ### `end` signals the end of the output stream\n    end(done) {\n        // Finish a possible pending quad\n        if (this._subject !== null) {\n            this._write(this._inDefaultGraph ? '.\\n' : '\\n}\\n');\n            this._subject = null;\n        }\n        // Disallow further writing\n        this._write = this._blockedWrite;\n        // Try to end the underlying stream, ensuring done is called exactly one time\n        let singleDone = done && ((error, result)=>{\n            singleDone = null, done(error, result);\n        });\n        if (this._endStream) try {\n            return this._outputStream.end(singleDone);\n        } catch (error) {}\n        singleDone && singleDone();\n    }\n}\n// Replaces a character by its escaped version\nfunction $33fd654882eefc25$var$characterReplacer(character) {\n    // Replace a single character by its escaped version\n    let result = $33fd654882eefc25$var$escapedCharacters[character];\n    if (result === undefined) {\n        // Replace a single character with its 4-bit unicode escape sequence\n        if (character.length === 1) {\n            result = character.charCodeAt(0).toString(16);\n            result = '\\\\u0000'.substr(0, 6 - result.length) + result;\n        } else {\n            result = ((character.charCodeAt(0) - 0xD800) * 0x400 + character.charCodeAt(1) + 0x2400).toString(16);\n            result = '\\\\U00000000'.substr(0, 10 - result.length) + result;\n        }\n    }\n    return result;\n}\n\n\n// **N3Store** objects store N3 quads by graph in memory.\nvar $3450dab365fe3575$exports = {};\n'use strict';\nvar $ec1bbd7296755677$exports = {};\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n'use strict';\n\nvar $N0o3H = parcelRequire(\"N0o3H\");\nvar $ec1bbd7296755677$require$Buffer = $N0o3H.Buffer;\n\nvar $1by5F = parcelRequire(\"1by5F\");\nvar $ec1bbd7296755677$require$ObjectDefineProperty = $1by5F.ObjectDefineProperty;\nvar $ec1bbd7296755677$require$ObjectKeys = $1by5F.ObjectKeys;\nvar $ec1bbd7296755677$require$ReflectApply = $1by5F.ReflectApply;\n\nvar $kDFyU = parcelRequire(\"kDFyU\");\nconst { promisify: { custom: $ec1bbd7296755677$var$customPromisify } } = $kDFyU;\nvar $4696c9d5bd46ecd2$export$42af8c323be37587;\nvar $4696c9d5bd46ecd2$export$f405f72c701dad87;\n'use strict';\n\nconst $4696c9d5bd46ecd2$var$AbortController = globalThis.AbortController || (parcelRequire(\"5zWM9\")).AbortController;\n\nvar $7ynhX = parcelRequire(\"7ynhX\");\nconst { codes: { ERR_INVALID_ARG_VALUE: $4696c9d5bd46ecd2$var$ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE: $4696c9d5bd46ecd2$var$ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS: $4696c9d5bd46ecd2$var$ERR_MISSING_ARGS, ERR_OUT_OF_RANGE: $4696c9d5bd46ecd2$var$ERR_OUT_OF_RANGE }, AbortError: $4696c9d5bd46ecd2$var$AbortError } = $7ynhX;\n\nvar $geuoF = parcelRequire(\"geuoF\");\nvar $4696c9d5bd46ecd2$require$validateAbortSignal = $geuoF.validateAbortSignal;\nvar $4696c9d5bd46ecd2$require$validateInteger = $geuoF.validateInteger;\nvar $4696c9d5bd46ecd2$require$validateObject = $geuoF.validateObject;\n\nconst $4696c9d5bd46ecd2$var$kWeakHandler = (parcelRequire(\"1by5F\")).Symbol('kWeak');\n\nconst $4696c9d5bd46ecd2$var$kResistStopPropagation = (parcelRequire(\"1by5F\")).Symbol('kResistStopPropagation');\n\nvar $9RUbc = parcelRequire(\"9RUbc\");\nvar $4696c9d5bd46ecd2$require$finished = $9RUbc.finished;\nvar $d16ccf556459ec6a$exports = {};\n'use strict';\nvar $5501b248b6c40ce0$exports = {};\n/* replacement start */ \nvar $ibaza = parcelRequire(\"ibaza\");\n'use strict';\n\nvar $1by5F = parcelRequire(\"1by5F\");\nvar $5501b248b6c40ce0$require$ArrayIsArray = $1by5F.ArrayIsArray;\nvar $5501b248b6c40ce0$require$Promise = $1by5F.Promise;\nvar $5501b248b6c40ce0$require$SymbolAsyncIterator = $1by5F.SymbolAsyncIterator;\nvar $5501b248b6c40ce0$require$SymbolDispose = $1by5F.SymbolDispose;\n\nvar $9RUbc = parcelRequire(\"9RUbc\");\n\nvar $5501b248b6c40ce0$require$once = (parcelRequire(\"kDFyU\")).once;\n\nvar $7CELW = parcelRequire(\"7CELW\");\n\nvar $lyuEd = parcelRequire(\"lyuEd\");\n\nvar $7ynhX = parcelRequire(\"7ynhX\");\nconst { aggregateTwoErrors: $5501b248b6c40ce0$var$aggregateTwoErrors, codes: { ERR_INVALID_ARG_TYPE: $5501b248b6c40ce0$var$ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE: $5501b248b6c40ce0$var$ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS: $5501b248b6c40ce0$var$ERR_MISSING_ARGS, ERR_STREAM_DESTROYED: $5501b248b6c40ce0$var$ERR_STREAM_DESTROYED, ERR_STREAM_PREMATURE_CLOSE: $5501b248b6c40ce0$var$ERR_STREAM_PREMATURE_CLOSE }, AbortError: $5501b248b6c40ce0$var$AbortError } = $7ynhX;\n\nvar $geuoF = parcelRequire(\"geuoF\");\nvar $5501b248b6c40ce0$require$validateFunction = $geuoF.validateFunction;\nvar $5501b248b6c40ce0$require$validateAbortSignal = $geuoF.validateAbortSignal;\n\nvar $eY1Gs = parcelRequire(\"eY1Gs\");\nvar $5501b248b6c40ce0$require$isIterable = $eY1Gs.isIterable;\nvar $5501b248b6c40ce0$require$isReadable = $eY1Gs.isReadable;\nvar $5501b248b6c40ce0$require$isReadableNodeStream = $eY1Gs.isReadableNodeStream;\nvar $5501b248b6c40ce0$require$isNodeStream = $eY1Gs.isNodeStream;\nvar $5501b248b6c40ce0$require$isTransformStream = $eY1Gs.isTransformStream;\nvar $5501b248b6c40ce0$require$isWebStream = $eY1Gs.isWebStream;\nvar $5501b248b6c40ce0$require$isReadableStream = $eY1Gs.isReadableStream;\nvar $5501b248b6c40ce0$require$isReadableFinished = $eY1Gs.isReadableFinished;\n\nconst $5501b248b6c40ce0$var$AbortController = globalThis.AbortController || (parcelRequire(\"5zWM9\")).AbortController;\nlet $5501b248b6c40ce0$var$PassThrough;\nlet $5501b248b6c40ce0$var$Readable;\nlet $5501b248b6c40ce0$var$addAbortListener;\nfunction $5501b248b6c40ce0$var$destroyer(stream, reading, writing) {\n    let finished = false;\n    stream.on('close', ()=>{\n        finished = true;\n    });\n    const cleanup = $9RUbc(stream, {\n        readable: reading,\n        writable: writing\n    }, (err)=>{\n        finished = !err;\n    });\n    return {\n        destroy: (err)=>{\n            if (finished) return;\n            finished = true;\n            $7CELW.destroyer(stream, err || new $5501b248b6c40ce0$var$ERR_STREAM_DESTROYED('pipe'));\n        },\n        cleanup: cleanup\n    };\n}\nfunction $5501b248b6c40ce0$var$popCallback(streams) {\n    // Streams should never be an empty array. It should always contain at least\n    // a single stream. Therefore optimize for the average case instead of\n    // checking for length === 0 as well.\n    $5501b248b6c40ce0$require$validateFunction(streams[streams.length - 1], 'streams[stream.length - 1]');\n    return streams.pop();\n}\nfunction $5501b248b6c40ce0$var$makeAsyncIterable(val) {\n    if ($5501b248b6c40ce0$require$isIterable(val)) return val;\n    else if ($5501b248b6c40ce0$require$isReadableNodeStream(val)) // Legacy streams are not Iterable.\n    return $5501b248b6c40ce0$var$fromReadable(val);\n    throw new $5501b248b6c40ce0$var$ERR_INVALID_ARG_TYPE('val', [\n        'Readable',\n        'Iterable',\n        'AsyncIterable'\n    ], val);\n}\n\nasync function* $5501b248b6c40ce0$var$fromReadable(val) {\n    if (!$5501b248b6c40ce0$var$Readable) $5501b248b6c40ce0$var$Readable = (parcelRequire(\"c6GJA\"));\n    yield* $5501b248b6c40ce0$var$Readable.prototype[$5501b248b6c40ce0$require$SymbolAsyncIterator].call(val);\n}\nasync function $5501b248b6c40ce0$var$pumpToNode(iterable, writable, finish, { end: end }) {\n    let error;\n    let onresolve = null;\n    const resume = (err)=>{\n        if (err) error = err;\n        if (onresolve) {\n            const callback = onresolve;\n            onresolve = null;\n            callback();\n        }\n    };\n    const wait = ()=>new $5501b248b6c40ce0$require$Promise((resolve, reject)=>{\n            if (error) reject(error);\n            else onresolve = ()=>{\n                if (error) reject(error);\n                else resolve();\n            };\n        });\n    writable.on('drain', resume);\n    const cleanup = $9RUbc(writable, {\n        readable: false\n    }, resume);\n    try {\n        if (writable.writableNeedDrain) await wait();\n        for await (const chunk of iterable)if (!writable.write(chunk)) await wait();\n        if (end) {\n            writable.end();\n            await wait();\n        }\n        finish();\n    } catch (err) {\n        finish(error !== err ? $5501b248b6c40ce0$var$aggregateTwoErrors(error, err) : err);\n    } finally{\n        cleanup();\n        writable.off('drain', resume);\n    }\n}\nasync function $5501b248b6c40ce0$var$pumpToWeb(readable, writable, finish, { end: end }) {\n    if ($5501b248b6c40ce0$require$isTransformStream(writable)) writable = writable.writable;\n    // https://streams.spec.whatwg.org/#example-manual-write-with-backpressure\n    const writer = writable.getWriter();\n    try {\n        for await (const chunk of readable){\n            await writer.ready;\n            writer.write(chunk).catch(()=>{});\n        }\n        await writer.ready;\n        if (end) await writer.close();\n        finish();\n    } catch (err) {\n        try {\n            await writer.abort(err);\n            finish(err);\n        } catch (err) {\n            finish(err);\n        }\n    }\n}\nfunction $5501b248b6c40ce0$var$pipeline(...streams) {\n    return $5501b248b6c40ce0$var$pipelineImpl(streams, $5501b248b6c40ce0$require$once($5501b248b6c40ce0$var$popCallback(streams)));\n}\n\n\nfunction $5501b248b6c40ce0$var$pipelineImpl(streams, callback, opts) {\n    if (streams.length === 1 && $5501b248b6c40ce0$require$ArrayIsArray(streams[0])) streams = streams[0];\n    if (streams.length < 2) throw new $5501b248b6c40ce0$var$ERR_MISSING_ARGS('streams');\n    const ac = new $5501b248b6c40ce0$var$AbortController();\n    const signal = ac.signal;\n    const outerSignal = opts === null || opts === undefined ? undefined : opts.signal;\n    // Need to cleanup event listeners if last stream is readable\n    // https://github.com/nodejs/node/issues/35452\n    const lastStreamCleanup = [];\n    $5501b248b6c40ce0$require$validateAbortSignal(outerSignal, 'options.signal');\n    function abort() {\n        finishImpl(new $5501b248b6c40ce0$var$AbortError());\n    }\n    $5501b248b6c40ce0$var$addAbortListener = $5501b248b6c40ce0$var$addAbortListener || (parcelRequire(\"kDFyU\")).addAbortListener;\n    let disposable;\n    if (outerSignal) disposable = $5501b248b6c40ce0$var$addAbortListener(outerSignal, abort);\n    let error;\n    let value;\n    const destroys = [];\n    let finishCount = 0;\n    function finish(err) {\n        finishImpl(err, --finishCount === 0);\n    }\n    function finishImpl(err, final) {\n        var _disposable;\n        if (err && (!error || error.code === 'ERR_STREAM_PREMATURE_CLOSE')) error = err;\n        if (!error && !final) return;\n        while(destroys.length)destroys.shift()(error);\n        (_disposable = disposable) === null || _disposable === undefined ? undefined : _disposable[$5501b248b6c40ce0$require$SymbolDispose]();\n        ac.abort();\n        if (final) {\n            if (!error) lastStreamCleanup.forEach((fn)=>fn());\n            $ibaza.nextTick(callback, error, value);\n        }\n    }\n    let ret;\n    for(let i = 0; i < streams.length; i++){\n        const stream = streams[i];\n        const reading = i < streams.length - 1;\n        const writing = i > 0;\n        const end = reading || (opts === null || opts === undefined ? undefined : opts.end) !== false;\n        const isLastStream = i === streams.length - 1;\n        if ($5501b248b6c40ce0$require$isNodeStream(stream)) {\n            if (end) {\n                const { destroy: destroy, cleanup: cleanup } = $5501b248b6c40ce0$var$destroyer(stream, reading, writing);\n                destroys.push(destroy);\n                if ($5501b248b6c40ce0$require$isReadable(stream) && isLastStream) lastStreamCleanup.push(cleanup);\n            }\n            // Catch stream errors that occur after pipe/pump has completed.\n            function onError(err) {\n                if (err && err.name !== 'AbortError' && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') finish(err);\n            }\n            stream.on('error', onError);\n            if ($5501b248b6c40ce0$require$isReadable(stream) && isLastStream) lastStreamCleanup.push(()=>{\n                stream.removeListener('error', onError);\n            });\n        }\n        if (i === 0) {\n            if (typeof stream === 'function') {\n                ret = stream({\n                    signal: signal\n                });\n                if (!$5501b248b6c40ce0$require$isIterable(ret)) throw new $5501b248b6c40ce0$var$ERR_INVALID_RETURN_VALUE('Iterable, AsyncIterable or Stream', 'source', ret);\n            } else if ($5501b248b6c40ce0$require$isIterable(stream) || $5501b248b6c40ce0$require$isReadableNodeStream(stream) || $5501b248b6c40ce0$require$isTransformStream(stream)) ret = stream;\n            else ret = $lyuEd.from(stream);\n        } else if (typeof stream === 'function') {\n            if ($5501b248b6c40ce0$require$isTransformStream(ret)) {\n                var _ret;\n                ret = $5501b248b6c40ce0$var$makeAsyncIterable((_ret = ret) === null || _ret === undefined ? undefined : _ret.readable);\n            } else ret = $5501b248b6c40ce0$var$makeAsyncIterable(ret);\n            ret = stream(ret, {\n                signal: signal\n            });\n            if (reading) {\n                if (!$5501b248b6c40ce0$require$isIterable(ret, true)) throw new $5501b248b6c40ce0$var$ERR_INVALID_RETURN_VALUE('AsyncIterable', `transform[${i - 1}]`, ret);\n            } else {\n                var _ret2;\n                if (!$5501b248b6c40ce0$var$PassThrough) $5501b248b6c40ce0$var$PassThrough = (parcelRequire(\"kFz2c\"));\n                // If the last argument to pipeline is not a stream\n                // we must create a proxy stream so that pipeline(...)\n                // always returns a stream which can be further\n                // composed through `.pipe(stream)`.\n                const pt = new $5501b248b6c40ce0$var$PassThrough({\n                    objectMode: true\n                });\n                // Handle Promises/A+ spec, `then` could be a getter that throws on\n                // second use.\n                const then = (_ret2 = ret) === null || _ret2 === undefined ? undefined : _ret2.then;\n                if (typeof then === 'function') {\n                    finishCount++;\n                    then.call(ret, (val)=>{\n                        value = val;\n                        if (val != null) pt.write(val);\n                        if (end) pt.end();\n                        $ibaza.nextTick(finish);\n                    }, (err)=>{\n                        pt.destroy(err);\n                        $ibaza.nextTick(finish, err);\n                    });\n                } else if ($5501b248b6c40ce0$require$isIterable(ret, true)) {\n                    finishCount++;\n                    $5501b248b6c40ce0$var$pumpToNode(ret, pt, finish, {\n                        end: end\n                    });\n                } else if ($5501b248b6c40ce0$require$isReadableStream(ret) || $5501b248b6c40ce0$require$isTransformStream(ret)) {\n                    const toRead = ret.readable || ret;\n                    finishCount++;\n                    $5501b248b6c40ce0$var$pumpToNode(toRead, pt, finish, {\n                        end: end\n                    });\n                } else throw new $5501b248b6c40ce0$var$ERR_INVALID_RETURN_VALUE('AsyncIterable or Promise', 'destination', ret);\n                ret = pt;\n                const { destroy: destroy, cleanup: cleanup } = $5501b248b6c40ce0$var$destroyer(ret, false, true);\n                destroys.push(destroy);\n                if (isLastStream) lastStreamCleanup.push(cleanup);\n            }\n        } else if ($5501b248b6c40ce0$require$isNodeStream(stream)) {\n            if ($5501b248b6c40ce0$require$isReadableNodeStream(ret)) {\n                finishCount += 2;\n                const cleanup = $5501b248b6c40ce0$var$pipe(ret, stream, finish, {\n                    end: end\n                });\n                if ($5501b248b6c40ce0$require$isReadable(stream) && isLastStream) lastStreamCleanup.push(cleanup);\n            } else if ($5501b248b6c40ce0$require$isTransformStream(ret) || $5501b248b6c40ce0$require$isReadableStream(ret)) {\n                const toRead = ret.readable || ret;\n                finishCount++;\n                $5501b248b6c40ce0$var$pumpToNode(toRead, stream, finish, {\n                    end: end\n                });\n            } else if ($5501b248b6c40ce0$require$isIterable(ret)) {\n                finishCount++;\n                $5501b248b6c40ce0$var$pumpToNode(ret, stream, finish, {\n                    end: end\n                });\n            } else throw new $5501b248b6c40ce0$var$ERR_INVALID_ARG_TYPE('val', [\n                'Readable',\n                'Iterable',\n                'AsyncIterable',\n                'ReadableStream',\n                'TransformStream'\n            ], ret);\n            ret = stream;\n        } else if ($5501b248b6c40ce0$require$isWebStream(stream)) {\n            if ($5501b248b6c40ce0$require$isReadableNodeStream(ret)) {\n                finishCount++;\n                $5501b248b6c40ce0$var$pumpToWeb($5501b248b6c40ce0$var$makeAsyncIterable(ret), stream, finish, {\n                    end: end\n                });\n            } else if ($5501b248b6c40ce0$require$isReadableStream(ret) || $5501b248b6c40ce0$require$isIterable(ret)) {\n                finishCount++;\n                $5501b248b6c40ce0$var$pumpToWeb(ret, stream, finish, {\n                    end: end\n                });\n            } else if ($5501b248b6c40ce0$require$isTransformStream(ret)) {\n                finishCount++;\n                $5501b248b6c40ce0$var$pumpToWeb(ret.readable, stream, finish, {\n                    end: end\n                });\n            } else throw new $5501b248b6c40ce0$var$ERR_INVALID_ARG_TYPE('val', [\n                'Readable',\n                'Iterable',\n                'AsyncIterable',\n                'ReadableStream',\n                'TransformStream'\n            ], ret);\n            ret = stream;\n        } else ret = $lyuEd.from(stream);\n    }\n    if (signal !== null && signal !== undefined && signal.aborted || outerSignal !== null && outerSignal !== undefined && outerSignal.aborted) $ibaza.nextTick(abort);\n    return ret;\n}\nfunction $5501b248b6c40ce0$var$pipe(src, dst, finish, { end: end }) {\n    let ended = false;\n    dst.on('close', ()=>{\n        if (!ended) // Finish if the destination closes before the source has completed.\n        finish(new $5501b248b6c40ce0$var$ERR_STREAM_PREMATURE_CLOSE());\n    });\n    src.pipe(dst, {\n        end: false\n    }) // If end is true we already will have a listener to end dst.\n    ;\n    if (end) {\n        // Compat. Before node v10.12.0 stdio used to throw an error so\n        // pipe() did/does not end() stdio destinations.\n        // Now they allow it but \"secretly\" don't close the underlying fd.\n        function endFn() {\n            ended = true;\n            dst.end();\n        }\n        if ($5501b248b6c40ce0$require$isReadableFinished(src)) // End the destination if the source has already ended.\n        $ibaza.nextTick(endFn);\n        else src.once('end', endFn);\n    } else finish();\n    $9RUbc(src, {\n        readable: true,\n        writable: false\n    }, (err)=>{\n        const rState = src._readableState;\n        if (err && err.code === 'ERR_STREAM_PREMATURE_CLOSE' && rState && rState.ended && !rState.errored && !rState.errorEmitted) // Some readable streams will emit 'close' before 'end'. However, since\n        // this is on the readable side 'end' should still be emitted if the\n        // stream has been ended and no error emitted. This should be allowed in\n        // favor of backwards compatibility. Since the stream is piped to a\n        // destination this should not result in any observable difference.\n        // We don't need to check if this is a writable premature close since\n        // eos will only fail with premature close on the reading side for\n        // duplex streams.\n        src.once('end', finish).once('error', finish);\n        else finish(err);\n    });\n    return $9RUbc(dst, {\n        readable: false,\n        writable: true\n    }, finish);\n}\n$5501b248b6c40ce0$exports = {\n    pipelineImpl: $5501b248b6c40ce0$var$pipelineImpl,\n    pipeline: $5501b248b6c40ce0$var$pipeline\n};\n\n\nvar $d16ccf556459ec6a$require$pipeline = $5501b248b6c40ce0$exports.pipeline;\n\nvar $lyuEd = parcelRequire(\"lyuEd\");\n\nvar $7CELW = parcelRequire(\"7CELW\");\nvar $d16ccf556459ec6a$require$destroyer = $7CELW.destroyer;\n\nvar $eY1Gs = parcelRequire(\"eY1Gs\");\nvar $d16ccf556459ec6a$require$isNodeStream = $eY1Gs.isNodeStream;\nvar $d16ccf556459ec6a$require$isReadable = $eY1Gs.isReadable;\nvar $d16ccf556459ec6a$require$isWritable = $eY1Gs.isWritable;\nvar $d16ccf556459ec6a$require$isWebStream = $eY1Gs.isWebStream;\nvar $d16ccf556459ec6a$require$isTransformStream = $eY1Gs.isTransformStream;\nvar $d16ccf556459ec6a$require$isWritableStream = $eY1Gs.isWritableStream;\nvar $d16ccf556459ec6a$require$isReadableStream = $eY1Gs.isReadableStream;\n\nvar $7ynhX = parcelRequire(\"7ynhX\");\nconst { AbortError: $d16ccf556459ec6a$var$AbortError, codes: { ERR_INVALID_ARG_VALUE: $d16ccf556459ec6a$var$ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS: $d16ccf556459ec6a$var$ERR_MISSING_ARGS } } = $7ynhX;\n\nvar $9RUbc = parcelRequire(\"9RUbc\");\n$d16ccf556459ec6a$exports = function compose(...streams) {\n    if (streams.length === 0) throw new $d16ccf556459ec6a$var$ERR_MISSING_ARGS('streams');\n    if (streams.length === 1) return $lyuEd.from(streams[0]);\n    const orgStreams = [\n        ...streams\n    ];\n    if (typeof streams[0] === 'function') streams[0] = $lyuEd.from(streams[0]);\n    if (typeof streams[streams.length - 1] === 'function') {\n        const idx = streams.length - 1;\n        streams[idx] = $lyuEd.from(streams[idx]);\n    }\n    for(let n = 0; n < streams.length; ++n){\n        if (!$d16ccf556459ec6a$require$isNodeStream(streams[n]) && !$d16ccf556459ec6a$require$isWebStream(streams[n])) continue;\n        if (n < streams.length - 1 && !($d16ccf556459ec6a$require$isReadable(streams[n]) || $d16ccf556459ec6a$require$isReadableStream(streams[n]) || $d16ccf556459ec6a$require$isTransformStream(streams[n]))) throw new $d16ccf556459ec6a$var$ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], 'must be readable');\n        if (n > 0 && !($d16ccf556459ec6a$require$isWritable(streams[n]) || $d16ccf556459ec6a$require$isWritableStream(streams[n]) || $d16ccf556459ec6a$require$isTransformStream(streams[n]))) throw new $d16ccf556459ec6a$var$ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], 'must be writable');\n    }\n    let ondrain;\n    let onfinish;\n    let onreadable;\n    let onclose;\n    let d;\n    function onfinished(err) {\n        const cb = onclose;\n        onclose = null;\n        if (cb) cb(err);\n        else if (err) d.destroy(err);\n        else if (!readable && !writable) d.destroy();\n    }\n    const head = streams[0];\n    const tail = $d16ccf556459ec6a$require$pipeline(streams, onfinished);\n    const writable = !!($d16ccf556459ec6a$require$isWritable(head) || $d16ccf556459ec6a$require$isWritableStream(head) || $d16ccf556459ec6a$require$isTransformStream(head));\n    const readable = !!($d16ccf556459ec6a$require$isReadable(tail) || $d16ccf556459ec6a$require$isReadableStream(tail) || $d16ccf556459ec6a$require$isTransformStream(tail));\n    // TODO(ronag): Avoid double buffering.\n    // Implement Writable/Readable/Duplex traits.\n    // See, https://github.com/nodejs/node/pull/33515.\n    d = new $lyuEd({\n        // TODO (ronag): highWaterMark?\n        writableObjectMode: !!(head !== null && head !== undefined && head.writableObjectMode),\n        readableObjectMode: !!(tail !== null && tail !== undefined && tail.readableObjectMode),\n        writable: writable,\n        readable: readable\n    });\n    if (writable) {\n        if ($d16ccf556459ec6a$require$isNodeStream(head)) {\n            d._write = function(chunk, encoding, callback) {\n                if (head.write(chunk, encoding)) callback();\n                else ondrain = callback;\n            };\n            d._final = function(callback) {\n                head.end();\n                onfinish = callback;\n            };\n            head.on('drain', function() {\n                if (ondrain) {\n                    const cb = ondrain;\n                    ondrain = null;\n                    cb();\n                }\n            });\n        } else if ($d16ccf556459ec6a$require$isWebStream(head)) {\n            const writable = $d16ccf556459ec6a$require$isTransformStream(head) ? head.writable : head;\n            const writer = writable.getWriter();\n            d._write = async function(chunk, encoding, callback) {\n                try {\n                    await writer.ready;\n                    writer.write(chunk).catch(()=>{});\n                    callback();\n                } catch (err) {\n                    callback(err);\n                }\n            };\n            d._final = async function(callback) {\n                try {\n                    await writer.ready;\n                    writer.close().catch(()=>{});\n                    onfinish = callback;\n                } catch (err) {\n                    callback(err);\n                }\n            };\n        }\n        const toRead = $d16ccf556459ec6a$require$isTransformStream(tail) ? tail.readable : tail;\n        $9RUbc(toRead, ()=>{\n            if (onfinish) {\n                const cb = onfinish;\n                onfinish = null;\n                cb();\n            }\n        });\n    }\n    if (readable) {\n        if ($d16ccf556459ec6a$require$isNodeStream(tail)) {\n            tail.on('readable', function() {\n                if (onreadable) {\n                    const cb = onreadable;\n                    onreadable = null;\n                    cb();\n                }\n            });\n            tail.on('end', function() {\n                d.push(null);\n            });\n            d._read = function() {\n                while(true){\n                    const buf = tail.read();\n                    if (buf === null) {\n                        onreadable = d._read;\n                        return;\n                    }\n                    if (!d.push(buf)) return;\n                }\n            };\n        } else if ($d16ccf556459ec6a$require$isWebStream(tail)) {\n            const readable = $d16ccf556459ec6a$require$isTransformStream(tail) ? tail.readable : tail;\n            const reader = readable.getReader();\n            d._read = async function() {\n                while(true)try {\n                    const { value: value, done: done } = await reader.read();\n                    if (!d.push(value)) return;\n                    if (done) {\n                        d.push(null);\n                        return;\n                    }\n                } catch  {\n                    return;\n                }\n            };\n        }\n    }\n    d._destroy = function(err, callback) {\n        if (!err && onclose !== null) err = new $d16ccf556459ec6a$var$AbortError();\n        onreadable = null;\n        ondrain = null;\n        onfinish = null;\n        if (onclose === null) callback(err);\n        else {\n            onclose = callback;\n            if ($d16ccf556459ec6a$require$isNodeStream(tail)) $d16ccf556459ec6a$require$destroyer(tail, err);\n        }\n    };\n    return d;\n};\n\n\n\nvar $6ASt2 = parcelRequire(\"6ASt2\");\nvar $4696c9d5bd46ecd2$require$addAbortSignalNoValidate = $6ASt2.addAbortSignalNoValidate;\n\nvar $eY1Gs = parcelRequire(\"eY1Gs\");\nvar $4696c9d5bd46ecd2$require$isWritable = $eY1Gs.isWritable;\nvar $4696c9d5bd46ecd2$require$isNodeStream = $eY1Gs.isNodeStream;\n\nvar $4696c9d5bd46ecd2$require$deprecate = (parcelRequire(\"kDFyU\")).deprecate;\n\nvar $4696c9d5bd46ecd2$require$ArrayPrototypePush = (parcelRequire(\"1by5F\")).ArrayPrototypePush;\nvar $4696c9d5bd46ecd2$require$Boolean = (parcelRequire(\"1by5F\")).Boolean;\nvar $4696c9d5bd46ecd2$require$MathFloor = (parcelRequire(\"1by5F\")).MathFloor;\nvar $4696c9d5bd46ecd2$require$Number = (parcelRequire(\"1by5F\")).Number;\nvar $4696c9d5bd46ecd2$require$NumberIsNaN = (parcelRequire(\"1by5F\")).NumberIsNaN;\nvar $4696c9d5bd46ecd2$require$Promise = (parcelRequire(\"1by5F\")).Promise;\nvar $4696c9d5bd46ecd2$require$PromiseReject = (parcelRequire(\"1by5F\")).PromiseReject;\nvar $4696c9d5bd46ecd2$require$PromiseResolve = (parcelRequire(\"1by5F\")).PromiseResolve;\nvar $4696c9d5bd46ecd2$require$PromisePrototypeThen = (parcelRequire(\"1by5F\")).PromisePrototypeThen;\nvar $4696c9d5bd46ecd2$require$Symbol = (parcelRequire(\"1by5F\")).Symbol;\nconst $4696c9d5bd46ecd2$var$kEmpty = $4696c9d5bd46ecd2$require$Symbol('kEmpty');\nconst $4696c9d5bd46ecd2$var$kEof = $4696c9d5bd46ecd2$require$Symbol('kEof');\nfunction $4696c9d5bd46ecd2$var$compose(stream, options) {\n    if (options != null) $4696c9d5bd46ecd2$require$validateObject(options, 'options');\n    if ((options === null || options === undefined ? undefined : options.signal) != null) $4696c9d5bd46ecd2$require$validateAbortSignal(options.signal, 'options.signal');\n    if ($4696c9d5bd46ecd2$require$isNodeStream(stream) && !$4696c9d5bd46ecd2$require$isWritable(stream)) throw new $4696c9d5bd46ecd2$var$ERR_INVALID_ARG_VALUE('stream', stream, 'must be writable');\n    const composedStream = $d16ccf556459ec6a$exports(this, stream);\n    if (options !== null && options !== undefined && options.signal) // Not validating as we already validated before\n    $4696c9d5bd46ecd2$require$addAbortSignalNoValidate(options.signal, composedStream);\n    return composedStream;\n}\n\nfunction $4696c9d5bd46ecd2$var$map(fn, options) {\n    if (typeof fn !== 'function') throw new $4696c9d5bd46ecd2$var$ERR_INVALID_ARG_TYPE('fn', [\n        'Function',\n        'AsyncFunction'\n    ], fn);\n    if (options != null) $4696c9d5bd46ecd2$require$validateObject(options, 'options');\n    if ((options === null || options === undefined ? undefined : options.signal) != null) $4696c9d5bd46ecd2$require$validateAbortSignal(options.signal, 'options.signal');\n    let concurrency = 1;\n    if ((options === null || options === undefined ? undefined : options.concurrency) != null) concurrency = $4696c9d5bd46ecd2$require$MathFloor(options.concurrency);\n    let highWaterMark = concurrency - 1;\n    if ((options === null || options === undefined ? undefined : options.highWaterMark) != null) highWaterMark = $4696c9d5bd46ecd2$require$MathFloor(options.highWaterMark);\n    $4696c9d5bd46ecd2$require$validateInteger(concurrency, 'options.concurrency', 1);\n    $4696c9d5bd46ecd2$require$validateInteger(highWaterMark, 'options.highWaterMark', 0);\n    highWaterMark += concurrency;\n    return (async function* map() {\n        const signal = (parcelRequire(\"kDFyU\")).AbortSignalAny([\n            options === null || options === undefined ? undefined : options.signal\n        ].filter($4696c9d5bd46ecd2$require$Boolean));\n        const stream = this;\n        const queue = [];\n        const signalOpt = {\n            signal: signal\n        };\n        let next;\n        let resume;\n        let done = false;\n        let cnt = 0;\n        function onCatch() {\n            done = true;\n            afterItemProcessed();\n        }\n        function afterItemProcessed() {\n            cnt -= 1;\n            maybeResume();\n        }\n        function maybeResume() {\n            if (resume && !done && cnt < concurrency && queue.length < highWaterMark) {\n                resume();\n                resume = null;\n            }\n        }\n        async function pump() {\n            try {\n                for await (let val of stream){\n                    if (done) return;\n                    if (signal.aborted) throw new $4696c9d5bd46ecd2$var$AbortError();\n                    try {\n                        val = fn(val, signalOpt);\n                        if (val === $4696c9d5bd46ecd2$var$kEmpty) continue;\n                        val = $4696c9d5bd46ecd2$require$PromiseResolve(val);\n                    } catch (err) {\n                        val = $4696c9d5bd46ecd2$require$PromiseReject(err);\n                    }\n                    cnt += 1;\n                    $4696c9d5bd46ecd2$require$PromisePrototypeThen(val, afterItemProcessed, onCatch);\n                    queue.push(val);\n                    if (next) {\n                        next();\n                        next = null;\n                    }\n                    if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) await new $4696c9d5bd46ecd2$require$Promise((resolve)=>{\n                        resume = resolve;\n                    });\n                }\n                queue.push($4696c9d5bd46ecd2$var$kEof);\n            } catch (err) {\n                const val = $4696c9d5bd46ecd2$require$PromiseReject(err);\n                $4696c9d5bd46ecd2$require$PromisePrototypeThen(val, afterItemProcessed, onCatch);\n                queue.push(val);\n            } finally{\n                done = true;\n                if (next) {\n                    next();\n                    next = null;\n                }\n            }\n        }\n        pump();\n        try {\n            while(true){\n                while(queue.length > 0){\n                    const val = await queue[0];\n                    if (val === $4696c9d5bd46ecd2$var$kEof) return;\n                    if (signal.aborted) throw new $4696c9d5bd46ecd2$var$AbortError();\n                    if (val !== $4696c9d5bd46ecd2$var$kEmpty) yield val;\n                    queue.shift();\n                    maybeResume();\n                }\n                await new $4696c9d5bd46ecd2$require$Promise((resolve)=>{\n                    next = resolve;\n                });\n            }\n        } finally{\n            done = true;\n            if (resume) {\n                resume();\n                resume = null;\n            }\n        }\n    }).call(this);\n}\nfunction $4696c9d5bd46ecd2$var$asIndexedPairs(options) {\n    if (options != null) $4696c9d5bd46ecd2$require$validateObject(options, 'options');\n    if ((options === null || options === undefined ? undefined : options.signal) != null) $4696c9d5bd46ecd2$require$validateAbortSignal(options.signal, 'options.signal');\n    return (async function* asIndexedPairs() {\n        let index = 0;\n        for await (const val of this){\n            var _options$signal;\n            if (options !== null && options !== undefined && (_options$signal = options.signal) !== null && _options$signal !== undefined && _options$signal.aborted) throw new $4696c9d5bd46ecd2$var$AbortError({\n                cause: options.signal.reason\n            });\n            yield [\n                index++,\n                val\n            ];\n        }\n    }).call(this);\n}\nasync function $4696c9d5bd46ecd2$var$some(fn, options) {\n    for await (const unused of $4696c9d5bd46ecd2$var$filter.call(this, fn, options))return true;\n    return false;\n}\nasync function $4696c9d5bd46ecd2$var$every(fn, options) {\n    if (typeof fn !== 'function') throw new $4696c9d5bd46ecd2$var$ERR_INVALID_ARG_TYPE('fn', [\n        'Function',\n        'AsyncFunction'\n    ], fn);\n    // https://en.wikipedia.org/wiki/De_Morgan%27s_laws\n    return !await $4696c9d5bd46ecd2$var$some.call(this, async (...args)=>{\n        return !await fn(...args);\n    }, options);\n}\nasync function $4696c9d5bd46ecd2$var$find(fn, options) {\n    for await (const result of $4696c9d5bd46ecd2$var$filter.call(this, fn, options))return result;\n    return undefined;\n}\nasync function $4696c9d5bd46ecd2$var$forEach(fn, options) {\n    if (typeof fn !== 'function') throw new $4696c9d5bd46ecd2$var$ERR_INVALID_ARG_TYPE('fn', [\n        'Function',\n        'AsyncFunction'\n    ], fn);\n    async function forEachFn(value, options) {\n        await fn(value, options);\n        return $4696c9d5bd46ecd2$var$kEmpty;\n    }\n    // eslint-disable-next-line no-unused-vars\n    for await (const unused of $4696c9d5bd46ecd2$var$map.call(this, forEachFn, options));\n}\nfunction $4696c9d5bd46ecd2$var$filter(fn, options) {\n    if (typeof fn !== 'function') throw new $4696c9d5bd46ecd2$var$ERR_INVALID_ARG_TYPE('fn', [\n        'Function',\n        'AsyncFunction'\n    ], fn);\n    async function filterFn(value, options) {\n        if (await fn(value, options)) return value;\n        return $4696c9d5bd46ecd2$var$kEmpty;\n    }\n    return $4696c9d5bd46ecd2$var$map.call(this, filterFn, options);\n}\n// Specific to provide better error to reduce since the argument is only\n// missing if the stream has no items in it - but the code is still appropriate\nclass $4696c9d5bd46ecd2$var$ReduceAwareErrMissingArgs extends $4696c9d5bd46ecd2$var$ERR_MISSING_ARGS {\n    constructor(){\n        super('reduce');\n        this.message = 'Reduce of an empty stream requires an initial value';\n    }\n}\nasync function $4696c9d5bd46ecd2$var$reduce(reducer, initialValue, options) {\n    var _options$signal2;\n    if (typeof reducer !== 'function') throw new $4696c9d5bd46ecd2$var$ERR_INVALID_ARG_TYPE('reducer', [\n        'Function',\n        'AsyncFunction'\n    ], reducer);\n    if (options != null) $4696c9d5bd46ecd2$require$validateObject(options, 'options');\n    if ((options === null || options === undefined ? undefined : options.signal) != null) $4696c9d5bd46ecd2$require$validateAbortSignal(options.signal, 'options.signal');\n    let hasInitialValue = arguments.length > 1;\n    if (options !== null && options !== undefined && (_options$signal2 = options.signal) !== null && _options$signal2 !== undefined && _options$signal2.aborted) {\n        const err = new $4696c9d5bd46ecd2$var$AbortError(undefined, {\n            cause: options.signal.reason\n        });\n        this.once('error', ()=>{}) // The error is already propagated\n        ;\n        await $4696c9d5bd46ecd2$require$finished(this.destroy(err));\n        throw err;\n    }\n    const ac = new $4696c9d5bd46ecd2$var$AbortController();\n    const signal = ac.signal;\n    if (options !== null && options !== undefined && options.signal) {\n        const opts = {\n            once: true,\n            [$4696c9d5bd46ecd2$var$kWeakHandler]: this,\n            [$4696c9d5bd46ecd2$var$kResistStopPropagation]: true\n        };\n        options.signal.addEventListener('abort', ()=>ac.abort(), opts);\n    }\n    let gotAnyItemFromStream = false;\n    try {\n        for await (const value of this){\n            var _options$signal3;\n            gotAnyItemFromStream = true;\n            if (options !== null && options !== undefined && (_options$signal3 = options.signal) !== null && _options$signal3 !== undefined && _options$signal3.aborted) throw new $4696c9d5bd46ecd2$var$AbortError();\n            if (!hasInitialValue) {\n                initialValue = value;\n                hasInitialValue = true;\n            } else initialValue = await reducer(initialValue, value, {\n                signal: signal\n            });\n        }\n        if (!gotAnyItemFromStream && !hasInitialValue) throw new $4696c9d5bd46ecd2$var$ReduceAwareErrMissingArgs();\n    } finally{\n        ac.abort();\n    }\n    return initialValue;\n}\nasync function $4696c9d5bd46ecd2$var$toArray(options) {\n    if (options != null) $4696c9d5bd46ecd2$require$validateObject(options, 'options');\n    if ((options === null || options === undefined ? undefined : options.signal) != null) $4696c9d5bd46ecd2$require$validateAbortSignal(options.signal, 'options.signal');\n    const result = [];\n    for await (const val of this){\n        var _options$signal4;\n        if (options !== null && options !== undefined && (_options$signal4 = options.signal) !== null && _options$signal4 !== undefined && _options$signal4.aborted) throw new $4696c9d5bd46ecd2$var$AbortError(undefined, {\n            cause: options.signal.reason\n        });\n        $4696c9d5bd46ecd2$require$ArrayPrototypePush(result, val);\n    }\n    return result;\n}\nfunction $4696c9d5bd46ecd2$var$flatMap(fn, options) {\n    const values = $4696c9d5bd46ecd2$var$map.call(this, fn, options);\n    return (async function* flatMap() {\n        for await (const val of values)yield* val;\n    }).call(this);\n}\nfunction $4696c9d5bd46ecd2$var$toIntegerOrInfinity(number) {\n    // We coerce here to align with the spec\n    // https://github.com/tc39/proposal-iterator-helpers/issues/169\n    number = $4696c9d5bd46ecd2$require$Number(number);\n    if ($4696c9d5bd46ecd2$require$NumberIsNaN(number)) return 0;\n    if (number < 0) throw new $4696c9d5bd46ecd2$var$ERR_OUT_OF_RANGE('number', '>= 0', number);\n    return number;\n}\nfunction $4696c9d5bd46ecd2$var$drop(number, options) {\n    if (options != null) $4696c9d5bd46ecd2$require$validateObject(options, 'options');\n    if ((options === null || options === undefined ? undefined : options.signal) != null) $4696c9d5bd46ecd2$require$validateAbortSignal(options.signal, 'options.signal');\n    number = $4696c9d5bd46ecd2$var$toIntegerOrInfinity(number);\n    return (async function* drop() {\n        var _options$signal5;\n        if (options !== null && options !== undefined && (_options$signal5 = options.signal) !== null && _options$signal5 !== undefined && _options$signal5.aborted) throw new $4696c9d5bd46ecd2$var$AbortError();\n        for await (const val of this){\n            var _options$signal6;\n            if (options !== null && options !== undefined && (_options$signal6 = options.signal) !== null && _options$signal6 !== undefined && _options$signal6.aborted) throw new $4696c9d5bd46ecd2$var$AbortError();\n            if (number-- <= 0) yield val;\n        }\n    }).call(this);\n}\nfunction $4696c9d5bd46ecd2$var$take(number, options) {\n    if (options != null) $4696c9d5bd46ecd2$require$validateObject(options, 'options');\n    if ((options === null || options === undefined ? undefined : options.signal) != null) $4696c9d5bd46ecd2$require$validateAbortSignal(options.signal, 'options.signal');\n    number = $4696c9d5bd46ecd2$var$toIntegerOrInfinity(number);\n    return (async function* take() {\n        var _options$signal7;\n        if (options !== null && options !== undefined && (_options$signal7 = options.signal) !== null && _options$signal7 !== undefined && _options$signal7.aborted) throw new $4696c9d5bd46ecd2$var$AbortError();\n        for await (const val of this){\n            var _options$signal8;\n            if (options !== null && options !== undefined && (_options$signal8 = options.signal) !== null && _options$signal8 !== undefined && _options$signal8.aborted) throw new $4696c9d5bd46ecd2$var$AbortError();\n            if (number-- > 0) yield val;\n            // Don't get another item from iterator in case we reached the end\n            if (number <= 0) return;\n        }\n    }).call(this);\n}\n$4696c9d5bd46ecd2$export$42af8c323be37587 = {\n    asIndexedPairs: $4696c9d5bd46ecd2$require$deprecate($4696c9d5bd46ecd2$var$asIndexedPairs, 'readable.asIndexedPairs will be removed in a future version.'),\n    drop: $4696c9d5bd46ecd2$var$drop,\n    filter: $4696c9d5bd46ecd2$var$filter,\n    flatMap: $4696c9d5bd46ecd2$var$flatMap,\n    map: $4696c9d5bd46ecd2$var$map,\n    take: $4696c9d5bd46ecd2$var$take,\n    compose: $4696c9d5bd46ecd2$var$compose\n};\n$4696c9d5bd46ecd2$export$f405f72c701dad87 = {\n    every: $4696c9d5bd46ecd2$var$every,\n    forEach: $4696c9d5bd46ecd2$var$forEach,\n    reduce: $4696c9d5bd46ecd2$var$reduce,\n    toArray: $4696c9d5bd46ecd2$var$toArray,\n    some: $4696c9d5bd46ecd2$var$some,\n    find: $4696c9d5bd46ecd2$var$find\n};\n\n\nvar $ec1bbd7296755677$require$streamReturningOperators = $4696c9d5bd46ecd2$export$42af8c323be37587;\nvar $ec1bbd7296755677$require$promiseReturningOperators = $4696c9d5bd46ecd2$export$f405f72c701dad87;\n\nvar $7ynhX = parcelRequire(\"7ynhX\");\nconst { codes: { ERR_ILLEGAL_CONSTRUCTOR: $ec1bbd7296755677$var$ERR_ILLEGAL_CONSTRUCTOR } } = $7ynhX;\n\n\nvar $bKeTG = parcelRequire(\"bKeTG\");\nvar $ec1bbd7296755677$require$setDefaultHighWaterMark = $bKeTG.setDefaultHighWaterMark;\nvar $ec1bbd7296755677$require$getDefaultHighWaterMark = $bKeTG.getDefaultHighWaterMark;\n\nvar $ec1bbd7296755677$require$pipeline = $5501b248b6c40ce0$exports.pipeline;\n\nvar $7CELW = parcelRequire(\"7CELW\");\nvar $ec1bbd7296755677$require$destroyer = $7CELW.destroyer;\n\nvar $9RUbc = parcelRequire(\"9RUbc\");\nconst $ec1bbd7296755677$var$internalBuffer = {};\nvar $369d19b0ed0d12c8$exports = {};\n'use strict';\n\nvar $1by5F = parcelRequire(\"1by5F\");\nvar $369d19b0ed0d12c8$require$ArrayPrototypePop = $1by5F.ArrayPrototypePop;\nvar $369d19b0ed0d12c8$require$Promise = $1by5F.Promise;\n\nvar $eY1Gs = parcelRequire(\"eY1Gs\");\nvar $369d19b0ed0d12c8$require$isIterable = $eY1Gs.isIterable;\nvar $369d19b0ed0d12c8$require$isNodeStream = $eY1Gs.isNodeStream;\nvar $369d19b0ed0d12c8$require$isWebStream = $eY1Gs.isWebStream;\n\nvar $369d19b0ed0d12c8$require$pl = $5501b248b6c40ce0$exports.pipelineImpl;\n\nvar $9RUbc = parcelRequire(\"9RUbc\");\nvar $369d19b0ed0d12c8$require$finished = $9RUbc.finished;\n\nfunction $369d19b0ed0d12c8$var$pipeline(...streams) {\n    return new $369d19b0ed0d12c8$require$Promise((resolve, reject)=>{\n        let signal;\n        let end;\n        const lastArg = streams[streams.length - 1];\n        if (lastArg && typeof lastArg === 'object' && !$369d19b0ed0d12c8$require$isNodeStream(lastArg) && !$369d19b0ed0d12c8$require$isIterable(lastArg) && !$369d19b0ed0d12c8$require$isWebStream(lastArg)) {\n            const options = $369d19b0ed0d12c8$require$ArrayPrototypePop(streams);\n            signal = options.signal;\n            end = options.end;\n        }\n        $369d19b0ed0d12c8$require$pl(streams, (err, value)=>{\n            if (err) reject(err);\n            else resolve(value);\n        }, {\n            signal: signal,\n            end: end\n        });\n    });\n}\n$369d19b0ed0d12c8$exports = {\n    finished: $369d19b0ed0d12c8$require$finished,\n    pipeline: $369d19b0ed0d12c8$var$pipeline\n};\n\n\n\nvar $eY1Gs = parcelRequire(\"eY1Gs\");\n\nconst $ec1bbd7296755677$var$Stream = $ec1bbd7296755677$exports = (parcelRequire(\"1Tt4D\")).Stream;\n$ec1bbd7296755677$var$Stream.isDestroyed = $eY1Gs.isDestroyed;\n$ec1bbd7296755677$var$Stream.isDisturbed = $eY1Gs.isDisturbed;\n$ec1bbd7296755677$var$Stream.isErrored = $eY1Gs.isErrored;\n$ec1bbd7296755677$var$Stream.isReadable = $eY1Gs.isReadable;\n$ec1bbd7296755677$var$Stream.isWritable = $eY1Gs.isWritable;\n\n$ec1bbd7296755677$var$Stream.Readable = (parcelRequire(\"c6GJA\"));\nfor (const key of $ec1bbd7296755677$require$ObjectKeys($ec1bbd7296755677$require$streamReturningOperators)){\n    const op = $ec1bbd7296755677$require$streamReturningOperators[key];\n    function fn(...args) {\n        if (new.target) throw $ec1bbd7296755677$var$ERR_ILLEGAL_CONSTRUCTOR();\n        return $ec1bbd7296755677$var$Stream.Readable.from($ec1bbd7296755677$require$ReflectApply(op, this, args));\n    }\n    $ec1bbd7296755677$require$ObjectDefineProperty(fn, 'name', {\n        __proto__: null,\n        value: op.name\n    });\n    $ec1bbd7296755677$require$ObjectDefineProperty(fn, 'length', {\n        __proto__: null,\n        value: op.length\n    });\n    $ec1bbd7296755677$require$ObjectDefineProperty($ec1bbd7296755677$var$Stream.Readable.prototype, key, {\n        __proto__: null,\n        value: fn,\n        enumerable: false,\n        configurable: true,\n        writable: true\n    });\n}\nfor (const key of $ec1bbd7296755677$require$ObjectKeys($ec1bbd7296755677$require$promiseReturningOperators)){\n    const op = $ec1bbd7296755677$require$promiseReturningOperators[key];\n    function fn1(...args) {\n        if (new.target) throw $ec1bbd7296755677$var$ERR_ILLEGAL_CONSTRUCTOR();\n        return $ec1bbd7296755677$require$ReflectApply(op, this, args);\n    }\n    $ec1bbd7296755677$require$ObjectDefineProperty(fn1, 'name', {\n        __proto__: null,\n        value: op.name\n    });\n    $ec1bbd7296755677$require$ObjectDefineProperty(fn1, 'length', {\n        __proto__: null,\n        value: op.length\n    });\n    $ec1bbd7296755677$require$ObjectDefineProperty($ec1bbd7296755677$var$Stream.Readable.prototype, key, {\n        __proto__: null,\n        value: fn1,\n        enumerable: false,\n        configurable: true,\n        writable: true\n    });\n}\n\n$ec1bbd7296755677$var$Stream.Writable = (parcelRequire(\"95yXm\"));\n\n$ec1bbd7296755677$var$Stream.Duplex = (parcelRequire(\"lyuEd\"));\n\n$ec1bbd7296755677$var$Stream.Transform = (parcelRequire(\"eI51J\"));\n\n$ec1bbd7296755677$var$Stream.PassThrough = (parcelRequire(\"kFz2c\"));\n$ec1bbd7296755677$var$Stream.pipeline = $ec1bbd7296755677$require$pipeline;\n\nvar $6ASt2 = parcelRequire(\"6ASt2\");\nvar $ec1bbd7296755677$require$addAbortSignal = $6ASt2.addAbortSignal;\n$ec1bbd7296755677$var$Stream.addAbortSignal = $ec1bbd7296755677$require$addAbortSignal;\n$ec1bbd7296755677$var$Stream.finished = $9RUbc;\n$ec1bbd7296755677$var$Stream.destroy = $ec1bbd7296755677$require$destroyer;\n$ec1bbd7296755677$var$Stream.compose = $d16ccf556459ec6a$exports;\n$ec1bbd7296755677$var$Stream.setDefaultHighWaterMark = $ec1bbd7296755677$require$setDefaultHighWaterMark;\n$ec1bbd7296755677$var$Stream.getDefaultHighWaterMark = $ec1bbd7296755677$require$getDefaultHighWaterMark;\n$ec1bbd7296755677$require$ObjectDefineProperty($ec1bbd7296755677$var$Stream, 'promises', {\n    __proto__: null,\n    configurable: true,\n    enumerable: true,\n    get () {\n        return $369d19b0ed0d12c8$exports;\n    }\n});\n$ec1bbd7296755677$require$ObjectDefineProperty($ec1bbd7296755677$require$pipeline, $ec1bbd7296755677$var$customPromisify, {\n    __proto__: null,\n    enumerable: true,\n    get () {\n        return $369d19b0ed0d12c8$exports.pipeline;\n    }\n});\n$ec1bbd7296755677$require$ObjectDefineProperty($9RUbc, $ec1bbd7296755677$var$customPromisify, {\n    __proto__: null,\n    enumerable: true,\n    get () {\n        return $369d19b0ed0d12c8$exports.finished;\n    }\n});\n// Backwards-compat with node 0.4.x\n$ec1bbd7296755677$var$Stream.Stream = $ec1bbd7296755677$var$Stream;\n$ec1bbd7296755677$var$Stream._isUint8Array = function isUint8Array(value) {\n    return value instanceof Uint8Array;\n};\n$ec1bbd7296755677$var$Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {\n    return $ec1bbd7296755677$require$Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);\n};\n\n\n\nconst $3450dab365fe3575$var$originalDestroy = $ec1bbd7296755677$exports.Readable.destroy;\n$3450dab365fe3575$exports = $ec1bbd7296755677$exports.Readable;\n// Explicit export naming is needed for ESM\n$3450dab365fe3575$exports._uint8ArrayToBuffer = $ec1bbd7296755677$exports._uint8ArrayToBuffer;\n$3450dab365fe3575$exports._isUint8Array = $ec1bbd7296755677$exports._isUint8Array;\n$3450dab365fe3575$exports.isDisturbed = $ec1bbd7296755677$exports.isDisturbed;\n$3450dab365fe3575$exports.isErrored = $ec1bbd7296755677$exports.isErrored;\n$3450dab365fe3575$exports.isReadable = $ec1bbd7296755677$exports.isReadable;\n$3450dab365fe3575$exports.Readable = $ec1bbd7296755677$exports.Readable;\n$3450dab365fe3575$exports.Writable = $ec1bbd7296755677$exports.Writable;\n$3450dab365fe3575$exports.Duplex = $ec1bbd7296755677$exports.Duplex;\n$3450dab365fe3575$exports.Transform = $ec1bbd7296755677$exports.Transform;\n$3450dab365fe3575$exports.PassThrough = $ec1bbd7296755677$exports.PassThrough;\n$3450dab365fe3575$exports.addAbortSignal = $ec1bbd7296755677$exports.addAbortSignal;\n$3450dab365fe3575$exports.finished = $ec1bbd7296755677$exports.finished;\n$3450dab365fe3575$exports.destroy = $ec1bbd7296755677$exports.destroy;\n$3450dab365fe3575$exports.destroy = $3450dab365fe3575$var$originalDestroy;\n$3450dab365fe3575$exports.pipeline = $ec1bbd7296755677$exports.pipeline;\n$3450dab365fe3575$exports.compose = $ec1bbd7296755677$exports.compose;\nObject.defineProperty($ec1bbd7296755677$exports, 'promises', {\n    configurable: true,\n    enumerable: true,\n    get () {\n        return $369d19b0ed0d12c8$exports;\n    }\n});\n$3450dab365fe3575$exports.Stream = $ec1bbd7296755677$exports.Stream;\n// Allow default importing\n$3450dab365fe3575$exports.default = $3450dab365fe3575$exports;\n\n\n\n\n\n\nconst $36d531372a4b28ea$var$ITERATOR = Symbol('iter');\nfunction $36d531372a4b28ea$var$merge(target, source, depth = 4) {\n    if (depth === 0) return Object.assign(target, source);\n    for(const key in source)target[key] = $36d531372a4b28ea$var$merge(target[key] || Object.create(null), source[key], depth - 1);\n    return target;\n}\n/**\n * Determines the intersection of the `_graphs` index s1 and s2.\n * s1 and s2 *must* belong to Stores that share an `_entityIndex`.\n *\n * False is returned when there is no intersection; this should\n * *not* be set as the value for an index.\n */ function $36d531372a4b28ea$var$intersect(s1, s2, depth = 4) {\n    let target = false;\n    for(const key in s1)if (key in s2) {\n        const intersection = depth === 0 ? null : $36d531372a4b28ea$var$intersect(s1[key], s2[key], depth - 1);\n        if (intersection !== false) {\n            target = target || Object.create(null);\n            target[key] = intersection;\n        } else if (depth === 3) return false;\n    }\n    return target;\n}\n/**\n * Determines the difference of the `_graphs` index s1 and s2.\n * s1 and s2 *must* belong to Stores that share an `_entityIndex`.\n *\n * False is returned when there is no difference; this should\n * *not* be set as the value for an index.\n */ function $36d531372a4b28ea$var$difference(s1, s2, depth = 4) {\n    let target = false;\n    for(const key in s1){\n        // When the key is not in the index, then none of the triples defined by s1[key] are\n        // in s2 and so we want to copy them over to the resultant store.\n        if (!(key in s2)) {\n            target = target || Object.create(null);\n            target[key] = depth === 0 ? null : $36d531372a4b28ea$var$merge({}, s1[key], depth - 1);\n        } else if (depth !== 0) {\n            const diff = $36d531372a4b28ea$var$difference(s1[key], s2[key], depth - 1);\n            if (diff !== false) {\n                target = target || Object.create(null);\n                target[key] = diff;\n            } else if (depth === 3) return false;\n        }\n    }\n    return target;\n}\nclass $36d531372a4b28ea$export$4e0df93146cafeaf {\n    constructor(options = {}){\n        this._id = 1;\n        // `_ids` maps entities such as `http://xmlns.com/foaf/0.1/name` to numbers,\n        // saving memory by using only numbers as keys in `_graphs`\n        this._ids = Object.create(null);\n        this._ids[''] = 1;\n        // inverse of `_ids`\n        this._entities = Object.create(null);\n        this._entities[1] = '';\n        // `_blankNodeIndex` is the index of the last automatically named blank node\n        this._blankNodeIndex = 0;\n        this._factory = options.factory || (0, $7b385df8cba0e42c$export$2e2bcd8739ae039);\n    }\n    _termFromId(id) {\n        if (id[0] === '.') {\n            const entities = this._entities;\n            const terms = id.split('.');\n            const q = this._factory.quad(this._termFromId(entities[terms[1]]), this._termFromId(entities[terms[2]]), this._termFromId(entities[terms[3]]), terms[4] && this._termFromId(entities[terms[4]]));\n            return q;\n        }\n        return (0, $7b385df8cba0e42c$export$85285e91bbd99cf)(id, this._factory);\n    }\n    _termToNumericId(term) {\n        if (term.termType === 'Quad') {\n            const s = this._termToNumericId(term.subject), p = this._termToNumericId(term.predicate), o = this._termToNumericId(term.object);\n            let g;\n            return s && p && o && ((0, $d6cb6627f0e6b6dd$export$1a29e0fa6b36b0c8)(term.graph) || (g = this._termToNumericId(term.graph))) && this._ids[g ? `.${s}.${p}.${o}.${g}` : `.${s}.${p}.${o}`];\n        }\n        return this._ids[(0, $7b385df8cba0e42c$export$fbf03d1179c9227e)(term)];\n    }\n    _termToNewNumericId(term) {\n        // This assumes that no graph term is present - we may wish to error if there is one\n        const str = term && term.termType === 'Quad' ? `.${this._termToNewNumericId(term.subject)}.${this._termToNewNumericId(term.predicate)}.${this._termToNewNumericId(term.object)}${(0, $d6cb6627f0e6b6dd$export$1a29e0fa6b36b0c8)(term.graph) ? '' : `.${this._termToNewNumericId(term.graph)}`}` : (0, $7b385df8cba0e42c$export$fbf03d1179c9227e)(term);\n        return this._ids[str] || (this._ids[this._entities[++this._id] = str] = this._id);\n    }\n    createBlankNode(suggestedName) {\n        let name, index;\n        // Generate a name based on the suggested name\n        if (suggestedName) {\n            name = suggestedName = `_:${suggestedName}`, index = 1;\n            while(this._ids[name])name = suggestedName + index++;\n        } else do name = `_:b${this._blankNodeIndex++}`;\n        while (this._ids[name]);\n        // Add the blank node to the entities, avoiding the generation of duplicates\n        this._ids[name] = ++this._id;\n        this._entities[this._id] = name;\n        return this._factory.blankNode(name.substr(2));\n    }\n}\nclass $36d531372a4b28ea$export$2e2bcd8739ae039 {\n    constructor(quads, options){\n        // The number of quads is initially zero\n        this._size = 0;\n        // `_graphs` contains subject, predicate, and object indexes per graph\n        this._graphs = Object.create(null);\n        // Shift parameters if `quads` is not given\n        if (!options && quads && !quads[0] && !(typeof quads.match === 'function')) options = quads, quads = null;\n        options = options || {};\n        this._factory = options.factory || (0, $7b385df8cba0e42c$export$2e2bcd8739ae039);\n        this._entityIndex = options.entityIndex || new $36d531372a4b28ea$export$4e0df93146cafeaf({\n            factory: this._factory\n        });\n        this._entities = this._entityIndex._entities;\n        this._termFromId = this._entityIndex._termFromId.bind(this._entityIndex);\n        this._termToNumericId = this._entityIndex._termToNumericId.bind(this._entityIndex);\n        this._termToNewNumericId = this._entityIndex._termToNewNumericId.bind(this._entityIndex);\n        // Add quads if passed\n        if (quads) this.addAll(quads);\n    }\n    // ## Public properties\n    // ### `size` returns the number of quads in the store\n    get size() {\n        // Return the quad count if if was cached\n        let size = this._size;\n        if (size !== null) return size;\n        // Calculate the number of quads by counting to the deepest level\n        size = 0;\n        const graphs = this._graphs;\n        let subjects, subject;\n        for(const graphKey in graphs)for(const subjectKey in subjects = graphs[graphKey].subjects)for(const predicateKey in subject = subjects[subjectKey])size += Object.keys(subject[predicateKey]).length;\n        return this._size = size;\n    }\n    // ## Private methods\n    // ### `_addToIndex` adds a quad to a three-layered index.\n    // Returns if the index has changed, if the entry did not already exist.\n    _addToIndex(index0, key0, key1, key2) {\n        // Create layers as necessary\n        const index1 = index0[key0] || (index0[key0] = {});\n        const index2 = index1[key1] || (index1[key1] = {});\n        // Setting the key to _any_ value signals the presence of the quad\n        const existed = key2 in index2;\n        if (!existed) index2[key2] = null;\n        return !existed;\n    }\n    // ### `_removeFromIndex` removes a quad from a three-layered index\n    _removeFromIndex(index0, key0, key1, key2) {\n        // Remove the quad from the index\n        const index1 = index0[key0], index2 = index1[key1];\n        delete index2[key2];\n        // Remove intermediary index layers if they are empty\n        for(const key in index2)return;\n        delete index1[key1];\n        for(const key in index1)return;\n        delete index0[key0];\n    }\n    // ### `_findInIndex` finds a set of quads in a three-layered index.\n    // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n    // Any of these keys can be undefined, which is interpreted as a wildcard.\n    // `name0`, `name1`, and `name2` are the names of the keys at each level,\n    // used when reconstructing the resulting quad\n    // (for instance: _subject_, _predicate_, and _object_).\n    // Finally, `graphId` will be the graph of the created quads.\n    *_findInIndex(index0, key0, key1, key2, name0, name1, name2, graphId) {\n        let tmp, index1, index2;\n        const entityKeys = this._entities;\n        const graph = this._termFromId(entityKeys[graphId]);\n        const parts = {\n            subject: null,\n            predicate: null,\n            object: null\n        };\n        // If a key is specified, use only that part of index 0.\n        if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];\n        for(const value0 in index0)if (index1 = index0[value0]) {\n            parts[name0] = this._termFromId(entityKeys[value0]);\n            // If a key is specified, use only that part of index 1.\n            if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];\n            for(const value1 in index1)if (index2 = index1[value1]) {\n                parts[name1] = this._termFromId(entityKeys[value1]);\n                // If a key is specified, use only that part of index 2, if it exists.\n                const values = key2 ? key2 in index2 ? [\n                    key2\n                ] : [] : Object.keys(index2);\n                // Create quads for all items found in index 2.\n                for(let l = 0; l < values.length; l++){\n                    parts[name2] = this._termFromId(entityKeys[values[l]]);\n                    yield this._factory.quad(parts.subject, parts.predicate, parts.object, graph);\n                }\n            }\n        }\n    }\n    // ### `_loop` executes the callback on all keys of index 0\n    _loop(index0, callback) {\n        for(const key0 in index0)callback(key0);\n    }\n    // ### `_loopByKey0` executes the callback on all keys of a certain entry in index 0\n    _loopByKey0(index0, key0, callback) {\n        let index1, key1;\n        if (index1 = index0[key0]) for(key1 in index1)callback(key1);\n    }\n    // ### `_loopByKey1` executes the callback on given keys of all entries in index 0\n    _loopByKey1(index0, key1, callback) {\n        let key0, index1;\n        for(key0 in index0){\n            index1 = index0[key0];\n            if (index1[key1]) callback(key0);\n        }\n    }\n    // ### `_loopBy2Keys` executes the callback on given keys of certain entries in index 2\n    _loopBy2Keys(index0, key0, key1, callback) {\n        let index1, index2, key2;\n        if ((index1 = index0[key0]) && (index2 = index1[key1])) for(key2 in index2)callback(key2);\n    }\n    // ### `_countInIndex` counts matching quads in a three-layered index.\n    // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n    // Any of these keys can be undefined, which is interpreted as a wildcard.\n    _countInIndex(index0, key0, key1, key2) {\n        let count = 0, tmp, index1, index2;\n        // If a key is specified, count only that part of index 0\n        if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];\n        for(const value0 in index0)if (index1 = index0[value0]) {\n            // If a key is specified, count only that part of index 1\n            if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];\n            for(const value1 in index1)if (index2 = index1[value1]) {\n                // If a key is specified, count the quad if it exists\n                if (key2) key2 in index2 && count++;\n                else count += Object.keys(index2).length;\n            }\n        }\n        return count;\n    }\n    // ### `_getGraphs` returns an array with the given graph,\n    // or all graphs if the argument is null or undefined.\n    _getGraphs(graph) {\n        graph = graph === '' ? 1 : graph && (this._termToNumericId(graph) || -1);\n        return typeof graph !== 'number' ? this._graphs : {\n            [graph]: this._graphs[graph]\n        };\n    }\n    // ### `_uniqueEntities` returns a function that accepts an entity ID\n    // and passes the corresponding entity to callback if it hasn't occurred before.\n    _uniqueEntities(callback) {\n        const uniqueIds = Object.create(null);\n        return (id)=>{\n            if (!(id in uniqueIds)) {\n                uniqueIds[id] = true;\n                callback(this._termFromId(this._entities[id], this._factory));\n            }\n        };\n    }\n    // ## Public methods\n    // ### `add` adds the specified quad to the dataset.\n    // Returns the dataset instance it was called on.\n    // Existing quads, as defined in Quad.equals, will be ignored.\n    add(quad) {\n        this.addQuad(quad);\n        return this;\n    }\n    // ### `addQuad` adds a new quad to the store.\n    // Returns if the quad index has changed, if the quad did not already exist.\n    addQuad(subject, predicate, object, graph) {\n        // Shift arguments if a quad object is given instead of components\n        if (!predicate) graph = subject.graph, object = subject.object, predicate = subject.predicate, subject = subject.subject;\n        // Convert terms to internal string representation\n        graph = graph ? this._termToNewNumericId(graph) : 1;\n        // Find the graph that will contain the triple\n        let graphItem = this._graphs[graph];\n        // Create the graph if it doesn't exist yet\n        if (!graphItem) {\n            graphItem = this._graphs[graph] = {\n                subjects: {},\n                predicates: {},\n                objects: {}\n            };\n            // Freezing a graph helps subsequent `add` performance,\n            // and properties will never be modified anyway\n            Object.freeze(graphItem);\n        }\n        // Since entities can often be long IRIs, we avoid storing them in every index.\n        // Instead, we have a separate index that maps entities to numbers,\n        // which are then used as keys in the other indexes.\n        subject = this._termToNewNumericId(subject);\n        predicate = this._termToNewNumericId(predicate);\n        object = this._termToNewNumericId(object);\n        if (!this._addToIndex(graphItem.subjects, subject, predicate, object)) return false;\n        this._addToIndex(graphItem.predicates, predicate, object, subject);\n        this._addToIndex(graphItem.objects, object, subject, predicate);\n        // The cached quad count is now invalid\n        this._size = null;\n        return true;\n    }\n    // ### `addQuads` adds multiple quads to the store\n    addQuads(quads) {\n        for(let i = 0; i < quads.length; i++)this.addQuad(quads[i]);\n    }\n    // ### `delete` removes the specified quad from the dataset.\n    // Returns the dataset instance it was called on.\n    delete(quad) {\n        this.removeQuad(quad);\n        return this;\n    }\n    // ### `has` determines whether a dataset includes a certain quad or quad pattern.\n    has(subjectOrQuad, predicate, object, graph) {\n        if (subjectOrQuad && subjectOrQuad.subject) ({ subject: subjectOrQuad, predicate: predicate, object: object, graph: graph } = subjectOrQuad);\n        return !this.readQuads(subjectOrQuad, predicate, object, graph).next().done;\n    }\n    // ### `import` adds a stream of quads to the store\n    import(stream) {\n        stream.on('data', (quad)=>{\n            this.addQuad(quad);\n        });\n        return stream;\n    }\n    // ### `removeQuad` removes a quad from the store if it exists\n    removeQuad(subject, predicate, object, graph) {\n        // Shift arguments if a quad object is given instead of components\n        if (!predicate) ({ subject: subject, predicate: predicate, object: object, graph: graph } = subject);\n        // Convert terms to internal string representation\n        graph = graph ? this._termToNumericId(graph) : 1;\n        // Find internal identifiers for all components\n        // and verify the quad exists.\n        const graphs = this._graphs;\n        let graphItem, subjects, predicates;\n        if (!(subject = subject && this._termToNumericId(subject)) || !(predicate = predicate && this._termToNumericId(predicate)) || !(object = object && this._termToNumericId(object)) || !(graphItem = graphs[graph]) || !(subjects = graphItem.subjects[subject]) || !(predicates = subjects[predicate]) || !(object in predicates)) return false;\n        // Remove it from all indexes\n        this._removeFromIndex(graphItem.subjects, subject, predicate, object);\n        this._removeFromIndex(graphItem.predicates, predicate, object, subject);\n        this._removeFromIndex(graphItem.objects, object, subject, predicate);\n        if (this._size !== null) this._size--;\n        // Remove the graph if it is empty\n        for(subject in graphItem.subjects)return true;\n        delete graphs[graph];\n        return true;\n    }\n    // ### `removeQuads` removes multiple quads from the store\n    removeQuads(quads) {\n        for(let i = 0; i < quads.length; i++)this.removeQuad(quads[i]);\n    }\n    // ### `remove` removes a stream of quads from the store\n    remove(stream) {\n        stream.on('data', (quad)=>{\n            this.removeQuad(quad);\n        });\n        return stream;\n    }\n    // ### `removeMatches` removes all matching quads from the store\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n    removeMatches(subject, predicate, object, graph) {\n        const stream = new (0, $3450dab365fe3575$exports.Readable)({\n            objectMode: true\n        });\n        const iterable = this.readQuads(subject, predicate, object, graph);\n        stream._read = (size)=>{\n            while(--size >= 0){\n                const { done: done, value: value } = iterable.next();\n                if (done) {\n                    stream.push(null);\n                    return;\n                }\n                stream.push(value);\n            }\n        };\n        return this.remove(stream);\n    }\n    // ### `deleteGraph` removes all triples with the given graph from the store\n    deleteGraph(graph) {\n        return this.removeMatches(null, null, null, graph);\n    }\n    // ### `getQuads` returns an array of quads matching a pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n    getQuads(subject, predicate, object, graph) {\n        return [\n            ...this.readQuads(subject, predicate, object, graph)\n        ];\n    }\n    /**\n   * `readQuads` returns a generator of quads matching a pattern.\n   * Setting any field to `undefined` or `null` indicates a wildcard.\n   * @deprecated Use `match` instead.\n   */ *readQuads(subject, predicate, object, graph) {\n        const graphs = this._getGraphs(graph);\n        let content, subjectId, predicateId, objectId;\n        // Translate IRIs to internal index keys.\n        if (subject && !(subjectId = this._termToNumericId(subject)) || predicate && !(predicateId = this._termToNumericId(predicate)) || object && !(objectId = this._termToNumericId(object))) return;\n        for(const graphId in graphs)// Only if the specified graph contains triples, there can be results\n        if (content = graphs[graphId]) {\n            // Choose the optimal index, based on what fields are present\n            if (subjectId) {\n                if (objectId) // If subject and object are given, the object index will be the fastest\n                yield* this._findInIndex(content.objects, objectId, subjectId, predicateId, 'object', 'subject', 'predicate', graphId);\n                else // If only subject and possibly predicate are given, the subject index will be the fastest\n                yield* this._findInIndex(content.subjects, subjectId, predicateId, null, 'subject', 'predicate', 'object', graphId);\n            } else if (predicateId) // If only predicate and possibly object are given, the predicate index will be the fastest\n            yield* this._findInIndex(content.predicates, predicateId, objectId, null, 'predicate', 'object', 'subject', graphId);\n            else if (objectId) // If only object is given, the object index will be the fastest\n            yield* this._findInIndex(content.objects, objectId, null, null, 'object', 'subject', 'predicate', graphId);\n            else // If nothing is given, iterate subjects and predicates first\n            yield* this._findInIndex(content.subjects, null, null, null, 'subject', 'predicate', 'object', graphId);\n        }\n    }\n    // ### `match` returns a new dataset that is comprised of all quads in the current instance matching the given arguments.\n    // The logic described in Quad Matching is applied for each quad in this dataset to check if it should be included in the output dataset.\n    // Note: This method always returns a new DatasetCore, even if that dataset contains no quads.\n    // Note: Since a DatasetCore is an unordered set, the order of the quads within the returned sequence is arbitrary.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n    // For backwards compatibility, the object return also implements the Readable stream interface.\n    match(subject, predicate, object, graph) {\n        return new $36d531372a4b28ea$var$DatasetCoreAndReadableStream(this, subject, predicate, object, graph, {\n            entityIndex: this._entityIndex\n        });\n    }\n    // ### `countQuads` returns the number of quads matching a pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n    countQuads(subject, predicate, object, graph) {\n        const graphs = this._getGraphs(graph);\n        let count = 0, content, subjectId, predicateId, objectId;\n        // Translate IRIs to internal index keys.\n        if (subject && !(subjectId = this._termToNumericId(subject)) || predicate && !(predicateId = this._termToNumericId(predicate)) || object && !(objectId = this._termToNumericId(object))) return 0;\n        for(const graphId in graphs)// Only if the specified graph contains triples, there can be results\n        if (content = graphs[graphId]) {\n            // Choose the optimal index, based on what fields are present\n            if (subject) {\n                if (object) // If subject and object are given, the object index will be the fastest\n                count += this._countInIndex(content.objects, objectId, subjectId, predicateId);\n                else // If only subject and possibly predicate are given, the subject index will be the fastest\n                count += this._countInIndex(content.subjects, subjectId, predicateId, objectId);\n            } else if (predicate) // If only predicate and possibly object are given, the predicate index will be the fastest\n            count += this._countInIndex(content.predicates, predicateId, objectId, subjectId);\n            else // If only object is possibly given, the object index will be the fastest\n            count += this._countInIndex(content.objects, objectId, subjectId, predicateId);\n        }\n        return count;\n    }\n    // ### `forEach` executes the callback on all quads.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n    forEach(callback, subject, predicate, object, graph) {\n        this.some((quad)=>{\n            callback(quad, this);\n            return false;\n        }, subject, predicate, object, graph);\n    }\n    // ### `every` executes the callback on all quads,\n    // and returns `true` if it returns truthy for all them.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n    every(callback, subject, predicate, object, graph) {\n        return !this.some((quad)=>!callback(quad, this), subject, predicate, object, graph);\n    }\n    // ### `some` executes the callback on all quads,\n    // and returns `true` if it returns truthy for any of them.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n    some(callback, subject, predicate, object, graph) {\n        for (const quad of this.readQuads(subject, predicate, object, graph))if (callback(quad, this)) return true;\n        return false;\n    }\n    // ### `getSubjects` returns all subjects that match the pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n    getSubjects(predicate, object, graph) {\n        const results = [];\n        this.forSubjects((s)=>{\n            results.push(s);\n        }, predicate, object, graph);\n        return results;\n    }\n    // ### `forSubjects` executes the callback on all subjects that match the pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n    forSubjects(callback, predicate, object, graph) {\n        const graphs = this._getGraphs(graph);\n        let content, predicateId, objectId;\n        callback = this._uniqueEntities(callback);\n        // Translate IRIs to internal index keys.\n        if (predicate && !(predicateId = this._termToNumericId(predicate)) || object && !(objectId = this._termToNumericId(object))) return;\n        for(graph in graphs)// Only if the specified graph contains triples, there can be results\n        if (content = graphs[graph]) {\n            // Choose optimal index based on which fields are wildcards\n            if (predicateId) {\n                if (objectId) // If predicate and object are given, the POS index is best.\n                this._loopBy2Keys(content.predicates, predicateId, objectId, callback);\n                else // If only predicate is given, the SPO index is best.\n                this._loopByKey1(content.subjects, predicateId, callback);\n            } else if (objectId) // If only object is given, the OSP index is best.\n            this._loopByKey0(content.objects, objectId, callback);\n            else // If no params given, iterate all the subjects\n            this._loop(content.subjects, callback);\n        }\n    }\n    // ### `getPredicates` returns all predicates that match the pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n    getPredicates(subject, object, graph) {\n        const results = [];\n        this.forPredicates((p)=>{\n            results.push(p);\n        }, subject, object, graph);\n        return results;\n    }\n    // ### `forPredicates` executes the callback on all predicates that match the pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n    forPredicates(callback, subject, object, graph) {\n        const graphs = this._getGraphs(graph);\n        let content, subjectId, objectId;\n        callback = this._uniqueEntities(callback);\n        // Translate IRIs to internal index keys.\n        if (subject && !(subjectId = this._termToNumericId(subject)) || object && !(objectId = this._termToNumericId(object))) return;\n        for(graph in graphs)// Only if the specified graph contains triples, there can be results\n        if (content = graphs[graph]) {\n            // Choose optimal index based on which fields are wildcards\n            if (subjectId) {\n                if (objectId) // If subject and object are given, the OSP index is best.\n                this._loopBy2Keys(content.objects, objectId, subjectId, callback);\n                else // If only subject is given, the SPO index is best.\n                this._loopByKey0(content.subjects, subjectId, callback);\n            } else if (objectId) // If only object is given, the POS index is best.\n            this._loopByKey1(content.predicates, objectId, callback);\n            else // If no params given, iterate all the predicates.\n            this._loop(content.predicates, callback);\n        }\n    }\n    // ### `getObjects` returns all objects that match the pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n    getObjects(subject, predicate, graph) {\n        const results = [];\n        this.forObjects((o)=>{\n            results.push(o);\n        }, subject, predicate, graph);\n        return results;\n    }\n    // ### `forObjects` executes the callback on all objects that match the pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n    forObjects(callback, subject, predicate, graph) {\n        const graphs = this._getGraphs(graph);\n        let content, subjectId, predicateId;\n        callback = this._uniqueEntities(callback);\n        // Translate IRIs to internal index keys.\n        if (subject && !(subjectId = this._termToNumericId(subject)) || predicate && !(predicateId = this._termToNumericId(predicate))) return;\n        for(graph in graphs)// Only if the specified graph contains triples, there can be results\n        if (content = graphs[graph]) {\n            // Choose optimal index based on which fields are wildcards\n            if (subjectId) {\n                if (predicateId) // If subject and predicate are given, the SPO index is best.\n                this._loopBy2Keys(content.subjects, subjectId, predicateId, callback);\n                else // If only subject is given, the OSP index is best.\n                this._loopByKey1(content.objects, subjectId, callback);\n            } else if (predicateId) // If only predicate is given, the POS index is best.\n            this._loopByKey0(content.predicates, predicateId, callback);\n            else // If no params given, iterate all the objects.\n            this._loop(content.objects, callback);\n        }\n    }\n    // ### `getGraphs` returns all graphs that match the pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n    getGraphs(subject, predicate, object) {\n        const results = [];\n        this.forGraphs((g)=>{\n            results.push(g);\n        }, subject, predicate, object);\n        return results;\n    }\n    // ### `forGraphs` executes the callback on all graphs that match the pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n    forGraphs(callback, subject, predicate, object) {\n        for(const graph in this._graphs)this.some((quad)=>{\n            callback(quad.graph);\n            return true; // Halt iteration of some()\n        }, subject, predicate, object, this._termFromId(this._entities[graph]));\n    }\n    // ### `createBlankNode` creates a new blank node, returning its name\n    createBlankNode(suggestedName) {\n        return this._entityIndex.createBlankNode(suggestedName);\n    }\n    // ### `extractLists` finds and removes all list triples\n    // and returns the items per list.\n    extractLists({ remove: remove = false, ignoreErrors: ignoreErrors = false } = {}) {\n        const lists = {}; // has scalar keys so could be a simple Object\n        const onError = ignoreErrors ? ()=>true : (node, message)=>{\n            throw new Error(`${node.value} ${message}`);\n        };\n        // Traverse each list from its tail\n        const tails = this.getQuads(null, (0, $09690bd0f6e8ba27$export$2e2bcd8739ae039).rdf.rest, (0, $09690bd0f6e8ba27$export$2e2bcd8739ae039).rdf.nil, null);\n        const toRemove = remove ? [\n            ...tails\n        ] : [];\n        tails.forEach((tailQuad)=>{\n            const items = []; // the members found as objects of rdf:first quads\n            let malformed = false; // signals whether the current list is malformed\n            let head; // the head of the list (_:b1 in above example)\n            let headPos; // set to subject or object when head is set\n            const graph = tailQuad.graph; // make sure list is in exactly one graph\n            // Traverse the list from tail to end\n            let current = tailQuad.subject;\n            while(current && !malformed){\n                const objectQuads = this.getQuads(null, null, current, null);\n                const subjectQuads = this.getQuads(current, null, null, null);\n                let quad, first = null, rest = null, parent = null;\n                // Find the first and rest of this list node\n                for(let i = 0; i < subjectQuads.length && !malformed; i++){\n                    quad = subjectQuads[i];\n                    if (!quad.graph.equals(graph)) malformed = onError(current, 'not confined to single graph');\n                    else if (head) malformed = onError(current, 'has non-list arcs out');\n                    else if (quad.predicate.value === (0, $09690bd0f6e8ba27$export$2e2bcd8739ae039).rdf.first) {\n                        if (first) malformed = onError(current, 'has multiple rdf:first arcs');\n                        else toRemove.push(first = quad);\n                    } else if (quad.predicate.value === (0, $09690bd0f6e8ba27$export$2e2bcd8739ae039).rdf.rest) {\n                        if (rest) malformed = onError(current, 'has multiple rdf:rest arcs');\n                        else toRemove.push(rest = quad);\n                    } else if (objectQuads.length) malformed = onError(current, 'can\\'t be subject and object');\n                    else {\n                        head = quad; // e.g. { (1 2 3) :p :o }\n                        headPos = 'subject';\n                    }\n                }\n                // { :s :p (1 2) } arrives here with no head\n                // { (1 2) :p :o } arrives here with head set to the list.\n                for(let i = 0; i < objectQuads.length && !malformed; ++i){\n                    quad = objectQuads[i];\n                    if (head) malformed = onError(current, 'can\\'t have coreferences');\n                    else if (quad.predicate.value === (0, $09690bd0f6e8ba27$export$2e2bcd8739ae039).rdf.rest) {\n                        if (parent) malformed = onError(current, 'has incoming rdf:rest arcs');\n                        else parent = quad;\n                    } else {\n                        head = quad; // e.g. { :s :p (1 2) }\n                        headPos = 'object';\n                    }\n                }\n                // Store the list item and continue with parent\n                if (!first) malformed = onError(current, 'has no list head');\n                else items.unshift(first.object);\n                current = parent && parent.subject;\n            }\n            // Don't remove any quads if the list is malformed\n            if (malformed) remove = false;\n            else if (head) lists[head[headPos].value] = items;\n        });\n        // Remove list quads if requested\n        if (remove) this.removeQuads(toRemove);\n        return lists;\n    }\n    /**\n   * Returns `true` if the current dataset is a superset of the given dataset; in other words, returns `true` if\n   * the given dataset is a subset of, i.e., is contained within, the current dataset.\n   *\n   * Blank Nodes will be normalized.\n   */ addAll(quads) {\n        if (quads instanceof $36d531372a4b28ea$var$DatasetCoreAndReadableStream) quads = quads.filtered;\n        if (Array.isArray(quads)) this.addQuads(quads);\n        else if (quads instanceof $36d531372a4b28ea$export$2e2bcd8739ae039 && quads._entityIndex === this._entityIndex) {\n            if (quads._size !== 0) {\n                this._graphs = $36d531372a4b28ea$var$merge(this._graphs, quads._graphs);\n                this._size = null; // Invalidate the cached size\n            }\n        } else for (const quad of quads)this.add(quad);\n        return this;\n    }\n    /**\n   * Returns `true` if the current dataset is a superset of the given dataset; in other words, returns `true` if\n   * the given dataset is a subset of, i.e., is contained within, the current dataset.\n   *\n   * Blank Nodes will be normalized.\n   */ contains(other) {\n        if (other instanceof $36d531372a4b28ea$var$DatasetCoreAndReadableStream) other = other.filtered;\n        if (other === this) return true;\n        if (!(other instanceof $36d531372a4b28ea$export$2e2bcd8739ae039) || this._entityIndex !== other._entityIndex) return other.every((quad)=>this.has(quad));\n        const g1 = this._graphs, g2 = other._graphs;\n        let s1, s2, p1, p2, o1;\n        for(const graph in g2){\n            if (!(s1 = g1[graph])) return false;\n            s1 = s1.subjects;\n            for(const subject in s2 = g2[graph].subjects){\n                if (!(p1 = s1[subject])) return false;\n                for(const predicate in p2 = s2[subject]){\n                    if (!(o1 = p1[predicate])) return false;\n                    for(const object in p2[predicate])if (!(object in o1)) return false;\n                }\n            }\n        }\n        return true;\n    }\n    /**\n   * This method removes the quads in the current dataset that match the given arguments.\n   *\n   * The logic described in {@link https://rdf.js.org/dataset-spec/#quad-matching|Quad Matching} is applied for each\n   * quad in this dataset, to select the quads which will be deleted.\n   *\n   * @param subject   The optional exact subject to match.\n   * @param predicate The optional exact predicate to match.\n   * @param object    The optional exact object to match.\n   * @param graph     The optional exact graph to match.\n   */ deleteMatches(subject, predicate, object, graph) {\n        for (const quad of this.match(subject, predicate, object, graph))this.removeQuad(quad);\n        return this;\n    }\n    /**\n   * Returns a new dataset that contains all quads from the current dataset that are not included in the given dataset.\n   */ difference(other) {\n        if (other && other instanceof $36d531372a4b28ea$var$DatasetCoreAndReadableStream) other = other.filtered;\n        if (other === this) return new $36d531372a4b28ea$export$2e2bcd8739ae039({\n            entityIndex: this._entityIndex\n        });\n        if (other instanceof $36d531372a4b28ea$export$2e2bcd8739ae039 && other._entityIndex === this._entityIndex) {\n            const store = new $36d531372a4b28ea$export$2e2bcd8739ae039({\n                entityIndex: this._entityIndex\n            });\n            const graphs = $36d531372a4b28ea$var$difference(this._graphs, other._graphs);\n            if (graphs) {\n                store._graphs = graphs;\n                store._size = null;\n            }\n            return store;\n        }\n        return this.filter((quad)=>!other.has(quad));\n    }\n    /**\n   * Returns true if the current dataset contains the same graph structure as the given dataset.\n   *\n   * Blank Nodes will be normalized.\n   */ equals(other) {\n        if (other instanceof $36d531372a4b28ea$var$DatasetCoreAndReadableStream) other = other.filtered;\n        return other === this || this.size === other.size && this.contains(other);\n    }\n    /**\n   * Creates a new dataset with all the quads that pass the test implemented by the provided `iteratee`.\n   *\n   * This method is aligned with Array.prototype.filter() in ECMAScript-262.\n   */ filter(iteratee) {\n        const store = new $36d531372a4b28ea$export$2e2bcd8739ae039({\n            entityIndex: this._entityIndex\n        });\n        for (const quad of this)if (iteratee(quad, this)) store.add(quad);\n        return store;\n    }\n    /**\n   * Returns a new dataset containing all quads from the current dataset that are also included in the given dataset.\n   */ intersection(other) {\n        if (other instanceof $36d531372a4b28ea$var$DatasetCoreAndReadableStream) other = other.filtered;\n        if (other === this) {\n            const store = new $36d531372a4b28ea$export$2e2bcd8739ae039({\n                entityIndex: this._entityIndex\n            });\n            store._graphs = $36d531372a4b28ea$var$merge(Object.create(null), this._graphs);\n            store._size = this._size;\n            return store;\n        } else if (other instanceof $36d531372a4b28ea$export$2e2bcd8739ae039 && this._entityIndex === other._entityIndex) {\n            const store = new $36d531372a4b28ea$export$2e2bcd8739ae039({\n                entityIndex: this._entityIndex\n            });\n            const graphs = $36d531372a4b28ea$var$intersect(other._graphs, this._graphs);\n            if (graphs) {\n                store._graphs = graphs;\n                store._size = null;\n            }\n            return store;\n        }\n        return this.filter((quad)=>other.has(quad));\n    }\n    /**\n   * Returns a new dataset containing all quads returned by applying `iteratee` to each quad in the current dataset.\n   */ map(iteratee) {\n        const store = new $36d531372a4b28ea$export$2e2bcd8739ae039({\n            entityIndex: this._entityIndex\n        });\n        for (const quad of this)store.add(iteratee(quad, this));\n        return store;\n    }\n    /**\n   * This method calls the `iteratee` method on each `quad` of the `Dataset`. The first time the `iteratee` method\n   * is called, the `accumulator` value is the `initialValue`, or, if not given, equals the first quad of the `Dataset`.\n   * The return value of each call to the `iteratee` method is used as the `accumulator` value for the next call.\n   *\n   * This method returns the return value of the last `iteratee` call.\n   *\n   * This method is aligned with `Array.prototype.reduce()` in ECMAScript-262.\n   */ reduce(callback, initialValue) {\n        const iter = this.readQuads();\n        let accumulator = initialValue === undefined ? iter.next().value : initialValue;\n        for (const quad of iter)accumulator = callback(accumulator, quad, this);\n        return accumulator;\n    }\n    /**\n   * Returns the set of quads within the dataset as a host-language-native sequence, for example an `Array` in\n   * ECMAScript-262.\n   *\n   * Since a `Dataset` is an unordered set, the order of the quads within the returned sequence is arbitrary.\n   */ toArray() {\n        return this.getQuads();\n    }\n    /**\n   * Returns an N-Quads string representation of the dataset, preprocessed with the\n   * {@link https://json-ld.github.io/normalization/spec/|RDF Dataset Normalization} algorithm.\n   */ toCanonical() {\n        throw new Error('not implemented');\n    }\n    /**\n   * Returns a stream that contains all quads of the dataset.\n   */ toStream() {\n        return this.match();\n    }\n    /**\n   * Returns an N-Quads string representation of the dataset.\n   *\n   * No prior normalization is required, therefore the results for the same quads may vary depending on the `Dataset`\n   * implementation.\n   */ toString() {\n        return new (0, $33fd654882eefc25$export$2e2bcd8739ae039)().quadsToString(this);\n    }\n    /**\n   * Returns a new `Dataset` that is a concatenation of this dataset and the quads given as an argument.\n   */ union(quads) {\n        const store = new $36d531372a4b28ea$export$2e2bcd8739ae039({\n            entityIndex: this._entityIndex\n        });\n        store._graphs = $36d531372a4b28ea$var$merge(Object.create(null), this._graphs);\n        store._size = this._size;\n        store.addAll(quads);\n        return store;\n    }\n    // ### Store is an iterable.\n    // Can be used where iterables are expected: for...of loops, array spread operator,\n    // `yield*`, and destructuring assignment (order is not guaranteed).\n    *[Symbol.iterator]() {\n        yield* this.readQuads();\n    }\n}\n/**\n * Returns a subset of the `index` with that part of the index\n * matching the `ids` array. `ids` contains 3 elements that are\n * either numerical ids; or `null`.\n *\n * `false` is returned when there are no matching indices; this should\n * *not* be set as the value for an index.\n */ function $36d531372a4b28ea$var$indexMatch(index, ids, depth = 0) {\n    const ind = ids[depth];\n    if (ind && !(ind in index)) return false;\n    let target = false;\n    for(const key in ind ? {\n        [ind]: index[ind]\n    } : index){\n        const result = depth === 2 ? null : $36d531372a4b28ea$var$indexMatch(index[key], ids, depth + 1);\n        if (result !== false) {\n            target = target || Object.create(null);\n            target[key] = result;\n        }\n    }\n    return target;\n}\n/**\n * A class that implements both DatasetCore and Readable.\n */ class $36d531372a4b28ea$var$DatasetCoreAndReadableStream extends (0, $3450dab365fe3575$exports.Readable) {\n    constructor(n3Store, subject, predicate, object, graph, options){\n        super({\n            objectMode: true\n        });\n        Object.assign(this, {\n            n3Store: n3Store,\n            subject: subject,\n            predicate: predicate,\n            object: object,\n            graph: graph,\n            options: options\n        });\n    }\n    get filtered() {\n        if (!this._filtered) {\n            const { n3Store: n3Store, graph: graph, object: object, predicate: predicate, subject: subject } = this;\n            const newStore = this._filtered = new $36d531372a4b28ea$export$2e2bcd8739ae039({\n                factory: n3Store._factory,\n                entityIndex: this.options.entityIndex\n            });\n            let subjectId, predicateId, objectId;\n            // Translate IRIs to internal index keys.\n            if (subject && !(subjectId = newStore._termToNumericId(subject)) || predicate && !(predicateId = newStore._termToNumericId(predicate)) || object && !(objectId = newStore._termToNumericId(object))) return newStore;\n            const graphs = n3Store._getGraphs(graph);\n            for(const graphKey in graphs){\n                let subjects, predicates, objects, content;\n                if (content = graphs[graphKey]) {\n                    if (!subjectId && predicateId) {\n                        if (predicates = $36d531372a4b28ea$var$indexMatch(content.predicates, [\n                            predicateId,\n                            objectId,\n                            subjectId\n                        ])) {\n                            subjects = $36d531372a4b28ea$var$indexMatch(content.subjects, [\n                                subjectId,\n                                predicateId,\n                                objectId\n                            ]);\n                            objects = $36d531372a4b28ea$var$indexMatch(content.objects, [\n                                objectId,\n                                subjectId,\n                                predicateId\n                            ]);\n                        }\n                    } else if (objectId) {\n                        if (objects = $36d531372a4b28ea$var$indexMatch(content.objects, [\n                            objectId,\n                            subjectId,\n                            predicateId\n                        ])) {\n                            subjects = $36d531372a4b28ea$var$indexMatch(content.subjects, [\n                                subjectId,\n                                predicateId,\n                                objectId\n                            ]);\n                            predicates = $36d531372a4b28ea$var$indexMatch(content.predicates, [\n                                predicateId,\n                                objectId,\n                                subjectId\n                            ]);\n                        }\n                    } else if (subjects = $36d531372a4b28ea$var$indexMatch(content.subjects, [\n                        subjectId,\n                        predicateId,\n                        objectId\n                    ])) {\n                        predicates = $36d531372a4b28ea$var$indexMatch(content.predicates, [\n                            predicateId,\n                            objectId,\n                            subjectId\n                        ]);\n                        objects = $36d531372a4b28ea$var$indexMatch(content.objects, [\n                            objectId,\n                            subjectId,\n                            predicateId\n                        ]);\n                    }\n                    if (subjects) newStore._graphs[graphKey] = {\n                        subjects: subjects,\n                        predicates: predicates,\n                        objects: objects\n                    };\n                }\n            }\n            newStore._size = null;\n        }\n        return this._filtered;\n    }\n    get size() {\n        return this.filtered.size;\n    }\n    _read(size) {\n        if (size > 0 && !this[$36d531372a4b28ea$var$ITERATOR]) this[$36d531372a4b28ea$var$ITERATOR] = this[Symbol.iterator]();\n        const iterable = this[$36d531372a4b28ea$var$ITERATOR];\n        while(--size >= 0){\n            const { done: done, value: value } = iterable.next();\n            if (done) {\n                this.push(null);\n                return;\n            }\n            this.push(value);\n        }\n    }\n    addAll(quads) {\n        return this.filtered.addAll(quads);\n    }\n    contains(other) {\n        return this.filtered.contains(other);\n    }\n    deleteMatches(subject, predicate, object, graph) {\n        return this.filtered.deleteMatches(subject, predicate, object, graph);\n    }\n    difference(other) {\n        return this.filtered.difference(other);\n    }\n    equals(other) {\n        return this.filtered.equals(other);\n    }\n    every(callback, subject, predicate, object, graph) {\n        return this.filtered.every(callback, subject, predicate, object, graph);\n    }\n    filter(iteratee) {\n        return this.filtered.filter(iteratee);\n    }\n    forEach(callback, subject, predicate, object, graph) {\n        return this.filtered.forEach(callback, subject, predicate, object, graph);\n    }\n    import(stream) {\n        return this.filtered.import(stream);\n    }\n    intersection(other) {\n        return this.filtered.intersection(other);\n    }\n    map(iteratee) {\n        return this.filtered.map(iteratee);\n    }\n    some(callback, subject, predicate, object, graph) {\n        return this.filtered.some(callback, subject, predicate, object, graph);\n    }\n    toCanonical() {\n        return this.filtered.toCanonical();\n    }\n    toStream() {\n        return this._filtered ? this._filtered.toStream() : this.n3Store.match(this.subject, this.predicate, this.object, this.graph);\n    }\n    union(quads) {\n        return this._filtered ? this._filtered.union(quads) : this.n3Store.match(this.subject, this.predicate, this.object, this.graph).addAll(quads);\n    }\n    toArray() {\n        return this._filtered ? this._filtered.toArray() : this.n3Store.getQuads(this.subject, this.predicate, this.object, this.graph);\n    }\n    reduce(callback, initialValue) {\n        return this.filtered.reduce(callback, initialValue);\n    }\n    toString() {\n        return new (0, $33fd654882eefc25$export$2e2bcd8739ae039)().quadsToString(this);\n    }\n    add(quad) {\n        return this.filtered.add(quad);\n    }\n    delete(quad) {\n        return this.filtered.delete(quad);\n    }\n    has(quad) {\n        return this.filtered.has(quad);\n    }\n    match(subject, predicate, object, graph) {\n        return new $36d531372a4b28ea$var$DatasetCoreAndReadableStream(this.filtered, subject, predicate, object, graph, this.options);\n    }\n    *[Symbol.iterator]() {\n        yield* this._filtered || this.n3Store.readQuads(this.subject, this.predicate, this.object, this.graph);\n    }\n}\n\n\n\nclass $4d0027ecfd24bd04$export$2e2bcd8739ae039 {\n    dataset(quads) {\n        return new (0, $36d531372a4b28ea$export$2e2bcd8739ae039)(quads);\n    }\n}\n\n\n\nfunction $def31a84d5beabde$export$d4c7b9e4255161a(dataset) {\n    const rules = [];\n    for (const { subject: subject, object: object } of dataset.match(null, (0, $7b385df8cba0e42c$export$2e2bcd8739ae039).namedNode('http://www.w3.org/2000/10/swap/log#implies'), null, (0, $7b385df8cba0e42c$export$2e2bcd8739ae039).defaultGraph())){\n        const premise = [\n            ...dataset.match(null, null, null, subject)\n        ];\n        const conclusion = [\n            ...dataset.match(null, null, null, object)\n        ];\n        rules.push({\n            premise: premise,\n            conclusion: conclusion\n        });\n    }\n    return rules;\n}\nclass $def31a84d5beabde$export$2e2bcd8739ae039 {\n    constructor(store){\n        this._store = store;\n    }\n    _add(subject, predicate, object, graphItem, cb) {\n        // Only add to the remaining indexes if there is not already a value in the index\n        if (!this._store._addToIndex(graphItem.subjects, subject, predicate, object)) return;\n        this._store._addToIndex(graphItem.predicates, predicate, object, subject);\n        this._store._addToIndex(graphItem.objects, object, subject, predicate);\n        cb();\n    }\n    // eslint-disable-next-line no-warning-comments\n    _evaluatePremise(rule, content, cb, i = 0) {\n        let v1, v2, value, index1, index2;\n        const [val0, val1, val2] = rule.premise[i].value, index = content[rule.premise[i].content];\n        const v0 = !(value = val0.value);\n        for(value in v0 ? index : {\n            [value]: index[value]\n        })if (index1 = index[value]) {\n            if (v0) val0.value = Number(value);\n            v1 = !(value = val1.value);\n            for(value in v1 ? index1 : {\n                [value]: index1[value]\n            })if (index2 = index1[value]) {\n                if (v1) val1.value = Number(value);\n                v2 = !(value = val2.value);\n                for(value in v2 ? index2 : {\n                    [value]: index2[value]\n                }){\n                    if (v2) val2.value = Number(value);\n                    if (i === rule.premise.length - 1) rule.conclusion.forEach((c)=>{\n                        // eslint-disable-next-line max-nested-callbacks\n                        this._add(c.subject.value, c.predicate.value, c.object.value, content, ()=>{\n                            cb(c);\n                        });\n                    });\n                    else this._evaluatePremise(rule, content, cb, i + 1);\n                }\n                if (v2) val2.value = null;\n            }\n            if (v1) val1.value = null;\n        }\n        if (v0) val0.value = null;\n    }\n    _evaluateRules(rules, content, cb) {\n        for(let i = 0; i < rules.length; i++)this._evaluatePremise(rules[i], content, cb);\n    }\n    // A naive reasoning algorithm where rules are just applied by repeatedly applying rules\n    // until no more evaluations are made\n    _reasonGraphNaive(rules, content) {\n        const newRules = [];\n        function addRule(conclusion) {\n            if (conclusion.next) conclusion.next.forEach((rule)=>{\n                newRules.push([\n                    conclusion.subject.value,\n                    conclusion.predicate.value,\n                    conclusion.object.value,\n                    rule\n                ]);\n            });\n        }\n        // eslint-disable-next-line func-style\n        const addConclusions = (conclusion)=>{\n            conclusion.forEach((c)=>{\n                // eslint-disable-next-line max-nested-callbacks\n                this._add(c.subject.value, c.predicate.value, c.object.value, content, ()=>{\n                    addRule(c);\n                });\n            });\n        };\n        this._evaluateRules(rules, content, addRule);\n        let r;\n        while((r = newRules.pop()) !== undefined){\n            const [subject, predicate, object, rule] = r;\n            const v1 = rule.basePremise.subject.value;\n            if (!v1) rule.basePremise.subject.value = subject;\n            const v2 = rule.basePremise.predicate.value;\n            if (!v2) rule.basePremise.predicate.value = predicate;\n            const v3 = rule.basePremise.object.value;\n            if (!v3) rule.basePremise.object.value = object;\n            if (rule.premise.length === 0) addConclusions(rule.conclusion);\n            else this._evaluatePremise(rule, content, addRule);\n            if (!v1) rule.basePremise.subject.value = null;\n            if (!v2) rule.basePremise.predicate.value = null;\n            if (!v3) rule.basePremise.object.value = null;\n        }\n    }\n    _createRule({ premise: premise, conclusion: conclusion }) {\n        const varMapping = {};\n        const toId = (value)=>value.termType === 'Variable' ? // If the term is a variable, then create an empty object that values can be placed into\n            varMapping[value.value] = varMapping[value.value] || {} : // If the term is not a variable, then set the ID value\n            {\n                value: this._store._termToNewNumericId(value)\n            };\n        // eslint-disable-next-line func-style\n        const t = (term)=>({\n                subject: toId(term.subject),\n                predicate: toId(term.predicate),\n                object: toId(term.object)\n            });\n        return {\n            premise: premise.map((p)=>t(p)),\n            conclusion: conclusion.map((p)=>t(p)),\n            variables: Object.values(varMapping)\n        };\n    }\n    reason(rules) {\n        if (!Array.isArray(rules)) rules = $def31a84d5beabde$export$d4c7b9e4255161a(rules);\n        rules = rules.map((rule)=>this._createRule(rule));\n        for (const r1 of rules){\n            for (const r2 of rules)for(let i = 0; i < r2.premise.length; i++){\n                const p = r2.premise[i];\n                for (const c of r1.conclusion){\n                    if ($def31a84d5beabde$var$termEq(p.subject, c.subject) && $def31a84d5beabde$var$termEq(p.predicate, c.predicate) && $def31a84d5beabde$var$termEq(p.object, c.object)) {\n                        const set = new Set();\n                        const premise = [];\n                        // Since these *will* be substituted when we apply the rule,\n                        // we need to do this, so that we index correctly in the subsequent section\n                        p.subject.value = p.subject.value || 1;\n                        p.object.value = p.object.value || 1;\n                        p.predicate.value = p.predicate.value || 1;\n                        for(let j = 0; j < r2.premise.length; j++)if (j !== i) premise.push($def31a84d5beabde$var$getIndex(r2.premise[j], set));\n                        // eslint-disable-next-line no-warning-comments\n                        // TODO: Create new rule, with new indexing\n                        //       Future, 'collapse' the next statements when they share a premise/base-premise\n                        (c.next = c.next || []).push({\n                            premise: premise,\n                            conclusion: r2.conclusion,\n                            // This is a single premise of the form { subject, predicate, object },\n                            // which we can use to instantiate the rule using the new data that was emitted\n                            basePremise: p\n                        });\n                    }\n                    r2.variables.forEach((v)=>{\n                        v.value = null;\n                    });\n                }\n            }\n        }\n        for (const rule of rules){\n            const set = new Set();\n            rule.premise = rule.premise.map((p)=>$def31a84d5beabde$var$getIndex(p, set));\n        }\n        const graphs = this._store._getGraphs();\n        for(const graphId in graphs)this._reasonGraphNaive(rules, graphs[graphId]);\n        this._store._size = null;\n    }\n}\nfunction $def31a84d5beabde$var$getIndex({ subject: subject, predicate: predicate, object: object }, set) {\n    const s = subject.value || set.has(subject) || (set.add(subject), false);\n    const p = predicate.value || set.has(predicate) || (set.add(predicate), false);\n    const o = object.value || set.has(object) || (set.add(object), false);\n    return !s && p ? {\n        content: 'predicates',\n        value: [\n            predicate,\n            object,\n            subject\n        ]\n    } : o ? {\n        content: 'objects',\n        value: [\n            object,\n            subject,\n            predicate\n        ]\n    } : {\n        content: 'subjects',\n        value: [\n            subject,\n            predicate,\n            object\n        ]\n    };\n}\nfunction $def31a84d5beabde$var$termEq(t1, t2) {\n    if (t1.value === null) t1.value = t2.value;\n    return t1.value === t2.value;\n}\n\n\n// **N3StreamParser** parses a text stream into a quad stream.\n\n\nclass $10e0b72da560a634$export$2e2bcd8739ae039 extends (0, $3450dab365fe3575$exports.Transform) {\n    constructor(options){\n        super({\n            decodeStrings: true\n        });\n        this._readableState.objectMode = true;\n        // Set up parser with dummy stream to obtain `data` and `end` callbacks\n        const parser = new (0, $bcb493474cb21cf3$export$2e2bcd8739ae039)(options);\n        let onData, onEnd;\n        const callbacks = {\n            // Handle quads by pushing them down the pipeline\n            onQuad: (error, quad)=>{\n                error && this.emit('error', error) || quad && this.push(quad);\n            },\n            // Emit prefixes through the `prefix` event\n            onPrefix: (prefix, uri)=>{\n                this.emit('prefix', prefix, uri);\n            }\n        };\n        if (options && options.comments) callbacks.onComment = (comment)=>{\n            this.emit('comment', comment);\n        };\n        parser.parse({\n            on: (event, callback)=>{\n                switch(event){\n                    case 'data':\n                        onData = callback;\n                        break;\n                    case 'end':\n                        onEnd = callback;\n                        break;\n                }\n            }\n        }, callbacks);\n        // Implement Transform methods through parser callbacks\n        this._transform = (chunk, encoding, done)=>{\n            onData(chunk);\n            done();\n        };\n        this._flush = (done)=>{\n            onEnd();\n            done();\n        };\n    }\n    // ### Parses a stream of strings\n    import(stream) {\n        stream.on('data', (chunk)=>{\n            this.write(chunk);\n        });\n        stream.on('end', ()=>{\n            this.end();\n        });\n        stream.on('error', (error)=>{\n            this.emit('error', error);\n        });\n        return this;\n    }\n}\n\n\n// **N3StreamWriter** serializes a quad stream into a text stream.\n\n\nclass $20ba4d3d17382691$export$2e2bcd8739ae039 extends (0, $3450dab365fe3575$exports.Transform) {\n    constructor(options){\n        super({\n            encoding: 'utf8',\n            writableObjectMode: true\n        });\n        // Set up writer with a dummy stream object\n        const writer = this._writer = new (0, $33fd654882eefc25$export$2e2bcd8739ae039)({\n            write: (quad, encoding, callback)=>{\n                this.push(quad);\n                callback && callback();\n            },\n            end: (callback)=>{\n                this.push(null);\n                callback && callback();\n            }\n        }, options);\n        // Implement Transform methods on top of writer\n        this._transform = (quad, encoding, done)=>{\n            writer.addQuad(quad, done);\n        };\n        this._flush = (done)=>{\n            writer.end(done);\n        };\n    }\n    // ### Serializes a stream of quads\n    import(stream) {\n        stream.on('data', (quad)=>{\n            this.write(quad);\n        });\n        stream.on('end', ()=>{\n            this.end();\n        });\n        stream.on('error', (error)=>{\n            this.emit('error', error);\n        });\n        stream.on('prefix', (prefix, iri)=>{\n            this._writer.addPrefix(prefix, iri);\n        });\n        return this;\n    }\n}\n\n\n\n\n\nvar // Export all named exports as a default object for backward compatibility\n$858c50017c7e043d$export$2e2bcd8739ae039 = {\n    Lexer: $ddaccca9a53aa58d$export$2e2bcd8739ae039,\n    Parser: $bcb493474cb21cf3$export$2e2bcd8739ae039,\n    Writer: $33fd654882eefc25$export$2e2bcd8739ae039,\n    Store: $36d531372a4b28ea$export$2e2bcd8739ae039,\n    StoreFactory: $4d0027ecfd24bd04$export$2e2bcd8739ae039,\n    EntityIndex: $36d531372a4b28ea$export$4e0df93146cafeaf,\n    StreamParser: $10e0b72da560a634$export$2e2bcd8739ae039,\n    StreamWriter: $20ba4d3d17382691$export$2e2bcd8739ae039,\n    Util: $d6cb6627f0e6b6dd$exports,\n    Reasoner: $def31a84d5beabde$export$2e2bcd8739ae039,\n    BaseIRI: $10447076e5190544$export$2e2bcd8739ae039,\n    DataFactory: $7b385df8cba0e42c$export$2e2bcd8739ae039,\n    Term: $7b385df8cba0e42c$export$656c1e606ad06131,\n    NamedNode: $7b385df8cba0e42c$export$e55689a56c4c92c2,\n    Literal: $7b385df8cba0e42c$export$e175ae9e414693bc,\n    BlankNode: $7b385df8cba0e42c$export$1a8019c085269883,\n    Variable: $7b385df8cba0e42c$export$c867a5c9595a1350,\n    DefaultGraph: $7b385df8cba0e42c$export$4383f89a7161b240,\n    Quad: $7b385df8cba0e42c$export$7005c9eb6671414d,\n    Triple: $7b385df8cba0e42c$export$7005c9eb6671414d,\n    termFromId: $7b385df8cba0e42c$export$85285e91bbd99cf,\n    termToId: $7b385df8cba0e42c$export$fbf03d1179c9227e\n};\n\n\nvar $b364f2cd2faf3e98$exports = {};\n\"use strict\";\n\n\nvar $8fdc4695a8dd62cf$require$fs = $b364f2cd2faf3e98$exports.promises;\nconst { DataFactory: $8fdc4695a8dd62cf$var$DataFactory } = $858c50017c7e043d$exports;\nconst { namedNode: $8fdc4695a8dd62cf$var$namedNode, literal: $8fdc4695a8dd62cf$var$literal } = $8fdc4695a8dd62cf$var$DataFactory;\nasync function $8fdc4695a8dd62cf$var$convertTtlToJson(inputFile, outputFile) {\n    const parser = new $858c50017c7e043d$exports.Parser();\n    const store = new $858c50017c7e043d$exports.Store();\n    const shapes = {};\n    const ttlData = await $8fdc4695a8dd62cf$require$fs.readFile(inputFile, 'utf8');\n    await new Promise((resolve, reject)=>{\n        parser.parse(ttlData, (error, quad, prefixes)=>{\n            if (error) return reject(error);\n            if (quad) store.addQuad(quad);\n            else resolve();\n        });\n    });\n    // Извлекаем NodeShape\n    store.getQuads(null, $8fdc4695a8dd62cf$var$namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'), $8fdc4695a8dd62cf$var$namedNode('http://www.w3.org/ns/shacl#NodeShape')).forEach((quad)=>{\n        const shapeId = quad.subject.value;\n        shapes[shapeId] = {\n            id: shapeId,\n            targetClass: null,\n            properties: []\n        };\n    });\n    // Извлекаем targetClass\n    store.getQuads(null, $8fdc4695a8dd62cf$var$namedNode('http://www.w3.org/ns/shacl#targetClass'), null).forEach((quad)=>{\n        if (shapes[quad.subject.value]) shapes[quad.subject.value].targetClass = quad.object.value;\n    });\n    // Извлекаем свойства\n    store.getQuads(null, $8fdc4695a8dd62cf$var$namedNode('http://www.w3.org/ns/shacl#property'), null).forEach((quad)=>{\n        const shapeId = quad.subject.value;\n        if (shapes[shapeId]) shapes[shapeId].properties.push({\n            propertyId: quad.object.value\n        });\n    });\n    // Извлекаем детали свойств\n    for (const shape of Object.values(shapes))for (const prop of shape.properties){\n        const propQuads = store.getQuads($8fdc4695a8dd62cf$var$namedNode(prop.propertyId), null, null);\n        prop.path = store.getQuads($8fdc4695a8dd62cf$var$namedNode(prop.propertyId), $8fdc4695a8dd62cf$var$namedNode('http://www.w3.org/ns/shacl#path'), null)[0]?.object.value;\n        prop.minCount = store.getQuads($8fdc4695a8dd62cf$var$namedNode(prop.propertyId), $8fdc4695a8dd62cf$var$namedNode('http://www.w3.org/ns/shacl#minCount'), null)[0]?.object.value;\n        prop.nodeKind = store.getQuads($8fdc4695a8dd62cf$var$namedNode(prop.propertyId), $8fdc4695a8dd62cf$var$namedNode('http://www.w3.org/ns/shacl#nodeKind'), null)[0]?.object.value;\n        prop.datatype = store.getQuads($8fdc4695a8dd62cf$var$namedNode(prop.propertyId), $8fdc4695a8dd62cf$var$namedNode('http://www.w3.org/ns/shacl#datatype'), null)[0]?.object.value;\n        prop.class = store.getQuads($8fdc4695a8dd62cf$var$namedNode(prop.propertyId), $8fdc4695a8dd62cf$var$namedNode('http://www.w3.org/ns/shacl#class'), null)[0]?.object.value;\n        // Обработка sh:or\n        const orQuads = store.getQuads($8fdc4695a8dd62cf$var$namedNode(prop.propertyId), $8fdc4695a8dd62cf$var$namedNode('http://www.w3.org/ns/shacl#or'), null);\n        if (orQuads.length > 0) {\n            prop.or = [];\n            const orList = store.getQuads(orQuads[0].object, null, null);\n            orList.forEach((orItem)=>{\n                const orNode = orItem.object;\n                const orDetails = store.getQuads(orNode, null, null);\n                const orProp = {};\n                orDetails.forEach((detail)=>{\n                    if (detail.predicate.value === 'http://www.w3.org/ns/shacl#nodeKind') orProp.nodeKind = detail.object.value;\n                    if (detail.predicate.value === 'http://www.w3.org/ns/shacl#datatype') orProp.datatype = detail.object.value;\n                });\n                prop.or.push(orProp);\n            });\n        }\n    }\n    // Формируем итоговый JSON\n    const jsonOutput = {\n        shapes: Object.values(shapes)\n    };\n    await $8fdc4695a8dd62cf$require$fs.writeFile(outputFile, JSON.stringify(jsonOutput, null, 2));\n    console.log('JSON saved to', outputFile);\n}\n$8fdc4695a8dd62cf$var$convertTtlToJson('/mnt/e/LU/Bachelor/qseoutput/dblp_books_QSE_FULL_SHACL_corrected.ttl', '/mnt/e/LU/Bachelor/dblp_books_schema.json').catch((err)=>console.error('Error:', err));\n\n})();\n//# sourceMappingURL=convert_shacl.js.map\n","'use strict'\n\n/*\n  This file is a reduced and adapted version of the main lib/internal/per_context/primordials.js file defined at\n\n  https://github.com/nodejs/node/blob/main/lib/internal/per_context/primordials.js\n\n  Don't try to replace with the original file and keep it up to date with the upstream file.\n*/\n\n// This is a simplified version of AggregateError\nclass AggregateError extends Error {\n  constructor(errors) {\n    if (!Array.isArray(errors)) {\n      throw new TypeError(`Expected input to be an Array, got ${typeof errors}`)\n    }\n    let message = ''\n    for (let i = 0; i < errors.length; i++) {\n      message += `    ${errors[i].stack}\\n`\n    }\n    super(message)\n    this.name = 'AggregateError'\n    this.errors = errors\n  }\n}\nmodule.exports = {\n  AggregateError,\n  ArrayIsArray(self) {\n    return Array.isArray(self)\n  },\n  ArrayPrototypeIncludes(self, el) {\n    return self.includes(el)\n  },\n  ArrayPrototypeIndexOf(self, el) {\n    return self.indexOf(el)\n  },\n  ArrayPrototypeJoin(self, sep) {\n    return self.join(sep)\n  },\n  ArrayPrototypeMap(self, fn) {\n    return self.map(fn)\n  },\n  ArrayPrototypePop(self, el) {\n    return self.pop(el)\n  },\n  ArrayPrototypePush(self, el) {\n    return self.push(el)\n  },\n  ArrayPrototypeSlice(self, start, end) {\n    return self.slice(start, end)\n  },\n  Error,\n  FunctionPrototypeCall(fn, thisArgs, ...args) {\n    return fn.call(thisArgs, ...args)\n  },\n  FunctionPrototypeSymbolHasInstance(self, instance) {\n    return Function.prototype[Symbol.hasInstance].call(self, instance)\n  },\n  MathFloor: Math.floor,\n  Number,\n  NumberIsInteger: Number.isInteger,\n  NumberIsNaN: Number.isNaN,\n  NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,\n  NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,\n  NumberParseInt: Number.parseInt,\n  ObjectDefineProperties(self, props) {\n    return Object.defineProperties(self, props)\n  },\n  ObjectDefineProperty(self, name, prop) {\n    return Object.defineProperty(self, name, prop)\n  },\n  ObjectGetOwnPropertyDescriptor(self, name) {\n    return Object.getOwnPropertyDescriptor(self, name)\n  },\n  ObjectKeys(obj) {\n    return Object.keys(obj)\n  },\n  ObjectSetPrototypeOf(target, proto) {\n    return Object.setPrototypeOf(target, proto)\n  },\n  Promise,\n  PromisePrototypeCatch(self, fn) {\n    return self.catch(fn)\n  },\n  PromisePrototypeThen(self, thenFn, catchFn) {\n    return self.then(thenFn, catchFn)\n  },\n  PromiseReject(err) {\n    return Promise.reject(err)\n  },\n  PromiseResolve(val) {\n    return Promise.resolve(val)\n  },\n  ReflectApply: Reflect.apply,\n  RegExpPrototypeTest(self, value) {\n    return self.test(value)\n  },\n  SafeSet: Set,\n  String,\n  StringPrototypeSlice(self, start, end) {\n    return self.slice(start, end)\n  },\n  StringPrototypeToLowerCase(self) {\n    return self.toLowerCase()\n  },\n  StringPrototypeToUpperCase(self) {\n    return self.toUpperCase()\n  },\n  StringPrototypeTrim(self) {\n    return self.trim()\n  },\n  Symbol,\n  SymbolFor: Symbol.for,\n  SymbolAsyncIterator: Symbol.asyncIterator,\n  SymbolHasInstance: Symbol.hasInstance,\n  SymbolIterator: Symbol.iterator,\n  SymbolDispose: Symbol.dispose || Symbol('Symbol.dispose'),\n  SymbolAsyncDispose: Symbol.asyncDispose || Symbol('Symbol.asyncDispose'),\n  TypedArrayPrototypeSet(self, buf, len) {\n    return self.set(buf, len)\n  },\n  Boolean,\n  Uint8Array\n}\n","'use strict'\n\nconst bufferModule = require('buffer')\nconst { format, inspect } = require('./util/inspect')\nconst {\n  codes: { ERR_INVALID_ARG_TYPE }\n} = require('./errors')\nconst { kResistStopPropagation, AggregateError, SymbolDispose } = require('./primordials')\nconst AbortSignal = globalThis.AbortSignal || require('abort-controller').AbortSignal\nconst AbortController = globalThis.AbortController || require('abort-controller').AbortController\nconst AsyncFunction = Object.getPrototypeOf(async function () {}).constructor\nconst Blob = globalThis.Blob || bufferModule.Blob\n/* eslint-disable indent */\nconst isBlob =\n  typeof Blob !== 'undefined'\n    ? function isBlob(b) {\n        // eslint-disable-next-line indent\n        return b instanceof Blob\n      }\n    : function isBlob(b) {\n        return false\n      }\n/* eslint-enable indent */\n\nconst validateAbortSignal = (signal, name) => {\n  if (signal !== undefined && (signal === null || typeof signal !== 'object' || !('aborted' in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal)\n  }\n}\nconst validateFunction = (value, name) => {\n  if (typeof value !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE(name, 'Function', value)\n  }\n}\nmodule.exports = {\n  AggregateError,\n  kEmptyObject: Object.freeze({}),\n  once(callback) {\n    let called = false\n    return function (...args) {\n      if (called) {\n        return\n      }\n      called = true\n      callback.apply(this, args)\n    }\n  },\n  createDeferredPromise: function () {\n    let resolve\n    let reject\n\n    // eslint-disable-next-line promise/param-names\n    const promise = new Promise((res, rej) => {\n      resolve = res\n      reject = rej\n    })\n    return {\n      promise,\n      resolve,\n      reject\n    }\n  },\n  promisify(fn) {\n    return new Promise((resolve, reject) => {\n      fn((err, ...args) => {\n        if (err) {\n          return reject(err)\n        }\n        return resolve(...args)\n      })\n    })\n  },\n  debuglog() {\n    return function () {}\n  },\n  format,\n  inspect,\n  types: {\n    isAsyncFunction(fn) {\n      return fn instanceof AsyncFunction\n    },\n    isArrayBufferView(arr) {\n      return ArrayBuffer.isView(arr)\n    }\n  },\n  isBlob,\n  deprecate(fn, message) {\n    return fn\n  },\n  addAbortListener:\n    require('events').addAbortListener ||\n    function addAbortListener(signal, listener) {\n      if (signal === undefined) {\n        throw new ERR_INVALID_ARG_TYPE('signal', 'AbortSignal', signal)\n      }\n      validateAbortSignal(signal, 'signal')\n      validateFunction(listener, 'listener')\n      let removeEventListener\n      if (signal.aborted) {\n        queueMicrotask(() => listener())\n      } else {\n        signal.addEventListener('abort', listener, {\n          __proto__: null,\n          once: true,\n          [kResistStopPropagation]: true\n        })\n        removeEventListener = () => {\n          signal.removeEventListener('abort', listener)\n        }\n      }\n      return {\n        __proto__: null,\n        [SymbolDispose]() {\n          var _removeEventListener\n          ;(_removeEventListener = removeEventListener) === null || _removeEventListener === undefined\n            ? undefined\n            : _removeEventListener()\n        }\n      }\n    },\n  AbortSignalAny:\n    AbortSignal.any ||\n    function AbortSignalAny(signals) {\n      // Fast path if there is only one signal.\n      if (signals.length === 1) {\n        return signals[0]\n      }\n      const ac = new AbortController()\n      const abort = () => ac.abort()\n      signals.forEach((signal) => {\n        validateAbortSignal(signal, 'signals')\n        signal.addEventListener('abort', abort, {\n          once: true\n        })\n      })\n      ac.signal.addEventListener(\n        'abort',\n        () => {\n          signals.forEach((signal) => signal.removeEventListener('abort', abort))\n        },\n        {\n          once: true\n        }\n      )\n      return ac.signal\n    }\n}\nmodule.exports.promisify.custom = Symbol.for('nodejs.util.promisify.custom')\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nconst base64 = require('base64-js')\nconst ieee754 = require('ieee754')\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","'use strict'\n\n/*\n  This file is a reduced and adapted version of the main lib/internal/util/inspect.js file defined at\n\n  https://github.com/nodejs/node/blob/main/lib/internal/util/inspect.js\n\n  Don't try to replace with the original file and keep it up to date with the upstream file.\n*/\nmodule.exports = {\n  format(format, ...args) {\n    // Simplified version of https://nodejs.org/api/util.html#utilformatformat-args\n    return format.replace(/%([sdifj])/g, function (...[_unused, type]) {\n      const replacement = args.shift()\n      if (type === 'f') {\n        return replacement.toFixed(6)\n      } else if (type === 'j') {\n        return JSON.stringify(replacement)\n      } else if (type === 's' && typeof replacement === 'object') {\n        const ctor = replacement.constructor !== Object ? replacement.constructor.name : ''\n        return `${ctor} {}`.trim()\n      } else {\n        return replacement.toString()\n      }\n    })\n  },\n  inspect(value) {\n    // Vastly simplified version of https://nodejs.org/api/util.html#utilinspectobject-options\n    switch (typeof value) {\n      case 'string':\n        if (value.includes(\"'\")) {\n          if (!value.includes('\"')) {\n            return `\"${value}\"`\n          } else if (!value.includes('`') && !value.includes('${')) {\n            return `\\`${value}\\``\n          }\n        }\n        return `'${value}'`\n      case 'number':\n        if (isNaN(value)) {\n          return 'NaN'\n        } else if (Object.is(value, -0)) {\n          return String(value)\n        }\n        return value\n      case 'bigint':\n        return `${String(value)}n`\n      case 'boolean':\n      case 'undefined':\n        return String(value)\n      case 'object':\n        return '{}'\n    }\n  }\n}\n","'use strict'\n\nconst { format, inspect } = require('./util/inspect')\nconst { AggregateError: CustomAggregateError } = require('./primordials')\n\n/*\n  This file is a reduced and adapted version of the main lib/internal/errors.js file defined at\n\n  https://github.com/nodejs/node/blob/main/lib/internal/errors.js\n\n  Don't try to replace with the original file and keep it up to date (starting from E(...) definitions)\n  with the upstream file.\n*/\n\nconst AggregateError = globalThis.AggregateError || CustomAggregateError\nconst kIsNodeError = Symbol('kIsNodeError')\nconst kTypes = [\n  'string',\n  'function',\n  'number',\n  'object',\n  // Accept 'Function' and 'Object' as alternative to the lower cased version.\n  'Function',\n  'Object',\n  'boolean',\n  'bigint',\n  'symbol'\n]\nconst classRegExp = /^([A-Z][a-z0-9]*)+$/\nconst nodeInternalPrefix = '__node_internal_'\nconst codes = {}\nfunction assert(value, message) {\n  if (!value) {\n    throw new codes.ERR_INTERNAL_ASSERTION(message)\n  }\n}\n\n// Only use this for integers! Decimal numbers do not work with this function.\nfunction addNumericalSeparator(val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\nfunction getMessage(key, msg, args) {\n  if (typeof msg === 'function') {\n    assert(\n      msg.length <= args.length,\n      // Default options do not count.\n      `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`\n    )\n    return msg(...args)\n  }\n  const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length\n  assert(\n    expectedLength === args.length,\n    `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`\n  )\n  if (args.length === 0) {\n    return msg\n  }\n  return format(msg, ...args)\n}\nfunction E(code, message, Base) {\n  if (!Base) {\n    Base = Error\n  }\n  class NodeError extends Base {\n    constructor(...args) {\n      super(getMessage(code, message, args))\n    }\n    toString() {\n      return `${this.name} [${code}]: ${this.message}`\n    }\n  }\n  Object.defineProperties(NodeError.prototype, {\n    name: {\n      value: Base.name,\n      writable: true,\n      enumerable: false,\n      configurable: true\n    },\n    toString: {\n      value() {\n        return `${this.name} [${code}]: ${this.message}`\n      },\n      writable: true,\n      enumerable: false,\n      configurable: true\n    }\n  })\n  NodeError.prototype.code = code\n  NodeError.prototype[kIsNodeError] = true\n  codes[code] = NodeError\n}\nfunction hideStackFrames(fn) {\n  // We rename the functions that will be hidden to cut off the stacktrace\n  // at the outermost one\n  const hidden = nodeInternalPrefix + fn.name\n  Object.defineProperty(fn, 'name', {\n    value: hidden\n  })\n  return fn\n}\nfunction aggregateTwoErrors(innerError, outerError) {\n  if (innerError && outerError && innerError !== outerError) {\n    if (Array.isArray(outerError.errors)) {\n      // If `outerError` is already an `AggregateError`.\n      outerError.errors.push(innerError)\n      return outerError\n    }\n    const err = new AggregateError([outerError, innerError], outerError.message)\n    err.code = outerError.code\n    return err\n  }\n  return innerError || outerError\n}\nclass AbortError extends Error {\n  constructor(message = 'The operation was aborted', options = undefined) {\n    if (options !== undefined && typeof options !== 'object') {\n      throw new codes.ERR_INVALID_ARG_TYPE('options', 'Object', options)\n    }\n    super(message, options)\n    this.code = 'ABORT_ERR'\n    this.name = 'AbortError'\n  }\n}\nE('ERR_ASSERTION', '%s', Error)\nE(\n  'ERR_INVALID_ARG_TYPE',\n  (name, expected, actual) => {\n    assert(typeof name === 'string', \"'name' must be a string\")\n    if (!Array.isArray(expected)) {\n      expected = [expected]\n    }\n    let msg = 'The '\n    if (name.endsWith(' argument')) {\n      // For cases like 'first argument'\n      msg += `${name} `\n    } else {\n      msg += `\"${name}\" ${name.includes('.') ? 'property' : 'argument'} `\n    }\n    msg += 'must be '\n    const types = []\n    const instances = []\n    const other = []\n    for (const value of expected) {\n      assert(typeof value === 'string', 'All expected entries have to be of type string')\n      if (kTypes.includes(value)) {\n        types.push(value.toLowerCase())\n      } else if (classRegExp.test(value)) {\n        instances.push(value)\n      } else {\n        assert(value !== 'object', 'The value \"object\" should be written as \"Object\"')\n        other.push(value)\n      }\n    }\n\n    // Special handle `object` in case other instances are allowed to outline\n    // the differences between each other.\n    if (instances.length > 0) {\n      const pos = types.indexOf('object')\n      if (pos !== -1) {\n        types.splice(types, pos, 1)\n        instances.push('Object')\n      }\n    }\n    if (types.length > 0) {\n      switch (types.length) {\n        case 1:\n          msg += `of type ${types[0]}`\n          break\n        case 2:\n          msg += `one of type ${types[0]} or ${types[1]}`\n          break\n        default: {\n          const last = types.pop()\n          msg += `one of type ${types.join(', ')}, or ${last}`\n        }\n      }\n      if (instances.length > 0 || other.length > 0) {\n        msg += ' or '\n      }\n    }\n    if (instances.length > 0) {\n      switch (instances.length) {\n        case 1:\n          msg += `an instance of ${instances[0]}`\n          break\n        case 2:\n          msg += `an instance of ${instances[0]} or ${instances[1]}`\n          break\n        default: {\n          const last = instances.pop()\n          msg += `an instance of ${instances.join(', ')}, or ${last}`\n        }\n      }\n      if (other.length > 0) {\n        msg += ' or '\n      }\n    }\n    switch (other.length) {\n      case 0:\n        break\n      case 1:\n        if (other[0].toLowerCase() !== other[0]) {\n          msg += 'an '\n        }\n        msg += `${other[0]}`\n        break\n      case 2:\n        msg += `one of ${other[0]} or ${other[1]}`\n        break\n      default: {\n        const last = other.pop()\n        msg += `one of ${other.join(', ')}, or ${last}`\n      }\n    }\n    if (actual == null) {\n      msg += `. Received ${actual}`\n    } else if (typeof actual === 'function' && actual.name) {\n      msg += `. Received function ${actual.name}`\n    } else if (typeof actual === 'object') {\n      var _actual$constructor\n      if (\n        (_actual$constructor = actual.constructor) !== null &&\n        _actual$constructor !== undefined &&\n        _actual$constructor.name\n      ) {\n        msg += `. Received an instance of ${actual.constructor.name}`\n      } else {\n        const inspected = inspect(actual, {\n          depth: -1\n        })\n        msg += `. Received ${inspected}`\n      }\n    } else {\n      let inspected = inspect(actual, {\n        colors: false\n      })\n      if (inspected.length > 25) {\n        inspected = `${inspected.slice(0, 25)}...`\n      }\n      msg += `. Received type ${typeof actual} (${inspected})`\n    }\n    return msg\n  },\n  TypeError\n)\nE(\n  'ERR_INVALID_ARG_VALUE',\n  (name, value, reason = 'is invalid') => {\n    let inspected = inspect(value)\n    if (inspected.length > 128) {\n      inspected = inspected.slice(0, 128) + '...'\n    }\n    const type = name.includes('.') ? 'property' : 'argument'\n    return `The ${type} '${name}' ${reason}. Received ${inspected}`\n  },\n  TypeError\n)\nE(\n  'ERR_INVALID_RETURN_VALUE',\n  (input, name, value) => {\n    var _value$constructor\n    const type =\n      value !== null &&\n      value !== undefined &&\n      (_value$constructor = value.constructor) !== null &&\n      _value$constructor !== undefined &&\n      _value$constructor.name\n        ? `instance of ${value.constructor.name}`\n        : `type ${typeof value}`\n    return `Expected ${input} to be returned from the \"${name}\"` + ` function but got ${type}.`\n  },\n  TypeError\n)\nE(\n  'ERR_MISSING_ARGS',\n  (...args) => {\n    assert(args.length > 0, 'At least one arg needs to be specified')\n    let msg\n    const len = args.length\n    args = (Array.isArray(args) ? args : [args]).map((a) => `\"${a}\"`).join(' or ')\n    switch (len) {\n      case 1:\n        msg += `The ${args[0]} argument`\n        break\n      case 2:\n        msg += `The ${args[0]} and ${args[1]} arguments`\n        break\n      default:\n        {\n          const last = args.pop()\n          msg += `The ${args.join(', ')}, and ${last} arguments`\n        }\n        break\n    }\n    return `${msg} must be specified`\n  },\n  TypeError\n)\nE(\n  'ERR_OUT_OF_RANGE',\n  (str, range, input) => {\n    assert(range, 'Missing \"range\" argument')\n    let received\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      const limit = BigInt(2) ** BigInt(32)\n      if (input > limit || input < -limit) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    } else {\n      received = inspect(input)\n    }\n    return `The value of \"${str}\" is out of range. It must be ${range}. Received ${received}`\n  },\n  RangeError\n)\nE('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times', Error)\nE('ERR_METHOD_NOT_IMPLEMENTED', 'The %s method is not implemented', Error)\nE('ERR_STREAM_ALREADY_FINISHED', 'Cannot call %s after a stream was finished', Error)\nE('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable', Error)\nE('ERR_STREAM_DESTROYED', 'Cannot call %s after a stream was destroyed', Error)\nE('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError)\nE('ERR_STREAM_PREMATURE_CLOSE', 'Premature close', Error)\nE('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF', Error)\nE('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event', Error)\nE('ERR_STREAM_WRITE_AFTER_END', 'write after end', Error)\nE('ERR_UNKNOWN_ENCODING', 'Unknown encoding: %s', TypeError)\nmodule.exports = {\n  AbortError,\n  aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),\n  hideStackFrames,\n  codes\n}\n","/*globals self, window */\n\"use strict\"\n\n/*eslint-disable @mysticatea/prettier */\nconst { AbortController, AbortSignal } =\n    typeof self !== \"undefined\" ? self :\n    typeof window !== \"undefined\" ? window :\n    /* otherwise */ undefined\n/*eslint-enable @mysticatea/prettier */\n\nmodule.exports = AbortController\nmodule.exports.AbortSignal = AbortSignal\nmodule.exports.default = AbortController\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototype inheritance, this class\n// prototypically inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict'\n\nconst {\n  ObjectDefineProperties,\n  ObjectGetOwnPropertyDescriptor,\n  ObjectKeys,\n  ObjectSetPrototypeOf\n} = require('../../ours/primordials')\nmodule.exports = Duplex\nconst Readable = require('./readable')\nconst Writable = require('./writable')\nObjectSetPrototypeOf(Duplex.prototype, Readable.prototype)\nObjectSetPrototypeOf(Duplex, Readable)\n{\n  const keys = ObjectKeys(Writable.prototype)\n  // Allow the keys array to be GC'ed.\n  for (let i = 0; i < keys.length; i++) {\n    const method = keys[i]\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method]\n  }\n}\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options)\n  Readable.call(this, options)\n  Writable.call(this, options)\n  if (options) {\n    this.allowHalfOpen = options.allowHalfOpen !== false\n    if (options.readable === false) {\n      this._readableState.readable = false\n      this._readableState.ended = true\n      this._readableState.endEmitted = true\n    }\n    if (options.writable === false) {\n      this._writableState.writable = false\n      this._writableState.ending = true\n      this._writableState.ended = true\n      this._writableState.finished = true\n    }\n  } else {\n    this.allowHalfOpen = true\n  }\n}\nObjectDefineProperties(Duplex.prototype, {\n  writable: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writable')\n  },\n  writableHighWaterMark: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableHighWaterMark')\n  },\n  writableObjectMode: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableObjectMode')\n  },\n  writableBuffer: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableBuffer')\n  },\n  writableLength: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableLength')\n  },\n  writableFinished: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableFinished')\n  },\n  writableCorked: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableCorked')\n  },\n  writableEnded: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableEnded')\n  },\n  writableNeedDrain: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableNeedDrain')\n  },\n  destroyed: {\n    __proto__: null,\n    get() {\n      if (this._readableState === undefined || this._writableState === undefined) {\n        return false\n      }\n      return this._readableState.destroyed && this._writableState.destroyed\n    },\n    set(value) {\n      // Backward compatibility, the user is explicitly\n      // managing destroyed.\n      if (this._readableState && this._writableState) {\n        this._readableState.destroyed = value\n        this._writableState.destroyed = value\n      }\n    }\n  }\n})\nlet webStreamsAdapters\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined) webStreamsAdapters = {}\n  return webStreamsAdapters\n}\nDuplex.fromWeb = function (pair, options) {\n  return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options)\n}\nDuplex.toWeb = function (duplex) {\n  return lazyWebStreams().newReadableWritablePairFromDuplex(duplex)\n}\nlet duplexify\nDuplex.from = function (body) {\n  if (!duplexify) {\n    duplexify = require('./duplexify')\n  }\n  return duplexify(body, 'body')\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict'\n\n/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n\nconst {\n  ArrayPrototypeIndexOf,\n  NumberIsInteger,\n  NumberIsNaN,\n  NumberParseInt,\n  ObjectDefineProperties,\n  ObjectKeys,\n  ObjectSetPrototypeOf,\n  Promise,\n  SafeSet,\n  SymbolAsyncDispose,\n  SymbolAsyncIterator,\n  Symbol\n} = require('../../ours/primordials')\nmodule.exports = Readable\nReadable.ReadableState = ReadableState\nconst { EventEmitter: EE } = require('events')\nconst { Stream, prependListener } = require('./legacy')\nconst { Buffer } = require('buffer')\nconst { addAbortSignal } = require('./add-abort-signal')\nconst eos = require('./end-of-stream')\nlet debug = require('../../ours/util').debuglog('stream', (fn) => {\n  debug = fn\n})\nconst BufferList = require('./buffer_list')\nconst destroyImpl = require('./destroy')\nconst { getHighWaterMark, getDefaultHighWaterMark } = require('./state')\nconst {\n  aggregateTwoErrors,\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_OUT_OF_RANGE,\n    ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT\n  },\n  AbortError\n} = require('../../ours/errors')\nconst { validateObject } = require('../validators')\nconst kPaused = Symbol('kPaused')\nconst { StringDecoder } = require('string_decoder/')\nconst from = require('./from')\nObjectSetPrototypeOf(Readable.prototype, Stream.prototype)\nObjectSetPrototypeOf(Readable, Stream)\nconst nop = () => {}\nconst { errorOrDestroy } = destroyImpl\nconst kObjectMode = 1 << 0\nconst kEnded = 1 << 1\nconst kEndEmitted = 1 << 2\nconst kReading = 1 << 3\nconst kConstructed = 1 << 4\nconst kSync = 1 << 5\nconst kNeedReadable = 1 << 6\nconst kEmittedReadable = 1 << 7\nconst kReadableListening = 1 << 8\nconst kResumeScheduled = 1 << 9\nconst kErrorEmitted = 1 << 10\nconst kEmitClose = 1 << 11\nconst kAutoDestroy = 1 << 12\nconst kDestroyed = 1 << 13\nconst kClosed = 1 << 14\nconst kCloseEmitted = 1 << 15\nconst kMultiAwaitDrain = 1 << 16\nconst kReadingMore = 1 << 17\nconst kDataEmitted = 1 << 18\n\n// TODO(benjamingr) it is likely slower to do it this way than with free functions\nfunction makeBitMapDescriptor(bit) {\n  return {\n    enumerable: false,\n    get() {\n      return (this.state & bit) !== 0\n    },\n    set(value) {\n      if (value) this.state |= bit\n      else this.state &= ~bit\n    }\n  }\n}\nObjectDefineProperties(ReadableState.prototype, {\n  objectMode: makeBitMapDescriptor(kObjectMode),\n  ended: makeBitMapDescriptor(kEnded),\n  endEmitted: makeBitMapDescriptor(kEndEmitted),\n  reading: makeBitMapDescriptor(kReading),\n  // Stream is still being constructed and cannot be\n  // destroyed until construction finished or failed.\n  // Async construction is opt in, therefore we start as\n  // constructed.\n  constructed: makeBitMapDescriptor(kConstructed),\n  // A flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  sync: makeBitMapDescriptor(kSync),\n  // Whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  needReadable: makeBitMapDescriptor(kNeedReadable),\n  emittedReadable: makeBitMapDescriptor(kEmittedReadable),\n  readableListening: makeBitMapDescriptor(kReadableListening),\n  resumeScheduled: makeBitMapDescriptor(kResumeScheduled),\n  // True if the error was already emitted and should not be thrown again.\n  errorEmitted: makeBitMapDescriptor(kErrorEmitted),\n  emitClose: makeBitMapDescriptor(kEmitClose),\n  autoDestroy: makeBitMapDescriptor(kAutoDestroy),\n  // Has it been destroyed.\n  destroyed: makeBitMapDescriptor(kDestroyed),\n  // Indicates whether the stream has finished destroying.\n  closed: makeBitMapDescriptor(kClosed),\n  // True if close has been emitted or would have been emitted\n  // depending on emitClose.\n  closeEmitted: makeBitMapDescriptor(kCloseEmitted),\n  multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),\n  // If true, a maybeReadMore has been scheduled.\n  readingMore: makeBitMapDescriptor(kReadingMore),\n  dataEmitted: makeBitMapDescriptor(kDataEmitted)\n})\nfunction ReadableState(options, stream, isDuplex) {\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof require('./duplex')\n\n  // Bit map field to store ReadableState more effciently with 1 bit per field\n  // instead of a V8 slot per field.\n  this.state = kEmitClose | kAutoDestroy | kConstructed | kSync\n  // Object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away.\n  if (options && options.objectMode) this.state |= kObjectMode\n  if (isDuplex && options && options.readableObjectMode) this.state |= kObjectMode\n\n  // The point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  this.highWaterMark = options\n    ? getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex)\n    : getDefaultHighWaterMark(false)\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift().\n  this.buffer = new BufferList()\n  this.length = 0\n  this.pipes = []\n  this.flowing = null\n  this[kPaused] = null\n\n  // Should close be emitted on destroy. Defaults to true.\n  if (options && options.emitClose === false) this.state &= ~kEmitClose\n\n  // Should .destroy() be called after 'end' (and potentially 'finish').\n  if (options && options.autoDestroy === false) this.state &= ~kAutoDestroy\n\n  // Indicates whether the stream has errored. When true no further\n  // _read calls, 'data' or 'readable' events should occur. This is needed\n  // since when autoDestroy is disabled we need a way to tell whether the\n  // stream has failed.\n  this.errored = null\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8'\n\n  // Ref the piped dest which we need a drain event on it\n  // type: null | Writable | Set<Writable>.\n  this.awaitDrainWriters = null\n  this.decoder = null\n  this.encoding = null\n  if (options && options.encoding) {\n    this.decoder = new StringDecoder(options.encoding)\n    this.encoding = options.encoding\n  }\n}\nfunction Readable(options) {\n  if (!(this instanceof Readable)) return new Readable(options)\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5.\n  const isDuplex = this instanceof require('./duplex')\n  this._readableState = new ReadableState(options, this, isDuplex)\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read\n    if (typeof options.destroy === 'function') this._destroy = options.destroy\n    if (typeof options.construct === 'function') this._construct = options.construct\n    if (options.signal && !isDuplex) addAbortSignal(options.signal, this)\n  }\n  Stream.call(this, options)\n  destroyImpl.construct(this, () => {\n    if (this._readableState.needReadable) {\n      maybeReadMore(this, this._readableState)\n    }\n  })\n}\nReadable.prototype.destroy = destroyImpl.destroy\nReadable.prototype._undestroy = destroyImpl.undestroy\nReadable.prototype._destroy = function (err, cb) {\n  cb(err)\n}\nReadable.prototype[EE.captureRejectionSymbol] = function (err) {\n  this.destroy(err)\n}\nReadable.prototype[SymbolAsyncDispose] = function () {\n  let error\n  if (!this.destroyed) {\n    error = this.readableEnded ? null : new AbortError()\n    this.destroy(error)\n  }\n  return new Promise((resolve, reject) => eos(this, (err) => (err && err !== error ? reject(err) : resolve(null))))\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  return readableAddChunk(this, chunk, encoding, false)\n}\n\n// Unshift should *always* be something directly out of read().\nReadable.prototype.unshift = function (chunk, encoding) {\n  return readableAddChunk(this, chunk, encoding, true)\n}\nfunction readableAddChunk(stream, chunk, encoding, addToFront) {\n  debug('readableAddChunk', chunk)\n  const state = stream._readableState\n  let err\n  if ((state.state & kObjectMode) === 0) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding\n      if (state.encoding !== encoding) {\n        if (addToFront && state.encoding) {\n          // When unshifting, if state.encoding is set, we have to save\n          // the string in the BufferList with the state encoding.\n          chunk = Buffer.from(chunk, encoding).toString(state.encoding)\n        } else {\n          chunk = Buffer.from(chunk, encoding)\n          encoding = ''\n        }\n      }\n    } else if (chunk instanceof Buffer) {\n      encoding = ''\n    } else if (Stream._isUint8Array(chunk)) {\n      chunk = Stream._uint8ArrayToBuffer(chunk)\n      encoding = ''\n    } else if (chunk != null) {\n      err = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk)\n    }\n  }\n  if (err) {\n    errorOrDestroy(stream, err)\n  } else if (chunk === null) {\n    state.state &= ~kReading\n    onEofChunk(stream, state)\n  } else if ((state.state & kObjectMode) !== 0 || (chunk && chunk.length > 0)) {\n    if (addToFront) {\n      if ((state.state & kEndEmitted) !== 0) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT())\n      else if (state.destroyed || state.errored) return false\n      else addChunk(stream, state, chunk, true)\n    } else if (state.ended) {\n      errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF())\n    } else if (state.destroyed || state.errored) {\n      return false\n    } else {\n      state.state &= ~kReading\n      if (state.decoder && !encoding) {\n        chunk = state.decoder.write(chunk)\n        if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false)\n        else maybeReadMore(stream, state)\n      } else {\n        addChunk(stream, state, chunk, false)\n      }\n    }\n  } else if (!addToFront) {\n    state.state &= ~kReading\n    maybeReadMore(stream, state)\n  }\n\n  // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0)\n}\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount('data') > 0) {\n    // Use the guard to avoid creating `Set()` repeatedly\n    // when we have multiple pipes.\n    if ((state.state & kMultiAwaitDrain) !== 0) {\n      state.awaitDrainWriters.clear()\n    } else {\n      state.awaitDrainWriters = null\n    }\n    state.dataEmitted = true\n    stream.emit('data', chunk)\n  } else {\n    // Update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length\n    if (addToFront) state.buffer.unshift(chunk)\n    else state.buffer.push(chunk)\n    if ((state.state & kNeedReadable) !== 0) emitReadable(stream)\n  }\n  maybeReadMore(stream, state)\n}\nReadable.prototype.isPaused = function () {\n  const state = this._readableState\n  return state[kPaused] === true || state.flowing === false\n}\n\n// Backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  const decoder = new StringDecoder(enc)\n  this._readableState.decoder = decoder\n  // If setEncoding(null), decoder.encoding equals utf8.\n  this._readableState.encoding = this._readableState.decoder.encoding\n  const buffer = this._readableState.buffer\n  // Iterate over current buffer to convert already stored Buffers:\n  let content = ''\n  for (const data of buffer) {\n    content += decoder.write(data)\n  }\n  buffer.clear()\n  if (content !== '') buffer.push(content)\n  this._readableState.length = content.length\n  return this\n}\n\n// Don't raise the hwm > 1GB.\nconst MAX_HWM = 0x40000000\nfunction computeNewHighWaterMark(n) {\n  if (n > MAX_HWM) {\n    throw new ERR_OUT_OF_RANGE('size', '<= 1GiB', n)\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts.\n    n--\n    n |= n >>> 1\n    n |= n >>> 2\n    n |= n >>> 4\n    n |= n >>> 8\n    n |= n >>> 16\n    n++\n  }\n  return n\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || (state.length === 0 && state.ended)) return 0\n  if ((state.state & kObjectMode) !== 0) return 1\n  if (NumberIsNaN(n)) {\n    // Only flow one buffer at a time.\n    if (state.flowing && state.length) return state.buffer.first().length\n    return state.length\n  }\n  if (n <= state.length) return n\n  return state.ended ? state.length : 0\n}\n\n// You can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n)\n  // Same as parseInt(undefined, 10), however V8 7.3 performance regressed\n  // in this scenario, so we are doing it manually.\n  if (n === undefined) {\n    n = NaN\n  } else if (!NumberIsInteger(n)) {\n    n = NumberParseInt(n, 10)\n  }\n  const state = this._readableState\n  const nOrig = n\n\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n)\n  if (n !== 0) state.state &= ~kEmittedReadable\n\n  // If we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (\n    n === 0 &&\n    state.needReadable &&\n    ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)\n  ) {\n    debug('read: emitReadable', state.length, state.ended)\n    if (state.length === 0 && state.ended) endReadable(this)\n    else emitReadable(this)\n    return null\n  }\n  n = howMuchToRead(n, state)\n\n  // If we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this)\n    return null\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  let doRead = (state.state & kNeedReadable) !== 0\n  debug('need readable', doRead)\n\n  // If we currently have less than the highWaterMark, then also read some.\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true\n    debug('length less than watermark', doRead)\n  }\n\n  // However, if we've ended, then there's no point, if we're already\n  // reading, then it's unnecessary, if we're constructing we have to wait,\n  // and if we're destroyed or errored, then it's not allowed,\n  if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {\n    doRead = false\n    debug('reading, ended or constructing', doRead)\n  } else if (doRead) {\n    debug('do read')\n    state.state |= kReading | kSync\n    // If the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.state |= kNeedReadable\n\n    // Call internal read method\n    try {\n      this._read(state.highWaterMark)\n    } catch (err) {\n      errorOrDestroy(this, err)\n    }\n    state.state &= ~kSync\n\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state)\n  }\n  let ret\n  if (n > 0) ret = fromList(n, state)\n  else ret = null\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark\n    n = 0\n  } else {\n    state.length -= n\n    if (state.multiAwaitDrain) {\n      state.awaitDrainWriters.clear()\n    } else {\n      state.awaitDrainWriters = null\n    }\n  }\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this)\n  }\n  if (ret !== null && !state.errorEmitted && !state.closeEmitted) {\n    state.dataEmitted = true\n    this.emit('data', ret)\n  }\n  return ret\n}\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk')\n  if (state.ended) return\n  if (state.decoder) {\n    const chunk = state.decoder.end()\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk)\n      state.length += state.objectMode ? 1 : chunk.length\n    }\n  }\n  state.ended = true\n  if (state.sync) {\n    // If we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call.\n    emitReadable(stream)\n  } else {\n    // Emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false\n    state.emittedReadable = true\n    // We have to emit readable now that we are EOF. Modules\n    // in the ecosystem (e.g. dicer) rely on this event being sync.\n    emitReadable_(stream)\n  }\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  const state = stream._readableState\n  debug('emitReadable', state.needReadable, state.emittedReadable)\n  state.needReadable = false\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing)\n    state.emittedReadable = true\n    process.nextTick(emitReadable_, stream)\n  }\n}\nfunction emitReadable_(stream) {\n  const state = stream._readableState\n  debug('emitReadable_', state.destroyed, state.length, state.ended)\n  if (!state.destroyed && !state.errored && (state.length || state.ended)) {\n    stream.emit('readable')\n    state.emittedReadable = false\n  }\n\n  // The stream needs another readable event if:\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark\n  flow(stream)\n}\n\n// At this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore && state.constructed) {\n    state.readingMore = true\n    process.nextTick(maybeReadMore_, stream, state)\n  }\n}\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (\n    !state.reading &&\n    !state.ended &&\n    (state.length < state.highWaterMark || (state.flowing && state.length === 0))\n  ) {\n    const len = state.length\n    debug('maybeReadMore read 0')\n    stream.read(0)\n    if (len === state.length)\n      // Didn't get any data, stop spinning.\n      break\n  }\n  state.readingMore = false\n}\n\n// Abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  throw new ERR_METHOD_NOT_IMPLEMENTED('_read()')\n}\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  const src = this\n  const state = this._readableState\n  if (state.pipes.length === 1) {\n    if (!state.multiAwaitDrain) {\n      state.multiAwaitDrain = true\n      state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : [])\n    }\n  }\n  state.pipes.push(dest)\n  debug('pipe count=%d opts=%j', state.pipes.length, pipeOpts)\n  const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr\n  const endFn = doEnd ? onend : unpipe\n  if (state.endEmitted) process.nextTick(endFn)\n  else src.once('end', endFn)\n  dest.on('unpipe', onunpipe)\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe')\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true\n        cleanup()\n      }\n    }\n  }\n  function onend() {\n    debug('onend')\n    dest.end()\n  }\n  let ondrain\n  let cleanedUp = false\n  function cleanup() {\n    debug('cleanup')\n    // Cleanup event handlers once the pipe is broken.\n    dest.removeListener('close', onclose)\n    dest.removeListener('finish', onfinish)\n    if (ondrain) {\n      dest.removeListener('drain', ondrain)\n    }\n    dest.removeListener('error', onerror)\n    dest.removeListener('unpipe', onunpipe)\n    src.removeListener('end', onend)\n    src.removeListener('end', unpipe)\n    src.removeListener('data', ondata)\n    cleanedUp = true\n\n    // If the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) ondrain()\n  }\n  function pause() {\n    // If the user unpiped during `dest.write()`, it is possible\n    // to get stuck in a permanently paused state if that write\n    // also returned false.\n    // => Check whether `dest` is still a piping destination.\n    if (!cleanedUp) {\n      if (state.pipes.length === 1 && state.pipes[0] === dest) {\n        debug('false write response, pause', 0)\n        state.awaitDrainWriters = dest\n        state.multiAwaitDrain = false\n      } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {\n        debug('false write response, pause', state.awaitDrainWriters.size)\n        state.awaitDrainWriters.add(dest)\n      }\n      src.pause()\n    }\n    if (!ondrain) {\n      // When the dest drains, it reduces the awaitDrain counter\n      // on the source.  This would be more elegant with a .once()\n      // handler in flow(), but adding and removing repeatedly is\n      // too slow.\n      ondrain = pipeOnDrain(src, dest)\n      dest.on('drain', ondrain)\n    }\n  }\n  src.on('data', ondata)\n  function ondata(chunk) {\n    debug('ondata')\n    const ret = dest.write(chunk)\n    debug('dest.write', ret)\n    if (ret === false) {\n      pause()\n    }\n  }\n\n  // If the dest has an error, then stop piping into it.\n  // However, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er)\n    unpipe()\n    dest.removeListener('error', onerror)\n    if (dest.listenerCount('error') === 0) {\n      const s = dest._writableState || dest._readableState\n      if (s && !s.errorEmitted) {\n        // User incorrectly emitted 'error' directly on the stream.\n        errorOrDestroy(dest, er)\n      } else {\n        dest.emit('error', er)\n      }\n    }\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror)\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish)\n    unpipe()\n  }\n  dest.once('close', onclose)\n  function onfinish() {\n    debug('onfinish')\n    dest.removeListener('close', onclose)\n    unpipe()\n  }\n  dest.once('finish', onfinish)\n  function unpipe() {\n    debug('unpipe')\n    src.unpipe(dest)\n  }\n\n  // Tell the dest that it's being piped to.\n  dest.emit('pipe', src)\n\n  // Start the flow if it hasn't been started already.\n\n  if (dest.writableNeedDrain === true) {\n    pause()\n  } else if (!state.flowing) {\n    debug('pipe resume')\n    src.resume()\n  }\n  return dest\n}\nfunction pipeOnDrain(src, dest) {\n  return function pipeOnDrainFunctionResult() {\n    const state = src._readableState\n\n    // `ondrain` will call directly,\n    // `this` maybe not a reference to dest,\n    // so we use the real dest here.\n    if (state.awaitDrainWriters === dest) {\n      debug('pipeOnDrain', 1)\n      state.awaitDrainWriters = null\n    } else if (state.multiAwaitDrain) {\n      debug('pipeOnDrain', state.awaitDrainWriters.size)\n      state.awaitDrainWriters.delete(dest)\n    }\n    if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount('data')) {\n      src.resume()\n    }\n  }\n}\nReadable.prototype.unpipe = function (dest) {\n  const state = this._readableState\n  const unpipeInfo = {\n    hasUnpiped: false\n  }\n\n  // If we're not piping anywhere, then do nothing.\n  if (state.pipes.length === 0) return this\n  if (!dest) {\n    // remove all.\n    const dests = state.pipes\n    state.pipes = []\n    this.pause()\n    for (let i = 0; i < dests.length; i++)\n      dests[i].emit('unpipe', this, {\n        hasUnpiped: false\n      })\n    return this\n  }\n\n  // Try to find the right one.\n  const index = ArrayPrototypeIndexOf(state.pipes, dest)\n  if (index === -1) return this\n  state.pipes.splice(index, 1)\n  if (state.pipes.length === 0) this.pause()\n  dest.emit('unpipe', this, unpipeInfo)\n  return this\n}\n\n// Set up data events if they are asked for\n// Ensure readable listeners eventually get something.\nReadable.prototype.on = function (ev, fn) {\n  const res = Stream.prototype.on.call(this, ev, fn)\n  const state = this._readableState\n  if (ev === 'data') {\n    // Update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0\n\n    // Try start flowing on next tick if stream isn't explicitly paused.\n    if (state.flowing !== false) this.resume()\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true\n      state.flowing = false\n      state.emittedReadable = false\n      debug('on readable', state.length, state.reading)\n      if (state.length) {\n        emitReadable(this)\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this)\n      }\n    }\n  }\n  return res\n}\nReadable.prototype.addListener = Readable.prototype.on\nReadable.prototype.removeListener = function (ev, fn) {\n  const res = Stream.prototype.removeListener.call(this, ev, fn)\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this)\n  }\n  return res\n}\nReadable.prototype.off = Readable.prototype.removeListener\nReadable.prototype.removeAllListeners = function (ev) {\n  const res = Stream.prototype.removeAllListeners.apply(this, arguments)\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this)\n  }\n  return res\n}\nfunction updateReadableListening(self) {\n  const state = self._readableState\n  state.readableListening = self.listenerCount('readable') > 0\n  if (state.resumeScheduled && state[kPaused] === false) {\n    // Flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true\n\n    // Crude way to check if we should resume.\n  } else if (self.listenerCount('data') > 0) {\n    self.resume()\n  } else if (!state.readableListening) {\n    state.flowing = null\n  }\n}\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0')\n  self.read(0)\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  const state = this._readableState\n  if (!state.flowing) {\n    debug('resume')\n    // We flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume().\n    state.flowing = !state.readableListening\n    resume(this, state)\n  }\n  state[kPaused] = false\n  return this\n}\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true\n    process.nextTick(resume_, stream, state)\n  }\n}\nfunction resume_(stream, state) {\n  debug('resume', state.reading)\n  if (!state.reading) {\n    stream.read(0)\n  }\n  state.resumeScheduled = false\n  stream.emit('resume')\n  flow(stream)\n  if (state.flowing && !state.reading) stream.read(0)\n}\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing)\n  if (this._readableState.flowing !== false) {\n    debug('pause')\n    this._readableState.flowing = false\n    this.emit('pause')\n  }\n  this._readableState[kPaused] = true\n  return this\n}\nfunction flow(stream) {\n  const state = stream._readableState\n  debug('flow', state.flowing)\n  while (state.flowing && stream.read() !== null);\n}\n\n// Wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  let paused = false\n\n  // TODO (ronag): Should this.destroy(err) emit\n  // 'error' on the wrapped stream? Would require\n  // a static factory method, e.g. Readable.wrap(stream).\n\n  stream.on('data', (chunk) => {\n    if (!this.push(chunk) && stream.pause) {\n      paused = true\n      stream.pause()\n    }\n  })\n  stream.on('end', () => {\n    this.push(null)\n  })\n  stream.on('error', (err) => {\n    errorOrDestroy(this, err)\n  })\n  stream.on('close', () => {\n    this.destroy()\n  })\n  stream.on('destroy', () => {\n    this.destroy()\n  })\n  this._read = () => {\n    if (paused && stream.resume) {\n      paused = false\n      stream.resume()\n    }\n  }\n\n  // Proxy all the other methods. Important when wrapping filters and duplexes.\n  const streamKeys = ObjectKeys(stream)\n  for (let j = 1; j < streamKeys.length; j++) {\n    const i = streamKeys[j]\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = stream[i].bind(stream)\n    }\n  }\n  return this\n}\nReadable.prototype[SymbolAsyncIterator] = function () {\n  return streamToAsyncIterator(this)\n}\nReadable.prototype.iterator = function (options) {\n  if (options !== undefined) {\n    validateObject(options, 'options')\n  }\n  return streamToAsyncIterator(this, options)\n}\nfunction streamToAsyncIterator(stream, options) {\n  if (typeof stream.read !== 'function') {\n    stream = Readable.wrap(stream, {\n      objectMode: true\n    })\n  }\n  const iter = createAsyncIterator(stream, options)\n  iter.stream = stream\n  return iter\n}\nasync function* createAsyncIterator(stream, options) {\n  let callback = nop\n  function next(resolve) {\n    if (this === stream) {\n      callback()\n      callback = nop\n    } else {\n      callback = resolve\n    }\n  }\n  stream.on('readable', next)\n  let error\n  const cleanup = eos(\n    stream,\n    {\n      writable: false\n    },\n    (err) => {\n      error = err ? aggregateTwoErrors(error, err) : null\n      callback()\n      callback = nop\n    }\n  )\n  try {\n    while (true) {\n      const chunk = stream.destroyed ? null : stream.read()\n      if (chunk !== null) {\n        yield chunk\n      } else if (error) {\n        throw error\n      } else if (error === null) {\n        return\n      } else {\n        await new Promise(next)\n      }\n    }\n  } catch (err) {\n    error = aggregateTwoErrors(error, err)\n    throw error\n  } finally {\n    if (\n      (error || (options === null || options === undefined ? undefined : options.destroyOnReturn) !== false) &&\n      (error === undefined || stream._readableState.autoDestroy)\n    ) {\n      destroyImpl.destroyer(stream, null)\n    } else {\n      stream.off('readable', next)\n      cleanup()\n    }\n  }\n}\n\n// Making it explicit these properties are not enumerable\n// because otherwise some prototype manipulation in\n// userland will fail.\nObjectDefineProperties(Readable.prototype, {\n  readable: {\n    __proto__: null,\n    get() {\n      const r = this._readableState\n      // r.readable === false means that this is part of a Duplex stream\n      // where the readable side was disabled upon construction.\n      // Compat. The user might manually disable readable side through\n      // deprecated setter.\n      return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted\n    },\n    set(val) {\n      // Backwards compat.\n      if (this._readableState) {\n        this._readableState.readable = !!val\n      }\n    }\n  },\n  readableDidRead: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState.dataEmitted\n    }\n  },\n  readableAborted: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return !!(\n        this._readableState.readable !== false &&\n        (this._readableState.destroyed || this._readableState.errored) &&\n        !this._readableState.endEmitted\n      )\n    }\n  },\n  readableHighWaterMark: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState.highWaterMark\n    }\n  },\n  readableBuffer: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState && this._readableState.buffer\n    }\n  },\n  readableFlowing: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState.flowing\n    },\n    set: function (state) {\n      if (this._readableState) {\n        this._readableState.flowing = state\n      }\n    }\n  },\n  readableLength: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState.length\n    }\n  },\n  readableObjectMode: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.objectMode : false\n    }\n  },\n  readableEncoding: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.encoding : null\n    }\n  },\n  errored: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.errored : null\n    }\n  },\n  closed: {\n    __proto__: null,\n    get() {\n      return this._readableState ? this._readableState.closed : false\n    }\n  },\n  destroyed: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.destroyed : false\n    },\n    set(value) {\n      // We ignore the value if the stream\n      // has not been initialized yet.\n      if (!this._readableState) {\n        return\n      }\n\n      // Backward compatibility, the user is explicitly\n      // managing destroyed.\n      this._readableState.destroyed = value\n    }\n  },\n  readableEnded: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.endEmitted : false\n    }\n  }\n})\nObjectDefineProperties(ReadableState.prototype, {\n  // Legacy getter for `pipesCount`.\n  pipesCount: {\n    __proto__: null,\n    get() {\n      return this.pipes.length\n    }\n  },\n  // Legacy property for `paused`.\n  paused: {\n    __proto__: null,\n    get() {\n      return this[kPaused] !== false\n    },\n    set(value) {\n      this[kPaused] = !!value\n    }\n  }\n})\n\n// Exposed for testing purposes only.\nReadable._fromList = fromList\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered.\n  if (state.length === 0) return null\n  let ret\n  if (state.objectMode) ret = state.buffer.shift()\n  else if (!n || n >= state.length) {\n    // Read it all, truncate the list.\n    if (state.decoder) ret = state.buffer.join('')\n    else if (state.buffer.length === 1) ret = state.buffer.first()\n    else ret = state.buffer.concat(state.length)\n    state.buffer.clear()\n  } else {\n    // read part of list.\n    ret = state.buffer.consume(n, state.decoder)\n  }\n  return ret\n}\nfunction endReadable(stream) {\n  const state = stream._readableState\n  debug('endReadable', state.endEmitted)\n  if (!state.endEmitted) {\n    state.ended = true\n    process.nextTick(endReadableNT, state, stream)\n  }\n}\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length)\n\n  // Check that we didn't get one last unshift.\n  if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {\n    state.endEmitted = true\n    stream.emit('end')\n    if (stream.writable && stream.allowHalfOpen === false) {\n      process.nextTick(endWritableNT, stream)\n    } else if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well.\n      const wState = stream._writableState\n      const autoDestroy =\n        !wState ||\n        (wState.autoDestroy &&\n          // We don't expect the writable to ever 'finish'\n          // if writable is explicitly set to false.\n          (wState.finished || wState.writable === false))\n      if (autoDestroy) {\n        stream.destroy()\n      }\n    }\n  }\n}\nfunction endWritableNT(stream) {\n  const writable = stream.writable && !stream.writableEnded && !stream.destroyed\n  if (writable) {\n    stream.end()\n  }\n}\nReadable.from = function (iterable, opts) {\n  return from(Readable, iterable, opts)\n}\nlet webStreamsAdapters\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined) webStreamsAdapters = {}\n  return webStreamsAdapters\n}\nReadable.fromWeb = function (readableStream, options) {\n  return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options)\n}\nReadable.toWeb = function (streamReadable, options) {\n  return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options)\n}\nReadable.wrap = function (src, options) {\n  var _ref, _src$readableObjectMo\n  return new Readable({\n    objectMode:\n      (_ref =\n        (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== undefined\n          ? _src$readableObjectMo\n          : src.objectMode) !== null && _ref !== undefined\n        ? _ref\n        : true,\n    ...options,\n    destroy(err, callback) {\n      destroyImpl.destroyer(src, err)\n      callback(err)\n    }\n  }).wrap(src)\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","'use strict'\n\nconst { ArrayIsArray, ObjectSetPrototypeOf } = require('../../ours/primordials')\nconst { EventEmitter: EE } = require('events')\nfunction Stream(opts) {\n  EE.call(this, opts)\n}\nObjectSetPrototypeOf(Stream.prototype, EE.prototype)\nObjectSetPrototypeOf(Stream, EE)\nStream.prototype.pipe = function (dest, options) {\n  const source = this\n  function ondata(chunk) {\n    if (dest.writable && dest.write(chunk) === false && source.pause) {\n      source.pause()\n    }\n  }\n  source.on('data', ondata)\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume()\n    }\n  }\n  dest.on('drain', ondrain)\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend)\n    source.on('close', onclose)\n  }\n  let didOnEnd = false\n  function onend() {\n    if (didOnEnd) return\n    didOnEnd = true\n    dest.end()\n  }\n  function onclose() {\n    if (didOnEnd) return\n    didOnEnd = true\n    if (typeof dest.destroy === 'function') dest.destroy()\n  }\n\n  // Don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup()\n    if (EE.listenerCount(this, 'error') === 0) {\n      this.emit('error', er)\n    }\n  }\n  prependListener(source, 'error', onerror)\n  prependListener(dest, 'error', onerror)\n\n  // Remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata)\n    dest.removeListener('drain', ondrain)\n    source.removeListener('end', onend)\n    source.removeListener('close', onclose)\n    source.removeListener('error', onerror)\n    dest.removeListener('error', onerror)\n    source.removeListener('end', cleanup)\n    source.removeListener('close', cleanup)\n    dest.removeListener('close', cleanup)\n  }\n  source.on('end', cleanup)\n  source.on('close', cleanup)\n  dest.on('close', cleanup)\n  dest.emit('pipe', source)\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest\n}\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn)\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn)\n  else if (ArrayIsArray(emitter._events[event])) emitter._events[event].unshift(fn)\n  else emitter._events[event] = [fn, emitter._events[event]]\n}\nmodule.exports = {\n  Stream,\n  prependListener\n}\n","'use strict'\n\nconst { SymbolDispose } = require('../../ours/primordials')\nconst { AbortError, codes } = require('../../ours/errors')\nconst { isNodeStream, isWebStream, kControllerErrorFunction } = require('./utils')\nconst eos = require('./end-of-stream')\nconst { ERR_INVALID_ARG_TYPE } = codes\nlet addAbortListener\n\n// This method is inlined here for readable-stream\n// It also does not allow for signal to not exist on the stream\n// https://github.com/nodejs/node/pull/36061#discussion_r533718029\nconst validateAbortSignal = (signal, name) => {\n  if (typeof signal !== 'object' || !('aborted' in signal)) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal)\n  }\n}\nmodule.exports.addAbortSignal = function addAbortSignal(signal, stream) {\n  validateAbortSignal(signal, 'signal')\n  if (!isNodeStream(stream) && !isWebStream(stream)) {\n    throw new ERR_INVALID_ARG_TYPE('stream', ['ReadableStream', 'WritableStream', 'Stream'], stream)\n  }\n  return module.exports.addAbortSignalNoValidate(signal, stream)\n}\nmodule.exports.addAbortSignalNoValidate = function (signal, stream) {\n  if (typeof signal !== 'object' || !('aborted' in signal)) {\n    return stream\n  }\n  const onAbort = isNodeStream(stream)\n    ? () => {\n        stream.destroy(\n          new AbortError(undefined, {\n            cause: signal.reason\n          })\n        )\n      }\n    : () => {\n        stream[kControllerErrorFunction](\n          new AbortError(undefined, {\n            cause: signal.reason\n          })\n        )\n      }\n  if (signal.aborted) {\n    onAbort()\n  } else {\n    addAbortListener = addAbortListener || require('../../ours/util').addAbortListener\n    const disposable = addAbortListener(signal, onAbort)\n    eos(stream, disposable[SymbolDispose])\n  }\n  return stream\n}\n","'use strict'\n\nconst { SymbolAsyncIterator, SymbolIterator, SymbolFor } = require('../../ours/primordials')\n\n// We need to use SymbolFor to make these globally available\n// for interopt with readable-stream, i.e. readable-stream\n// and node core needs to be able to read/write private state\n// from each other for proper interoperability.\nconst kIsDestroyed = SymbolFor('nodejs.stream.destroyed')\nconst kIsErrored = SymbolFor('nodejs.stream.errored')\nconst kIsReadable = SymbolFor('nodejs.stream.readable')\nconst kIsWritable = SymbolFor('nodejs.stream.writable')\nconst kIsDisturbed = SymbolFor('nodejs.stream.disturbed')\nconst kIsClosedPromise = SymbolFor('nodejs.webstream.isClosedPromise')\nconst kControllerErrorFunction = SymbolFor('nodejs.webstream.controllerErrorFunction')\nfunction isReadableNodeStream(obj, strict = false) {\n  var _obj$_readableState\n  return !!(\n    (\n      obj &&\n      typeof obj.pipe === 'function' &&\n      typeof obj.on === 'function' &&\n      (!strict || (typeof obj.pause === 'function' && typeof obj.resume === 'function')) &&\n      (!obj._writableState ||\n        ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === undefined\n          ? undefined\n          : _obj$_readableState.readable) !== false) &&\n      // Duplex\n      (!obj._writableState || obj._readableState)\n    ) // Writable has .pipe.\n  )\n}\nfunction isWritableNodeStream(obj) {\n  var _obj$_writableState\n  return !!(\n    (\n      obj &&\n      typeof obj.write === 'function' &&\n      typeof obj.on === 'function' &&\n      (!obj._readableState ||\n        ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === undefined\n          ? undefined\n          : _obj$_writableState.writable) !== false)\n    ) // Duplex\n  )\n}\nfunction isDuplexNodeStream(obj) {\n  return !!(\n    obj &&\n    typeof obj.pipe === 'function' &&\n    obj._readableState &&\n    typeof obj.on === 'function' &&\n    typeof obj.write === 'function'\n  )\n}\nfunction isNodeStream(obj) {\n  return (\n    obj &&\n    (obj._readableState ||\n      obj._writableState ||\n      (typeof obj.write === 'function' && typeof obj.on === 'function') ||\n      (typeof obj.pipe === 'function' && typeof obj.on === 'function'))\n  )\n}\nfunction isReadableStream(obj) {\n  return !!(\n    obj &&\n    !isNodeStream(obj) &&\n    typeof obj.pipeThrough === 'function' &&\n    typeof obj.getReader === 'function' &&\n    typeof obj.cancel === 'function'\n  )\n}\nfunction isWritableStream(obj) {\n  return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === 'function' && typeof obj.abort === 'function')\n}\nfunction isTransformStream(obj) {\n  return !!(obj && !isNodeStream(obj) && typeof obj.readable === 'object' && typeof obj.writable === 'object')\n}\nfunction isWebStream(obj) {\n  return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj)\n}\nfunction isIterable(obj, isAsync) {\n  if (obj == null) return false\n  if (isAsync === true) return typeof obj[SymbolAsyncIterator] === 'function'\n  if (isAsync === false) return typeof obj[SymbolIterator] === 'function'\n  return typeof obj[SymbolAsyncIterator] === 'function' || typeof obj[SymbolIterator] === 'function'\n}\nfunction isDestroyed(stream) {\n  if (!isNodeStream(stream)) return null\n  const wState = stream._writableState\n  const rState = stream._readableState\n  const state = wState || rState\n  return !!(stream.destroyed || stream[kIsDestroyed] || (state !== null && state !== undefined && state.destroyed))\n}\n\n// Have been end():d.\nfunction isWritableEnded(stream) {\n  if (!isWritableNodeStream(stream)) return null\n  if (stream.writableEnded === true) return true\n  const wState = stream._writableState\n  if (wState !== null && wState !== undefined && wState.errored) return false\n  if (typeof (wState === null || wState === undefined ? undefined : wState.ended) !== 'boolean') return null\n  return wState.ended\n}\n\n// Have emitted 'finish'.\nfunction isWritableFinished(stream, strict) {\n  if (!isWritableNodeStream(stream)) return null\n  if (stream.writableFinished === true) return true\n  const wState = stream._writableState\n  if (wState !== null && wState !== undefined && wState.errored) return false\n  if (typeof (wState === null || wState === undefined ? undefined : wState.finished) !== 'boolean') return null\n  return !!(wState.finished || (strict === false && wState.ended === true && wState.length === 0))\n}\n\n// Have been push(null):d.\nfunction isReadableEnded(stream) {\n  if (!isReadableNodeStream(stream)) return null\n  if (stream.readableEnded === true) return true\n  const rState = stream._readableState\n  if (!rState || rState.errored) return false\n  if (typeof (rState === null || rState === undefined ? undefined : rState.ended) !== 'boolean') return null\n  return rState.ended\n}\n\n// Have emitted 'end'.\nfunction isReadableFinished(stream, strict) {\n  if (!isReadableNodeStream(stream)) return null\n  const rState = stream._readableState\n  if (rState !== null && rState !== undefined && rState.errored) return false\n  if (typeof (rState === null || rState === undefined ? undefined : rState.endEmitted) !== 'boolean') return null\n  return !!(rState.endEmitted || (strict === false && rState.ended === true && rState.length === 0))\n}\nfunction isReadable(stream) {\n  if (stream && stream[kIsReadable] != null) return stream[kIsReadable]\n  if (typeof (stream === null || stream === undefined ? undefined : stream.readable) !== 'boolean') return null\n  if (isDestroyed(stream)) return false\n  return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream)\n}\nfunction isWritable(stream) {\n  if (stream && stream[kIsWritable] != null) return stream[kIsWritable]\n  if (typeof (stream === null || stream === undefined ? undefined : stream.writable) !== 'boolean') return null\n  if (isDestroyed(stream)) return false\n  return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream)\n}\nfunction isFinished(stream, opts) {\n  if (!isNodeStream(stream)) {\n    return null\n  }\n  if (isDestroyed(stream)) {\n    return true\n  }\n  if ((opts === null || opts === undefined ? undefined : opts.readable) !== false && isReadable(stream)) {\n    return false\n  }\n  if ((opts === null || opts === undefined ? undefined : opts.writable) !== false && isWritable(stream)) {\n    return false\n  }\n  return true\n}\nfunction isWritableErrored(stream) {\n  var _stream$_writableStat, _stream$_writableStat2\n  if (!isNodeStream(stream)) {\n    return null\n  }\n  if (stream.writableErrored) {\n    return stream.writableErrored\n  }\n  return (_stream$_writableStat =\n    (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === undefined\n      ? undefined\n      : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== undefined\n    ? _stream$_writableStat\n    : null\n}\nfunction isReadableErrored(stream) {\n  var _stream$_readableStat, _stream$_readableStat2\n  if (!isNodeStream(stream)) {\n    return null\n  }\n  if (stream.readableErrored) {\n    return stream.readableErrored\n  }\n  return (_stream$_readableStat =\n    (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === undefined\n      ? undefined\n      : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== undefined\n    ? _stream$_readableStat\n    : null\n}\nfunction isClosed(stream) {\n  if (!isNodeStream(stream)) {\n    return null\n  }\n  if (typeof stream.closed === 'boolean') {\n    return stream.closed\n  }\n  const wState = stream._writableState\n  const rState = stream._readableState\n  if (\n    typeof (wState === null || wState === undefined ? undefined : wState.closed) === 'boolean' ||\n    typeof (rState === null || rState === undefined ? undefined : rState.closed) === 'boolean'\n  ) {\n    return (\n      (wState === null || wState === undefined ? undefined : wState.closed) ||\n      (rState === null || rState === undefined ? undefined : rState.closed)\n    )\n  }\n  if (typeof stream._closed === 'boolean' && isOutgoingMessage(stream)) {\n    return stream._closed\n  }\n  return null\n}\nfunction isOutgoingMessage(stream) {\n  return (\n    typeof stream._closed === 'boolean' &&\n    typeof stream._defaultKeepAlive === 'boolean' &&\n    typeof stream._removedConnection === 'boolean' &&\n    typeof stream._removedContLen === 'boolean'\n  )\n}\nfunction isServerResponse(stream) {\n  return typeof stream._sent100 === 'boolean' && isOutgoingMessage(stream)\n}\nfunction isServerRequest(stream) {\n  var _stream$req\n  return (\n    typeof stream._consuming === 'boolean' &&\n    typeof stream._dumped === 'boolean' &&\n    ((_stream$req = stream.req) === null || _stream$req === undefined ? undefined : _stream$req.upgradeOrConnect) ===\n      undefined\n  )\n}\nfunction willEmitClose(stream) {\n  if (!isNodeStream(stream)) return null\n  const wState = stream._writableState\n  const rState = stream._readableState\n  const state = wState || rState\n  return (\n    (!state && isServerResponse(stream)) || !!(state && state.autoDestroy && state.emitClose && state.closed === false)\n  )\n}\nfunction isDisturbed(stream) {\n  var _stream$kIsDisturbed\n  return !!(\n    stream &&\n    ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== undefined\n      ? _stream$kIsDisturbed\n      : stream.readableDidRead || stream.readableAborted)\n  )\n}\nfunction isErrored(stream) {\n  var _ref,\n    _ref2,\n    _ref3,\n    _ref4,\n    _ref5,\n    _stream$kIsErrored,\n    _stream$_readableStat3,\n    _stream$_writableStat3,\n    _stream$_readableStat4,\n    _stream$_writableStat4\n  return !!(\n    stream &&\n    ((_ref =\n      (_ref2 =\n        (_ref3 =\n          (_ref4 =\n            (_ref5 =\n              (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== undefined\n                ? _stream$kIsErrored\n                : stream.readableErrored) !== null && _ref5 !== undefined\n              ? _ref5\n              : stream.writableErrored) !== null && _ref4 !== undefined\n            ? _ref4\n            : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === undefined\n            ? undefined\n            : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== undefined\n          ? _ref3\n          : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === undefined\n          ? undefined\n          : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== undefined\n        ? _ref2\n        : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === undefined\n        ? undefined\n        : _stream$_readableStat4.errored) !== null && _ref !== undefined\n      ? _ref\n      : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === undefined\n      ? undefined\n      : _stream$_writableStat4.errored)\n  )\n}\nmodule.exports = {\n  isDestroyed,\n  kIsDestroyed,\n  isDisturbed,\n  kIsDisturbed,\n  isErrored,\n  kIsErrored,\n  isReadable,\n  kIsReadable,\n  kIsClosedPromise,\n  kControllerErrorFunction,\n  kIsWritable,\n  isClosed,\n  isDuplexNodeStream,\n  isFinished,\n  isIterable,\n  isReadableNodeStream,\n  isReadableStream,\n  isReadableEnded,\n  isReadableFinished,\n  isReadableErrored,\n  isNodeStream,\n  isWebStream,\n  isWritable,\n  isWritableNodeStream,\n  isWritableStream,\n  isWritableEnded,\n  isWritableFinished,\n  isWritableErrored,\n  isServerRequest,\n  isServerResponse,\n  willEmitClose,\n  isTransformStream\n}\n","// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n\n'use strict'\n\n/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n\nconst { AbortError, codes } = require('../../ours/errors')\nconst { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes\nconst { kEmptyObject, once } = require('../../ours/util')\nconst { validateAbortSignal, validateFunction, validateObject, validateBoolean } = require('../validators')\nconst { Promise, PromisePrototypeThen, SymbolDispose } = require('../../ours/primordials')\nconst {\n  isClosed,\n  isReadable,\n  isReadableNodeStream,\n  isReadableStream,\n  isReadableFinished,\n  isReadableErrored,\n  isWritable,\n  isWritableNodeStream,\n  isWritableStream,\n  isWritableFinished,\n  isWritableErrored,\n  isNodeStream,\n  willEmitClose: _willEmitClose,\n  kIsClosedPromise\n} = require('./utils')\nlet addAbortListener\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function'\n}\nconst nop = () => {}\nfunction eos(stream, options, callback) {\n  var _options$readable, _options$writable\n  if (arguments.length === 2) {\n    callback = options\n    options = kEmptyObject\n  } else if (options == null) {\n    options = kEmptyObject\n  } else {\n    validateObject(options, 'options')\n  }\n  validateFunction(callback, 'callback')\n  validateAbortSignal(options.signal, 'options.signal')\n  callback = once(callback)\n  if (isReadableStream(stream) || isWritableStream(stream)) {\n    return eosWeb(stream, options, callback)\n  }\n  if (!isNodeStream(stream)) {\n    throw new ERR_INVALID_ARG_TYPE('stream', ['ReadableStream', 'WritableStream', 'Stream'], stream)\n  }\n  const readable =\n    (_options$readable = options.readable) !== null && _options$readable !== undefined\n      ? _options$readable\n      : isReadableNodeStream(stream)\n  const writable =\n    (_options$writable = options.writable) !== null && _options$writable !== undefined\n      ? _options$writable\n      : isWritableNodeStream(stream)\n  const wState = stream._writableState\n  const rState = stream._readableState\n  const onlegacyfinish = () => {\n    if (!stream.writable) {\n      onfinish()\n    }\n  }\n\n  // TODO (ronag): Improve soft detection to include core modules and\n  // common ecosystem modules that do properly emit 'close' but fail\n  // this generic check.\n  let willEmitClose =\n    _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable\n  let writableFinished = isWritableFinished(stream, false)\n  const onfinish = () => {\n    writableFinished = true\n    // Stream should not be destroyed here. If it is that\n    // means that user space is doing something differently and\n    // we cannot trust willEmitClose.\n    if (stream.destroyed) {\n      willEmitClose = false\n    }\n    if (willEmitClose && (!stream.readable || readable)) {\n      return\n    }\n    if (!readable || readableFinished) {\n      callback.call(stream)\n    }\n  }\n  let readableFinished = isReadableFinished(stream, false)\n  const onend = () => {\n    readableFinished = true\n    // Stream should not be destroyed here. If it is that\n    // means that user space is doing something differently and\n    // we cannot trust willEmitClose.\n    if (stream.destroyed) {\n      willEmitClose = false\n    }\n    if (willEmitClose && (!stream.writable || writable)) {\n      return\n    }\n    if (!writable || writableFinished) {\n      callback.call(stream)\n    }\n  }\n  const onerror = (err) => {\n    callback.call(stream, err)\n  }\n  let closed = isClosed(stream)\n  const onclose = () => {\n    closed = true\n    const errored = isWritableErrored(stream) || isReadableErrored(stream)\n    if (errored && typeof errored !== 'boolean') {\n      return callback.call(stream, errored)\n    }\n    if (readable && !readableFinished && isReadableNodeStream(stream, true)) {\n      if (!isReadableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE())\n    }\n    if (writable && !writableFinished) {\n      if (!isWritableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE())\n    }\n    callback.call(stream)\n  }\n  const onclosed = () => {\n    closed = true\n    const errored = isWritableErrored(stream) || isReadableErrored(stream)\n    if (errored && typeof errored !== 'boolean') {\n      return callback.call(stream, errored)\n    }\n    callback.call(stream)\n  }\n  const onrequest = () => {\n    stream.req.on('finish', onfinish)\n  }\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish)\n    if (!willEmitClose) {\n      stream.on('abort', onclose)\n    }\n    if (stream.req) {\n      onrequest()\n    } else {\n      stream.on('request', onrequest)\n    }\n  } else if (writable && !wState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish)\n    stream.on('close', onlegacyfinish)\n  }\n\n  // Not all streams will emit 'close' after 'aborted'.\n  if (!willEmitClose && typeof stream.aborted === 'boolean') {\n    stream.on('aborted', onclose)\n  }\n  stream.on('end', onend)\n  stream.on('finish', onfinish)\n  if (options.error !== false) {\n    stream.on('error', onerror)\n  }\n  stream.on('close', onclose)\n  if (closed) {\n    process.nextTick(onclose)\n  } else if (\n    (wState !== null && wState !== undefined && wState.errorEmitted) ||\n    (rState !== null && rState !== undefined && rState.errorEmitted)\n  ) {\n    if (!willEmitClose) {\n      process.nextTick(onclosed)\n    }\n  } else if (\n    !readable &&\n    (!willEmitClose || isReadable(stream)) &&\n    (writableFinished || isWritable(stream) === false)\n  ) {\n    process.nextTick(onclosed)\n  } else if (\n    !writable &&\n    (!willEmitClose || isWritable(stream)) &&\n    (readableFinished || isReadable(stream) === false)\n  ) {\n    process.nextTick(onclosed)\n  } else if (rState && stream.req && stream.aborted) {\n    process.nextTick(onclosed)\n  }\n  const cleanup = () => {\n    callback = nop\n    stream.removeListener('aborted', onclose)\n    stream.removeListener('complete', onfinish)\n    stream.removeListener('abort', onclose)\n    stream.removeListener('request', onrequest)\n    if (stream.req) stream.req.removeListener('finish', onfinish)\n    stream.removeListener('end', onlegacyfinish)\n    stream.removeListener('close', onlegacyfinish)\n    stream.removeListener('finish', onfinish)\n    stream.removeListener('end', onend)\n    stream.removeListener('error', onerror)\n    stream.removeListener('close', onclose)\n  }\n  if (options.signal && !closed) {\n    const abort = () => {\n      // Keep it because cleanup removes it.\n      const endCallback = callback\n      cleanup()\n      endCallback.call(\n        stream,\n        new AbortError(undefined, {\n          cause: options.signal.reason\n        })\n      )\n    }\n    if (options.signal.aborted) {\n      process.nextTick(abort)\n    } else {\n      addAbortListener = addAbortListener || require('../../ours/util').addAbortListener\n      const disposable = addAbortListener(options.signal, abort)\n      const originalCallback = callback\n      callback = once((...args) => {\n        disposable[SymbolDispose]()\n        originalCallback.apply(stream, args)\n      })\n    }\n  }\n  return cleanup\n}\nfunction eosWeb(stream, options, callback) {\n  let isAborted = false\n  let abort = nop\n  if (options.signal) {\n    abort = () => {\n      isAborted = true\n      callback.call(\n        stream,\n        new AbortError(undefined, {\n          cause: options.signal.reason\n        })\n      )\n    }\n    if (options.signal.aborted) {\n      process.nextTick(abort)\n    } else {\n      addAbortListener = addAbortListener || require('../../ours/util').addAbortListener\n      const disposable = addAbortListener(options.signal, abort)\n      const originalCallback = callback\n      callback = once((...args) => {\n        disposable[SymbolDispose]()\n        originalCallback.apply(stream, args)\n      })\n    }\n  }\n  const resolverFn = (...args) => {\n    if (!isAborted) {\n      process.nextTick(() => callback.apply(stream, args))\n    }\n  }\n  PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn)\n  return nop\n}\nfunction finished(stream, opts) {\n  var _opts\n  let autoCleanup = false\n  if (opts === null) {\n    opts = kEmptyObject\n  }\n  if ((_opts = opts) !== null && _opts !== undefined && _opts.cleanup) {\n    validateBoolean(opts.cleanup, 'cleanup')\n    autoCleanup = opts.cleanup\n  }\n  return new Promise((resolve, reject) => {\n    const cleanup = eos(stream, opts, (err) => {\n      if (autoCleanup) {\n        cleanup()\n      }\n      if (err) {\n        reject(err)\n      } else {\n        resolve()\n      }\n    })\n  })\n}\nmodule.exports = eos\nmodule.exports.finished = finished\n","/* eslint jsdoc/require-jsdoc: \"error\" */\n\n'use strict'\n\nconst {\n  ArrayIsArray,\n  ArrayPrototypeIncludes,\n  ArrayPrototypeJoin,\n  ArrayPrototypeMap,\n  NumberIsInteger,\n  NumberIsNaN,\n  NumberMAX_SAFE_INTEGER,\n  NumberMIN_SAFE_INTEGER,\n  NumberParseInt,\n  ObjectPrototypeHasOwnProperty,\n  RegExpPrototypeExec,\n  String,\n  StringPrototypeToUpperCase,\n  StringPrototypeTrim\n} = require('../ours/primordials')\nconst {\n  hideStackFrames,\n  codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }\n} = require('../ours/errors')\nconst { normalizeEncoding } = require('../ours/util')\nconst { isAsyncFunction, isArrayBufferView } = require('../ours/util').types\nconst signals = {}\n\n/**\n * @param {*} value\n * @returns {boolean}\n */\nfunction isInt32(value) {\n  return value === (value | 0)\n}\n\n/**\n * @param {*} value\n * @returns {boolean}\n */\nfunction isUint32(value) {\n  return value === value >>> 0\n}\nconst octalReg = /^[0-7]+$/\nconst modeDesc = 'must be a 32-bit unsigned integer or an octal string'\n\n/**\n * Parse and validate values that will be converted into mode_t (the S_*\n * constants). Only valid numbers and octal strings are allowed. They could be\n * converted to 32-bit unsigned integers or non-negative signed integers in the\n * C++ land, but any value higher than 0o777 will result in platform-specific\n * behaviors.\n * @param {*} value Values to be validated\n * @param {string} name Name of the argument\n * @param {number} [def] If specified, will be returned for invalid values\n * @returns {number}\n */\nfunction parseFileMode(value, name, def) {\n  if (typeof value === 'undefined') {\n    value = def\n  }\n  if (typeof value === 'string') {\n    if (RegExpPrototypeExec(octalReg, value) === null) {\n      throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc)\n    }\n    value = NumberParseInt(value, 8)\n  }\n  validateUint32(value, name)\n  return value\n}\n\n/**\n * @callback validateInteger\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateInteger} */\nconst validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {\n  if (typeof value !== 'number') throw new ERR_INVALID_ARG_TYPE(name, 'number', value)\n  if (!NumberIsInteger(value)) throw new ERR_OUT_OF_RANGE(name, 'an integer', value)\n  if (value < min || value > max) throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value)\n})\n\n/**\n * @callback validateInt32\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateInt32} */\nconst validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {\n  // The defaults for min and max correspond to the limits of 32-bit integers.\n  if (typeof value !== 'number') {\n    throw new ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n  if (!NumberIsInteger(value)) {\n    throw new ERR_OUT_OF_RANGE(name, 'an integer', value)\n  }\n  if (value < min || value > max) {\n    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value)\n  }\n})\n\n/**\n * @callback validateUint32\n * @param {*} value\n * @param {string} name\n * @param {number|boolean} [positive=false]\n * @returns {asserts value is number}\n */\n\n/** @type {validateUint32} */\nconst validateUint32 = hideStackFrames((value, name, positive = false) => {\n  if (typeof value !== 'number') {\n    throw new ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n  if (!NumberIsInteger(value)) {\n    throw new ERR_OUT_OF_RANGE(name, 'an integer', value)\n  }\n  const min = positive ? 1 : 0\n  // 2 ** 32 === 4294967296\n  const max = 4294967295\n  if (value < min || value > max) {\n    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value)\n  }\n})\n\n/**\n * @callback validateString\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string}\n */\n\n/** @type {validateString} */\nfunction validateString(value, name) {\n  if (typeof value !== 'string') throw new ERR_INVALID_ARG_TYPE(name, 'string', value)\n}\n\n/**\n * @callback validateNumber\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateNumber} */\nfunction validateNumber(value, name, min = undefined, max) {\n  if (typeof value !== 'number') throw new ERR_INVALID_ARG_TYPE(name, 'number', value)\n  if (\n    (min != null && value < min) ||\n    (max != null && value > max) ||\n    ((min != null || max != null) && NumberIsNaN(value))\n  ) {\n    throw new ERR_OUT_OF_RANGE(\n      name,\n      `${min != null ? `>= ${min}` : ''}${min != null && max != null ? ' && ' : ''}${max != null ? `<= ${max}` : ''}`,\n      value\n    )\n  }\n}\n\n/**\n * @callback validateOneOf\n * @template T\n * @param {T} value\n * @param {string} name\n * @param {T[]} oneOf\n */\n\n/** @type {validateOneOf} */\nconst validateOneOf = hideStackFrames((value, name, oneOf) => {\n  if (!ArrayPrototypeIncludes(oneOf, value)) {\n    const allowed = ArrayPrototypeJoin(\n      ArrayPrototypeMap(oneOf, (v) => (typeof v === 'string' ? `'${v}'` : String(v))),\n      ', '\n    )\n    const reason = 'must be one of: ' + allowed\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason)\n  }\n})\n\n/**\n * @callback validateBoolean\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is boolean}\n */\n\n/** @type {validateBoolean} */\nfunction validateBoolean(value, name) {\n  if (typeof value !== 'boolean') throw new ERR_INVALID_ARG_TYPE(name, 'boolean', value)\n}\n\n/**\n * @param {any} options\n * @param {string} key\n * @param {boolean} defaultValue\n * @returns {boolean}\n */\nfunction getOwnPropertyValueOrDefault(options, key, defaultValue) {\n  return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key]\n}\n\n/**\n * @callback validateObject\n * @param {*} value\n * @param {string} name\n * @param {{\n *   allowArray?: boolean,\n *   allowFunction?: boolean,\n *   nullable?: boolean\n * }} [options]\n */\n\n/** @type {validateObject} */\nconst validateObject = hideStackFrames((value, name, options = null) => {\n  const allowArray = getOwnPropertyValueOrDefault(options, 'allowArray', false)\n  const allowFunction = getOwnPropertyValueOrDefault(options, 'allowFunction', false)\n  const nullable = getOwnPropertyValueOrDefault(options, 'nullable', false)\n  if (\n    (!nullable && value === null) ||\n    (!allowArray && ArrayIsArray(value)) ||\n    (typeof value !== 'object' && (!allowFunction || typeof value !== 'function'))\n  ) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'Object', value)\n  }\n})\n\n/**\n * @callback validateDictionary - We are using the Web IDL Standard definition\n *                                of \"dictionary\" here, which means any value\n *                                whose Type is either Undefined, Null, or\n *                                Object (which includes functions).\n * @param {*} value\n * @param {string} name\n * @see https://webidl.spec.whatwg.org/#es-dictionary\n * @see https://tc39.es/ecma262/#table-typeof-operator-results\n */\n\n/** @type {validateDictionary} */\nconst validateDictionary = hideStackFrames((value, name) => {\n  if (value != null && typeof value !== 'object' && typeof value !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE(name, 'a dictionary', value)\n  }\n})\n\n/**\n * @callback validateArray\n * @param {*} value\n * @param {string} name\n * @param {number} [minLength]\n * @returns {asserts value is any[]}\n */\n\n/** @type {validateArray} */\nconst validateArray = hideStackFrames((value, name, minLength = 0) => {\n  if (!ArrayIsArray(value)) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'Array', value)\n  }\n  if (value.length < minLength) {\n    const reason = `must be longer than ${minLength}`\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason)\n  }\n})\n\n/**\n * @callback validateStringArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string[]}\n */\n\n/** @type {validateStringArray} */\nfunction validateStringArray(value, name) {\n  validateArray(value, name)\n  for (let i = 0; i < value.length; i++) {\n    validateString(value[i], `${name}[${i}]`)\n  }\n}\n\n/**\n * @callback validateBooleanArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is boolean[]}\n */\n\n/** @type {validateBooleanArray} */\nfunction validateBooleanArray(value, name) {\n  validateArray(value, name)\n  for (let i = 0; i < value.length; i++) {\n    validateBoolean(value[i], `${name}[${i}]`)\n  }\n}\n\n/**\n * @callback validateAbortSignalArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is AbortSignal[]}\n */\n\n/** @type {validateAbortSignalArray} */\nfunction validateAbortSignalArray(value, name) {\n  validateArray(value, name)\n  for (let i = 0; i < value.length; i++) {\n    const signal = value[i]\n    const indexedName = `${name}[${i}]`\n    if (signal == null) {\n      throw new ERR_INVALID_ARG_TYPE(indexedName, 'AbortSignal', signal)\n    }\n    validateAbortSignal(signal, indexedName)\n  }\n}\n\n/**\n * @param {*} signal\n * @param {string} [name='signal']\n * @returns {asserts signal is keyof signals}\n */\nfunction validateSignalName(signal, name = 'signal') {\n  validateString(signal, name)\n  if (signals[signal] === undefined) {\n    if (signals[StringPrototypeToUpperCase(signal)] !== undefined) {\n      throw new ERR_UNKNOWN_SIGNAL(signal + ' (signals must use all capital letters)')\n    }\n    throw new ERR_UNKNOWN_SIGNAL(signal)\n  }\n}\n\n/**\n * @callback validateBuffer\n * @param {*} buffer\n * @param {string} [name='buffer']\n * @returns {asserts buffer is ArrayBufferView}\n */\n\n/** @type {validateBuffer} */\nconst validateBuffer = hideStackFrames((buffer, name = 'buffer') => {\n  if (!isArrayBufferView(buffer)) {\n    throw new ERR_INVALID_ARG_TYPE(name, ['Buffer', 'TypedArray', 'DataView'], buffer)\n  }\n})\n\n/**\n * @param {string} data\n * @param {string} encoding\n */\nfunction validateEncoding(data, encoding) {\n  const normalizedEncoding = normalizeEncoding(encoding)\n  const length = data.length\n  if (normalizedEncoding === 'hex' && length % 2 !== 0) {\n    throw new ERR_INVALID_ARG_VALUE('encoding', encoding, `is invalid for data of length ${length}`)\n  }\n}\n\n/**\n * Check that the port number is not NaN when coerced to a number,\n * is an integer and that it falls within the legal range of port numbers.\n * @param {*} port\n * @param {string} [name='Port']\n * @param {boolean} [allowZero=true]\n * @returns {number}\n */\nfunction validatePort(port, name = 'Port', allowZero = true) {\n  if (\n    (typeof port !== 'number' && typeof port !== 'string') ||\n    (typeof port === 'string' && StringPrototypeTrim(port).length === 0) ||\n    +port !== +port >>> 0 ||\n    port > 0xffff ||\n    (port === 0 && !allowZero)\n  ) {\n    throw new ERR_SOCKET_BAD_PORT(name, port, allowZero)\n  }\n  return port | 0\n}\n\n/**\n * @callback validateAbortSignal\n * @param {*} signal\n * @param {string} name\n */\n\n/** @type {validateAbortSignal} */\nconst validateAbortSignal = hideStackFrames((signal, name) => {\n  if (signal !== undefined && (signal === null || typeof signal !== 'object' || !('aborted' in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal)\n  }\n})\n\n/**\n * @callback validateFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */\n\n/** @type {validateFunction} */\nconst validateFunction = hideStackFrames((value, name) => {\n  if (typeof value !== 'function') throw new ERR_INVALID_ARG_TYPE(name, 'Function', value)\n})\n\n/**\n * @callback validatePlainFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */\n\n/** @type {validatePlainFunction} */\nconst validatePlainFunction = hideStackFrames((value, name) => {\n  if (typeof value !== 'function' || isAsyncFunction(value)) throw new ERR_INVALID_ARG_TYPE(name, 'Function', value)\n})\n\n/**\n * @callback validateUndefined\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is undefined}\n */\n\n/** @type {validateUndefined} */\nconst validateUndefined = hideStackFrames((value, name) => {\n  if (value !== undefined) throw new ERR_INVALID_ARG_TYPE(name, 'undefined', value)\n})\n\n/**\n * @template T\n * @param {T} value\n * @param {string} name\n * @param {T[]} union\n */\nfunction validateUnion(value, name, union) {\n  if (!ArrayPrototypeIncludes(union, value)) {\n    throw new ERR_INVALID_ARG_TYPE(name, `('${ArrayPrototypeJoin(union, '|')}')`, value)\n  }\n}\n\n/*\n  The rules for the Link header field are described here:\n  https://www.rfc-editor.org/rfc/rfc8288.html#section-3\n\n  This regex validates any string surrounded by angle brackets\n  (not necessarily a valid URI reference) followed by zero or more\n  link-params separated by semicolons.\n*/\nconst linkValueRegExp = /^(?:<[^>]*>)(?:\\s*;\\s*[^;\"\\s]+(?:=(\")?[^;\"\\s]*\\1)?)*$/\n\n/**\n * @param {any} value\n * @param {string} name\n */\nfunction validateLinkHeaderFormat(value, name) {\n  if (typeof value === 'undefined' || !RegExpPrototypeExec(linkValueRegExp, value)) {\n    throw new ERR_INVALID_ARG_VALUE(\n      name,\n      value,\n      'must be an array or string of format \"</styles.css>; rel=preload; as=style\"'\n    )\n  }\n}\n\n/**\n * @param {any} hints\n * @return {string}\n */\nfunction validateLinkHeaderValue(hints) {\n  if (typeof hints === 'string') {\n    validateLinkHeaderFormat(hints, 'hints')\n    return hints\n  } else if (ArrayIsArray(hints)) {\n    const hintsLength = hints.length\n    let result = ''\n    if (hintsLength === 0) {\n      return result\n    }\n    for (let i = 0; i < hintsLength; i++) {\n      const link = hints[i]\n      validateLinkHeaderFormat(link, 'hints')\n      result += link\n      if (i !== hintsLength - 1) {\n        result += ', '\n      }\n    }\n    return result\n  }\n  throw new ERR_INVALID_ARG_VALUE(\n    'hints',\n    hints,\n    'must be an array or string of format \"</styles.css>; rel=preload; as=style\"'\n  )\n}\nmodule.exports = {\n  isInt32,\n  isUint32,\n  parseFileMode,\n  validateArray,\n  validateStringArray,\n  validateBooleanArray,\n  validateAbortSignalArray,\n  validateBoolean,\n  validateBuffer,\n  validateDictionary,\n  validateEncoding,\n  validateFunction,\n  validateInt32,\n  validateInteger,\n  validateNumber,\n  validateObject,\n  validateOneOf,\n  validatePlainFunction,\n  validatePort,\n  validateSignalName,\n  validateString,\n  validateUint32,\n  validateUndefined,\n  validateUnion,\n  validateAbortSignal,\n  validateLinkHeaderValue\n}\n","'use strict'\n\nconst { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array } = require('../../ours/primordials')\nconst { Buffer } = require('buffer')\nconst { inspect } = require('../../ours/util')\nmodule.exports = class BufferList {\n  constructor() {\n    this.head = null\n    this.tail = null\n    this.length = 0\n  }\n  push(v) {\n    const entry = {\n      data: v,\n      next: null\n    }\n    if (this.length > 0) this.tail.next = entry\n    else this.head = entry\n    this.tail = entry\n    ++this.length\n  }\n  unshift(v) {\n    const entry = {\n      data: v,\n      next: this.head\n    }\n    if (this.length === 0) this.tail = entry\n    this.head = entry\n    ++this.length\n  }\n  shift() {\n    if (this.length === 0) return\n    const ret = this.head.data\n    if (this.length === 1) this.head = this.tail = null\n    else this.head = this.head.next\n    --this.length\n    return ret\n  }\n  clear() {\n    this.head = this.tail = null\n    this.length = 0\n  }\n  join(s) {\n    if (this.length === 0) return ''\n    let p = this.head\n    let ret = '' + p.data\n    while ((p = p.next) !== null) ret += s + p.data\n    return ret\n  }\n  concat(n) {\n    if (this.length === 0) return Buffer.alloc(0)\n    const ret = Buffer.allocUnsafe(n >>> 0)\n    let p = this.head\n    let i = 0\n    while (p) {\n      TypedArrayPrototypeSet(ret, p.data, i)\n      i += p.data.length\n      p = p.next\n    }\n    return ret\n  }\n\n  // Consumes a specified amount of bytes or characters from the buffered data.\n  consume(n, hasStrings) {\n    const data = this.head.data\n    if (n < data.length) {\n      // `slice` is the same for buffers and strings.\n      const slice = data.slice(0, n)\n      this.head.data = data.slice(n)\n      return slice\n    }\n    if (n === data.length) {\n      // First chunk is a perfect match.\n      return this.shift()\n    }\n    // Result spans more than one buffer.\n    return hasStrings ? this._getString(n) : this._getBuffer(n)\n  }\n  first() {\n    return this.head.data\n  }\n  *[SymbolIterator]() {\n    for (let p = this.head; p; p = p.next) {\n      yield p.data\n    }\n  }\n\n  // Consumes a specified amount of characters from the buffered data.\n  _getString(n) {\n    let ret = ''\n    let p = this.head\n    let c = 0\n    do {\n      const str = p.data\n      if (n > str.length) {\n        ret += str\n        n -= str.length\n      } else {\n        if (n === str.length) {\n          ret += str\n          ++c\n          if (p.next) this.head = p.next\n          else this.head = this.tail = null\n        } else {\n          ret += StringPrototypeSlice(str, 0, n)\n          this.head = p\n          p.data = StringPrototypeSlice(str, n)\n        }\n        break\n      }\n      ++c\n    } while ((p = p.next) !== null)\n    this.length -= c\n    return ret\n  }\n\n  // Consumes a specified amount of bytes from the buffered data.\n  _getBuffer(n) {\n    const ret = Buffer.allocUnsafe(n)\n    const retLen = n\n    let p = this.head\n    let c = 0\n    do {\n      const buf = p.data\n      if (n > buf.length) {\n        TypedArrayPrototypeSet(ret, buf, retLen - n)\n        n -= buf.length\n      } else {\n        if (n === buf.length) {\n          TypedArrayPrototypeSet(ret, buf, retLen - n)\n          ++c\n          if (p.next) this.head = p.next\n          else this.head = this.tail = null\n        } else {\n          TypedArrayPrototypeSet(ret, new Uint8Array(buf.buffer, buf.byteOffset, n), retLen - n)\n          this.head = p\n          p.data = buf.slice(n)\n        }\n        break\n      }\n      ++c\n    } while ((p = p.next) !== null)\n    this.length -= c\n    return ret\n  }\n\n  // Make sure the linked list only shows the minimal necessary information.\n  [Symbol.for('nodejs.util.inspect.custom')](_, options) {\n    return inspect(this, {\n      ...options,\n      // Only inspect one level.\n      depth: 0,\n      // It should not recurse.\n      customInspect: false\n    })\n  }\n}\n","'use strict'\n\n/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n\nconst {\n  aggregateTwoErrors,\n  codes: { ERR_MULTIPLE_CALLBACK },\n  AbortError\n} = require('../../ours/errors')\nconst { Symbol } = require('../../ours/primordials')\nconst { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = require('./utils')\nconst kDestroy = Symbol('kDestroy')\nconst kConstruct = Symbol('kConstruct')\nfunction checkError(err, w, r) {\n  if (err) {\n    // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n    err.stack // eslint-disable-line no-unused-expressions\n\n    if (w && !w.errored) {\n      w.errored = err\n    }\n    if (r && !r.errored) {\n      r.errored = err\n    }\n  }\n}\n\n// Backwards compat. cb() is undocumented and unused in core but\n// unfortunately might be used by modules.\nfunction destroy(err, cb) {\n  const r = this._readableState\n  const w = this._writableState\n  // With duplex streams we use the writable side for state.\n  const s = w || r\n  if ((w !== null && w !== undefined && w.destroyed) || (r !== null && r !== undefined && r.destroyed)) {\n    if (typeof cb === 'function') {\n      cb()\n    }\n    return this\n  }\n\n  // We set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n  checkError(err, w, r)\n  if (w) {\n    w.destroyed = true\n  }\n  if (r) {\n    r.destroyed = true\n  }\n\n  // If still constructing then defer calling _destroy.\n  if (!s.constructed) {\n    this.once(kDestroy, function (er) {\n      _destroy(this, aggregateTwoErrors(er, err), cb)\n    })\n  } else {\n    _destroy(this, err, cb)\n  }\n  return this\n}\nfunction _destroy(self, err, cb) {\n  let called = false\n  function onDestroy(err) {\n    if (called) {\n      return\n    }\n    called = true\n    const r = self._readableState\n    const w = self._writableState\n    checkError(err, w, r)\n    if (w) {\n      w.closed = true\n    }\n    if (r) {\n      r.closed = true\n    }\n    if (typeof cb === 'function') {\n      cb(err)\n    }\n    if (err) {\n      process.nextTick(emitErrorCloseNT, self, err)\n    } else {\n      process.nextTick(emitCloseNT, self)\n    }\n  }\n  try {\n    self._destroy(err || null, onDestroy)\n  } catch (err) {\n    onDestroy(err)\n  }\n}\nfunction emitErrorCloseNT(self, err) {\n  emitErrorNT(self, err)\n  emitCloseNT(self)\n}\nfunction emitCloseNT(self) {\n  const r = self._readableState\n  const w = self._writableState\n  if (w) {\n    w.closeEmitted = true\n  }\n  if (r) {\n    r.closeEmitted = true\n  }\n  if ((w !== null && w !== undefined && w.emitClose) || (r !== null && r !== undefined && r.emitClose)) {\n    self.emit('close')\n  }\n}\nfunction emitErrorNT(self, err) {\n  const r = self._readableState\n  const w = self._writableState\n  if ((w !== null && w !== undefined && w.errorEmitted) || (r !== null && r !== undefined && r.errorEmitted)) {\n    return\n  }\n  if (w) {\n    w.errorEmitted = true\n  }\n  if (r) {\n    r.errorEmitted = true\n  }\n  self.emit('error', err)\n}\nfunction undestroy() {\n  const r = this._readableState\n  const w = this._writableState\n  if (r) {\n    r.constructed = true\n    r.closed = false\n    r.closeEmitted = false\n    r.destroyed = false\n    r.errored = null\n    r.errorEmitted = false\n    r.reading = false\n    r.ended = r.readable === false\n    r.endEmitted = r.readable === false\n  }\n  if (w) {\n    w.constructed = true\n    w.destroyed = false\n    w.closed = false\n    w.closeEmitted = false\n    w.errored = null\n    w.errorEmitted = false\n    w.finalCalled = false\n    w.prefinished = false\n    w.ended = w.writable === false\n    w.ending = w.writable === false\n    w.finished = w.writable === false\n  }\n}\nfunction errorOrDestroy(stream, err, sync) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n\n  const r = stream._readableState\n  const w = stream._writableState\n  if ((w !== null && w !== undefined && w.destroyed) || (r !== null && r !== undefined && r.destroyed)) {\n    return this\n  }\n  if ((r !== null && r !== undefined && r.autoDestroy) || (w !== null && w !== undefined && w.autoDestroy))\n    stream.destroy(err)\n  else if (err) {\n    // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n    err.stack // eslint-disable-line no-unused-expressions\n\n    if (w && !w.errored) {\n      w.errored = err\n    }\n    if (r && !r.errored) {\n      r.errored = err\n    }\n    if (sync) {\n      process.nextTick(emitErrorNT, stream, err)\n    } else {\n      emitErrorNT(stream, err)\n    }\n  }\n}\nfunction construct(stream, cb) {\n  if (typeof stream._construct !== 'function') {\n    return\n  }\n  const r = stream._readableState\n  const w = stream._writableState\n  if (r) {\n    r.constructed = false\n  }\n  if (w) {\n    w.constructed = false\n  }\n  stream.once(kConstruct, cb)\n  if (stream.listenerCount(kConstruct) > 1) {\n    // Duplex\n    return\n  }\n  process.nextTick(constructNT, stream)\n}\nfunction constructNT(stream) {\n  let called = false\n  function onConstruct(err) {\n    if (called) {\n      errorOrDestroy(stream, err !== null && err !== undefined ? err : new ERR_MULTIPLE_CALLBACK())\n      return\n    }\n    called = true\n    const r = stream._readableState\n    const w = stream._writableState\n    const s = w || r\n    if (r) {\n      r.constructed = true\n    }\n    if (w) {\n      w.constructed = true\n    }\n    if (s.destroyed) {\n      stream.emit(kDestroy, err)\n    } else if (err) {\n      errorOrDestroy(stream, err, true)\n    } else {\n      process.nextTick(emitConstructNT, stream)\n    }\n  }\n  try {\n    stream._construct((err) => {\n      process.nextTick(onConstruct, err)\n    })\n  } catch (err) {\n    process.nextTick(onConstruct, err)\n  }\n}\nfunction emitConstructNT(stream) {\n  stream.emit(kConstruct)\n}\nfunction isRequest(stream) {\n  return (stream === null || stream === undefined ? undefined : stream.setHeader) && typeof stream.abort === 'function'\n}\nfunction emitCloseLegacy(stream) {\n  stream.emit('close')\n}\nfunction emitErrorCloseLegacy(stream, err) {\n  stream.emit('error', err)\n  process.nextTick(emitCloseLegacy, stream)\n}\n\n// Normalize destroy for legacy.\nfunction destroyer(stream, err) {\n  if (!stream || isDestroyed(stream)) {\n    return\n  }\n  if (!err && !isFinished(stream)) {\n    err = new AbortError()\n  }\n\n  // TODO: Remove isRequest branches.\n  if (isServerRequest(stream)) {\n    stream.socket = null\n    stream.destroy(err)\n  } else if (isRequest(stream)) {\n    stream.abort()\n  } else if (isRequest(stream.req)) {\n    stream.req.abort()\n  } else if (typeof stream.destroy === 'function') {\n    stream.destroy(err)\n  } else if (typeof stream.close === 'function') {\n    // TODO: Don't lose err?\n    stream.close()\n  } else if (err) {\n    process.nextTick(emitErrorCloseLegacy, stream, err)\n  } else {\n    process.nextTick(emitCloseLegacy, stream)\n  }\n  if (!stream.destroyed) {\n    stream[kIsDestroyed] = true\n  }\n}\nmodule.exports = {\n  construct,\n  destroyer,\n  destroy,\n  undestroy,\n  errorOrDestroy\n}\n","'use strict'\n\nconst { MathFloor, NumberIsInteger } = require('../../ours/primordials')\nconst { validateInteger } = require('../validators')\nconst { ERR_INVALID_ARG_VALUE } = require('../../ours/errors').codes\nlet defaultHighWaterMarkBytes = 16 * 1024\nlet defaultHighWaterMarkObjectMode = 16\nfunction highWaterMarkFrom(options, isDuplex, duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null\n}\nfunction getDefaultHighWaterMark(objectMode) {\n  return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes\n}\nfunction setDefaultHighWaterMark(objectMode, value) {\n  validateInteger(value, 'value', 0)\n  if (objectMode) {\n    defaultHighWaterMarkObjectMode = value\n  } else {\n    defaultHighWaterMarkBytes = value\n  }\n}\nfunction getHighWaterMark(state, options, duplexKey, isDuplex) {\n  const hwm = highWaterMarkFrom(options, isDuplex, duplexKey)\n  if (hwm != null) {\n    if (!NumberIsInteger(hwm) || hwm < 0) {\n      const name = isDuplex ? `options.${duplexKey}` : 'options.highWaterMark'\n      throw new ERR_INVALID_ARG_VALUE(name, hwm)\n    }\n    return MathFloor(hwm)\n  }\n\n  // Default value\n  return getDefaultHighWaterMark(state.objectMode)\n}\nmodule.exports = {\n  getHighWaterMark,\n  getDefaultHighWaterMark,\n  setDefaultHighWaterMark\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}","/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","'use strict'\n\n/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n\nconst { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require('../../ours/primordials')\nconst { Buffer } = require('buffer')\nconst { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } = require('../../ours/errors').codes\nfunction from(Readable, iterable, opts) {\n  let iterator\n  if (typeof iterable === 'string' || iterable instanceof Buffer) {\n    return new Readable({\n      objectMode: true,\n      ...opts,\n      read() {\n        this.push(iterable)\n        this.push(null)\n      }\n    })\n  }\n  let isAsync\n  if (iterable && iterable[SymbolAsyncIterator]) {\n    isAsync = true\n    iterator = iterable[SymbolAsyncIterator]()\n  } else if (iterable && iterable[SymbolIterator]) {\n    isAsync = false\n    iterator = iterable[SymbolIterator]()\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('iterable', ['Iterable'], iterable)\n  }\n  const readable = new Readable({\n    objectMode: true,\n    highWaterMark: 1,\n    // TODO(ronag): What options should be allowed?\n    ...opts\n  })\n\n  // Flag to protect against _read\n  // being called before last iteration completion.\n  let reading = false\n  readable._read = function () {\n    if (!reading) {\n      reading = true\n      next()\n    }\n  }\n  readable._destroy = function (error, cb) {\n    PromisePrototypeThen(\n      close(error),\n      () => process.nextTick(cb, error),\n      // nextTick is here in case cb throws\n      (e) => process.nextTick(cb, e || error)\n    )\n  }\n  async function close(error) {\n    const hadError = error !== undefined && error !== null\n    const hasThrow = typeof iterator.throw === 'function'\n    if (hadError && hasThrow) {\n      const { value, done } = await iterator.throw(error)\n      await value\n      if (done) {\n        return\n      }\n    }\n    if (typeof iterator.return === 'function') {\n      const { value } = await iterator.return()\n      await value\n    }\n  }\n  async function next() {\n    for (;;) {\n      try {\n        const { value, done } = isAsync ? await iterator.next() : iterator.next()\n        if (done) {\n          readable.push(null)\n        } else {\n          const res = value && typeof value.then === 'function' ? await value : value\n          if (res === null) {\n            reading = false\n            throw new ERR_STREAM_NULL_VALUES()\n          } else if (readable.push(res)) {\n            continue\n          } else {\n            reading = false\n          }\n        }\n      } catch (err) {\n        readable.destroy(err)\n      }\n      break\n    }\n  }\n  return readable\n}\nmodule.exports = from\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict'\n\n/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n\nconst {\n  ArrayPrototypeSlice,\n  Error,\n  FunctionPrototypeSymbolHasInstance,\n  ObjectDefineProperty,\n  ObjectDefineProperties,\n  ObjectSetPrototypeOf,\n  StringPrototypeToLowerCase,\n  Symbol,\n  SymbolHasInstance\n} = require('../../ours/primordials')\nmodule.exports = Writable\nWritable.WritableState = WritableState\nconst { EventEmitter: EE } = require('events')\nconst Stream = require('./legacy').Stream\nconst { Buffer } = require('buffer')\nconst destroyImpl = require('./destroy')\nconst { addAbortSignal } = require('./add-abort-signal')\nconst { getHighWaterMark, getDefaultHighWaterMark } = require('./state')\nconst {\n  ERR_INVALID_ARG_TYPE,\n  ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_MULTIPLE_CALLBACK,\n  ERR_STREAM_CANNOT_PIPE,\n  ERR_STREAM_DESTROYED,\n  ERR_STREAM_ALREADY_FINISHED,\n  ERR_STREAM_NULL_VALUES,\n  ERR_STREAM_WRITE_AFTER_END,\n  ERR_UNKNOWN_ENCODING\n} = require('../../ours/errors').codes\nconst { errorOrDestroy } = destroyImpl\nObjectSetPrototypeOf(Writable.prototype, Stream.prototype)\nObjectSetPrototypeOf(Writable, Stream)\nfunction nop() {}\nconst kOnFinished = Symbol('kOnFinished')\nfunction WritableState(options, stream, isDuplex) {\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof require('./duplex')\n\n  // Object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!(options && options.objectMode)\n  if (isDuplex) this.objectMode = this.objectMode || !!(options && options.writableObjectMode)\n\n  // The point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write().\n  this.highWaterMark = options\n    ? getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex)\n    : getDefaultHighWaterMark(false)\n\n  // if _final has been called.\n  this.finalCalled = false\n\n  // drain event flag.\n  this.needDrain = false\n  // At the start of calling end()\n  this.ending = false\n  // When end() has been called, and returned.\n  this.ended = false\n  // When 'finish' is emitted.\n  this.finished = false\n\n  // Has it been destroyed\n  this.destroyed = false\n\n  // Should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  const noDecode = !!(options && options.decodeStrings === false)\n  this.decodeStrings = !noDecode\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8'\n\n  // Not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0\n\n  // A flag to see when we're in the middle of a write.\n  this.writing = false\n\n  // When true all writes will be buffered until .uncork() call.\n  this.corked = 0\n\n  // A flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true\n\n  // A flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false\n\n  // The callback that's passed to _write(chunk, cb).\n  this.onwrite = onwrite.bind(undefined, stream)\n\n  // The callback that the user supplies to write(chunk, encoding, cb).\n  this.writecb = null\n\n  // The amount that is being written when _write is called.\n  this.writelen = 0\n\n  // Storage for data passed to the afterWrite() callback in case of\n  // synchronous _write() completion.\n  this.afterWriteTickInfo = null\n  resetBuffer(this)\n\n  // Number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted.\n  this.pendingcb = 0\n\n  // Stream is still being constructed and cannot be\n  // destroyed until construction finished or failed.\n  // Async construction is opt in, therefore we start as\n  // constructed.\n  this.constructed = true\n\n  // Emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams.\n  this.prefinished = false\n\n  // True if the error was already emitted and should not be thrown again.\n  this.errorEmitted = false\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = !options || options.emitClose !== false\n\n  // Should .destroy() be called after 'finish' (and potentially 'end').\n  this.autoDestroy = !options || options.autoDestroy !== false\n\n  // Indicates whether the stream has errored. When true all write() calls\n  // should return false. This is needed since when autoDestroy\n  // is disabled we need a way to tell whether the stream has failed.\n  this.errored = null\n\n  // Indicates whether the stream has finished destroying.\n  this.closed = false\n\n  // True if close has been emitted or would have been emitted\n  // depending on emitClose.\n  this.closeEmitted = false\n  this[kOnFinished] = []\n}\nfunction resetBuffer(state) {\n  state.buffered = []\n  state.bufferedIndex = 0\n  state.allBuffers = true\n  state.allNoop = true\n}\nWritableState.prototype.getBuffer = function getBuffer() {\n  return ArrayPrototypeSlice(this.buffered, this.bufferedIndex)\n}\nObjectDefineProperty(WritableState.prototype, 'bufferedRequestCount', {\n  __proto__: null,\n  get() {\n    return this.buffered.length - this.bufferedIndex\n  }\n})\nfunction Writable(options) {\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5.\n  const isDuplex = this instanceof require('./duplex')\n  if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this)) return new Writable(options)\n  this._writableState = new WritableState(options, this, isDuplex)\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write\n    if (typeof options.writev === 'function') this._writev = options.writev\n    if (typeof options.destroy === 'function') this._destroy = options.destroy\n    if (typeof options.final === 'function') this._final = options.final\n    if (typeof options.construct === 'function') this._construct = options.construct\n    if (options.signal) addAbortSignal(options.signal, this)\n  }\n  Stream.call(this, options)\n  destroyImpl.construct(this, () => {\n    const state = this._writableState\n    if (!state.writing) {\n      clearBuffer(this, state)\n    }\n    finishMaybe(this, state)\n  })\n}\nObjectDefineProperty(Writable, SymbolHasInstance, {\n  __proto__: null,\n  value: function (object) {\n    if (FunctionPrototypeSymbolHasInstance(this, object)) return true\n    if (this !== Writable) return false\n    return object && object._writableState instanceof WritableState\n  }\n})\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE())\n}\nfunction _write(stream, chunk, encoding, cb) {\n  const state = stream._writableState\n  if (typeof encoding === 'function') {\n    cb = encoding\n    encoding = state.defaultEncoding\n  } else {\n    if (!encoding) encoding = state.defaultEncoding\n    else if (encoding !== 'buffer' && !Buffer.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding)\n    if (typeof cb !== 'function') cb = nop\n  }\n  if (chunk === null) {\n    throw new ERR_STREAM_NULL_VALUES()\n  } else if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      if (state.decodeStrings !== false) {\n        chunk = Buffer.from(chunk, encoding)\n        encoding = 'buffer'\n      }\n    } else if (chunk instanceof Buffer) {\n      encoding = 'buffer'\n    } else if (Stream._isUint8Array(chunk)) {\n      chunk = Stream._uint8ArrayToBuffer(chunk)\n      encoding = 'buffer'\n    } else {\n      throw new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk)\n    }\n  }\n  let err\n  if (state.ending) {\n    err = new ERR_STREAM_WRITE_AFTER_END()\n  } else if (state.destroyed) {\n    err = new ERR_STREAM_DESTROYED('write')\n  }\n  if (err) {\n    process.nextTick(cb, err)\n    errorOrDestroy(stream, err, true)\n    return err\n  }\n  state.pendingcb++\n  return writeOrBuffer(stream, state, chunk, encoding, cb)\n}\nWritable.prototype.write = function (chunk, encoding, cb) {\n  return _write(this, chunk, encoding, cb) === true\n}\nWritable.prototype.cork = function () {\n  this._writableState.corked++\n}\nWritable.prototype.uncork = function () {\n  const state = this._writableState\n  if (state.corked) {\n    state.corked--\n    if (!state.writing) clearBuffer(this, state)\n  }\n}\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = StringPrototypeToLowerCase(encoding)\n  if (!Buffer.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding)\n  this._writableState.defaultEncoding = encoding\n  return this\n}\n\n// If we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, callback) {\n  const len = state.objectMode ? 1 : chunk.length\n  state.length += len\n\n  // stream._write resets state.length\n  const ret = state.length < state.highWaterMark\n  // We must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true\n  if (state.writing || state.corked || state.errored || !state.constructed) {\n    state.buffered.push({\n      chunk,\n      encoding,\n      callback\n    })\n    if (state.allBuffers && encoding !== 'buffer') {\n      state.allBuffers = false\n    }\n    if (state.allNoop && callback !== nop) {\n      state.allNoop = false\n    }\n  } else {\n    state.writelen = len\n    state.writecb = callback\n    state.writing = true\n    state.sync = true\n    stream._write(chunk, encoding, state.onwrite)\n    state.sync = false\n  }\n\n  // Return false if errored or destroyed in order to break\n  // any synchronous while(stream.write(data)) loops.\n  return ret && !state.errored && !state.destroyed\n}\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len\n  state.writecb = cb\n  state.writing = true\n  state.sync = true\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'))\n  else if (writev) stream._writev(chunk, state.onwrite)\n  else stream._write(chunk, encoding, state.onwrite)\n  state.sync = false\n}\nfunction onwriteError(stream, state, er, cb) {\n  --state.pendingcb\n  cb(er)\n  // Ensure callbacks are invoked even when autoDestroy is\n  // not enabled. Passing `er` here doesn't make sense since\n  // it's related to one specific write, not to the buffered\n  // writes.\n  errorBuffer(state)\n  // This can emit error, but error must always follow cb.\n  errorOrDestroy(stream, er)\n}\nfunction onwrite(stream, er) {\n  const state = stream._writableState\n  const sync = state.sync\n  const cb = state.writecb\n  if (typeof cb !== 'function') {\n    errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK())\n    return\n  }\n  state.writing = false\n  state.writecb = null\n  state.length -= state.writelen\n  state.writelen = 0\n  if (er) {\n    // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n    er.stack // eslint-disable-line no-unused-expressions\n\n    if (!state.errored) {\n      state.errored = er\n    }\n\n    // In case of duplex streams we need to notify the readable side of the\n    // error.\n    if (stream._readableState && !stream._readableState.errored) {\n      stream._readableState.errored = er\n    }\n    if (sync) {\n      process.nextTick(onwriteError, stream, state, er, cb)\n    } else {\n      onwriteError(stream, state, er, cb)\n    }\n  } else {\n    if (state.buffered.length > state.bufferedIndex) {\n      clearBuffer(stream, state)\n    }\n    if (sync) {\n      // It is a common case that the callback passed to .write() is always\n      // the same. In that case, we do not schedule a new nextTick(), but\n      // rather just increase a counter, to improve performance and avoid\n      // memory allocations.\n      if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {\n        state.afterWriteTickInfo.count++\n      } else {\n        state.afterWriteTickInfo = {\n          count: 1,\n          cb,\n          stream,\n          state\n        }\n        process.nextTick(afterWriteTick, state.afterWriteTickInfo)\n      }\n    } else {\n      afterWrite(stream, state, 1, cb)\n    }\n  }\n}\nfunction afterWriteTick({ stream, state, count, cb }) {\n  state.afterWriteTickInfo = null\n  return afterWrite(stream, state, count, cb)\n}\nfunction afterWrite(stream, state, count, cb) {\n  const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain\n  if (needDrain) {\n    state.needDrain = false\n    stream.emit('drain')\n  }\n  while (count-- > 0) {\n    state.pendingcb--\n    cb()\n  }\n  if (state.destroyed) {\n    errorBuffer(state)\n  }\n  finishMaybe(stream, state)\n}\n\n// If there's something in the buffer waiting, then invoke callbacks.\nfunction errorBuffer(state) {\n  if (state.writing) {\n    return\n  }\n  for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {\n    var _state$errored\n    const { chunk, callback } = state.buffered[n]\n    const len = state.objectMode ? 1 : chunk.length\n    state.length -= len\n    callback(\n      (_state$errored = state.errored) !== null && _state$errored !== undefined\n        ? _state$errored\n        : new ERR_STREAM_DESTROYED('write')\n    )\n  }\n  const onfinishCallbacks = state[kOnFinished].splice(0)\n  for (let i = 0; i < onfinishCallbacks.length; i++) {\n    var _state$errored2\n    onfinishCallbacks[i](\n      (_state$errored2 = state.errored) !== null && _state$errored2 !== undefined\n        ? _state$errored2\n        : new ERR_STREAM_DESTROYED('end')\n    )\n  }\n  resetBuffer(state)\n}\n\n// If there's something in the buffer waiting, then process it.\nfunction clearBuffer(stream, state) {\n  if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {\n    return\n  }\n  const { buffered, bufferedIndex, objectMode } = state\n  const bufferedLength = buffered.length - bufferedIndex\n  if (!bufferedLength) {\n    return\n  }\n  let i = bufferedIndex\n  state.bufferProcessing = true\n  if (bufferedLength > 1 && stream._writev) {\n    state.pendingcb -= bufferedLength - 1\n    const callback = state.allNoop\n      ? nop\n      : (err) => {\n          for (let n = i; n < buffered.length; ++n) {\n            buffered[n].callback(err)\n          }\n        }\n    // Make a copy of `buffered` if it's going to be used by `callback` above,\n    // since `doWrite` will mutate the array.\n    const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i)\n    chunks.allBuffers = state.allBuffers\n    doWrite(stream, state, true, state.length, chunks, '', callback)\n    resetBuffer(state)\n  } else {\n    do {\n      const { chunk, encoding, callback } = buffered[i]\n      buffered[i++] = null\n      const len = objectMode ? 1 : chunk.length\n      doWrite(stream, state, false, len, chunk, encoding, callback)\n    } while (i < buffered.length && !state.writing)\n    if (i === buffered.length) {\n      resetBuffer(state)\n    } else if (i > 256) {\n      buffered.splice(0, i)\n      state.bufferedIndex = 0\n    } else {\n      state.bufferedIndex = i\n    }\n  }\n  state.bufferProcessing = false\n}\nWritable.prototype._write = function (chunk, encoding, cb) {\n  if (this._writev) {\n    this._writev(\n      [\n        {\n          chunk,\n          encoding\n        }\n      ],\n      cb\n    )\n  } else {\n    throw new ERR_METHOD_NOT_IMPLEMENTED('_write()')\n  }\n}\nWritable.prototype._writev = null\nWritable.prototype.end = function (chunk, encoding, cb) {\n  const state = this._writableState\n  if (typeof chunk === 'function') {\n    cb = chunk\n    chunk = null\n    encoding = null\n  } else if (typeof encoding === 'function') {\n    cb = encoding\n    encoding = null\n  }\n  let err\n  if (chunk !== null && chunk !== undefined) {\n    const ret = _write(this, chunk, encoding)\n    if (ret instanceof Error) {\n      err = ret\n    }\n  }\n\n  // .end() fully uncorks.\n  if (state.corked) {\n    state.corked = 1\n    this.uncork()\n  }\n  if (err) {\n    // Do nothing...\n  } else if (!state.errored && !state.ending) {\n    // This is forgiving in terms of unnecessary calls to end() and can hide\n    // logic errors. However, usually such errors are harmless and causing a\n    // hard error can be disproportionately destructive. It is not always\n    // trivial for the user to determine whether end() needs to be called\n    // or not.\n\n    state.ending = true\n    finishMaybe(this, state, true)\n    state.ended = true\n  } else if (state.finished) {\n    err = new ERR_STREAM_ALREADY_FINISHED('end')\n  } else if (state.destroyed) {\n    err = new ERR_STREAM_DESTROYED('end')\n  }\n  if (typeof cb === 'function') {\n    if (err || state.finished) {\n      process.nextTick(cb, err)\n    } else {\n      state[kOnFinished].push(cb)\n    }\n  }\n  return this\n}\nfunction needFinish(state) {\n  return (\n    state.ending &&\n    !state.destroyed &&\n    state.constructed &&\n    state.length === 0 &&\n    !state.errored &&\n    state.buffered.length === 0 &&\n    !state.finished &&\n    !state.writing &&\n    !state.errorEmitted &&\n    !state.closeEmitted\n  )\n}\nfunction callFinal(stream, state) {\n  let called = false\n  function onFinish(err) {\n    if (called) {\n      errorOrDestroy(stream, err !== null && err !== undefined ? err : ERR_MULTIPLE_CALLBACK())\n      return\n    }\n    called = true\n    state.pendingcb--\n    if (err) {\n      const onfinishCallbacks = state[kOnFinished].splice(0)\n      for (let i = 0; i < onfinishCallbacks.length; i++) {\n        onfinishCallbacks[i](err)\n      }\n      errorOrDestroy(stream, err, state.sync)\n    } else if (needFinish(state)) {\n      state.prefinished = true\n      stream.emit('prefinish')\n      // Backwards compat. Don't check state.sync here.\n      // Some streams assume 'finish' will be emitted\n      // asynchronously relative to _final callback.\n      state.pendingcb++\n      process.nextTick(finish, stream, state)\n    }\n  }\n  state.sync = true\n  state.pendingcb++\n  try {\n    stream._final(onFinish)\n  } catch (err) {\n    onFinish(err)\n  }\n  state.sync = false\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.finalCalled = true\n      callFinal(stream, state)\n    } else {\n      state.prefinished = true\n      stream.emit('prefinish')\n    }\n  }\n}\nfunction finishMaybe(stream, state, sync) {\n  if (needFinish(state)) {\n    prefinish(stream, state)\n    if (state.pendingcb === 0) {\n      if (sync) {\n        state.pendingcb++\n        process.nextTick(\n          (stream, state) => {\n            if (needFinish(state)) {\n              finish(stream, state)\n            } else {\n              state.pendingcb--\n            }\n          },\n          stream,\n          state\n        )\n      } else if (needFinish(state)) {\n        state.pendingcb++\n        finish(stream, state)\n      }\n    }\n  }\n}\nfunction finish(stream, state) {\n  state.pendingcb--\n  state.finished = true\n  const onfinishCallbacks = state[kOnFinished].splice(0)\n  for (let i = 0; i < onfinishCallbacks.length; i++) {\n    onfinishCallbacks[i]()\n  }\n  stream.emit('finish')\n  if (state.autoDestroy) {\n    // In case of duplex streams we need a way to detect\n    // if the readable side is ready for autoDestroy as well.\n    const rState = stream._readableState\n    const autoDestroy =\n      !rState ||\n      (rState.autoDestroy &&\n        // We don't expect the readable to ever 'end'\n        // if readable is explicitly set to false.\n        (rState.endEmitted || rState.readable === false))\n    if (autoDestroy) {\n      stream.destroy()\n    }\n  }\n}\nObjectDefineProperties(Writable.prototype, {\n  closed: {\n    __proto__: null,\n    get() {\n      return this._writableState ? this._writableState.closed : false\n    }\n  },\n  destroyed: {\n    __proto__: null,\n    get() {\n      return this._writableState ? this._writableState.destroyed : false\n    },\n    set(value) {\n      // Backward compatibility, the user is explicitly managing destroyed.\n      if (this._writableState) {\n        this._writableState.destroyed = value\n      }\n    }\n  },\n  writable: {\n    __proto__: null,\n    get() {\n      const w = this._writableState\n      // w.writable === false means that this is part of a Duplex stream\n      // where the writable side was disabled upon construction.\n      // Compat. The user might manually disable writable side through\n      // deprecated setter.\n      return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended\n    },\n    set(val) {\n      // Backwards compatible.\n      if (this._writableState) {\n        this._writableState.writable = !!val\n      }\n    }\n  },\n  writableFinished: {\n    __proto__: null,\n    get() {\n      return this._writableState ? this._writableState.finished : false\n    }\n  },\n  writableObjectMode: {\n    __proto__: null,\n    get() {\n      return this._writableState ? this._writableState.objectMode : false\n    }\n  },\n  writableBuffer: {\n    __proto__: null,\n    get() {\n      return this._writableState && this._writableState.getBuffer()\n    }\n  },\n  writableEnded: {\n    __proto__: null,\n    get() {\n      return this._writableState ? this._writableState.ending : false\n    }\n  },\n  writableNeedDrain: {\n    __proto__: null,\n    get() {\n      const wState = this._writableState\n      if (!wState) return false\n      return !wState.destroyed && !wState.ending && wState.needDrain\n    }\n  },\n  writableHighWaterMark: {\n    __proto__: null,\n    get() {\n      return this._writableState && this._writableState.highWaterMark\n    }\n  },\n  writableCorked: {\n    __proto__: null,\n    get() {\n      return this._writableState ? this._writableState.corked : 0\n    }\n  },\n  writableLength: {\n    __proto__: null,\n    get() {\n      return this._writableState && this._writableState.length\n    }\n  },\n  errored: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._writableState ? this._writableState.errored : null\n    }\n  },\n  writableAborted: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return !!(\n        this._writableState.writable !== false &&\n        (this._writableState.destroyed || this._writableState.errored) &&\n        !this._writableState.finished\n      )\n    }\n  }\n})\nconst destroy = destroyImpl.destroy\nWritable.prototype.destroy = function (err, cb) {\n  const state = this._writableState\n\n  // Invoke pending callbacks.\n  if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {\n    process.nextTick(errorBuffer, state)\n  }\n  destroy.call(this, err, cb)\n  return this\n}\nWritable.prototype._undestroy = destroyImpl.undestroy\nWritable.prototype._destroy = function (err, cb) {\n  cb(err)\n}\nWritable.prototype[EE.captureRejectionSymbol] = function (err) {\n  this.destroy(err)\n}\nlet webStreamsAdapters\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined) webStreamsAdapters = {}\n  return webStreamsAdapters\n}\nWritable.fromWeb = function (writableStream, options) {\n  return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options)\n}\nWritable.toWeb = function (streamWritable) {\n  return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable)\n}\n","/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n\n;('use strict')\nconst bufferModule = require('buffer')\nconst {\n  isReadable,\n  isWritable,\n  isIterable,\n  isNodeStream,\n  isReadableNodeStream,\n  isWritableNodeStream,\n  isDuplexNodeStream,\n  isReadableStream,\n  isWritableStream\n} = require('./utils')\nconst eos = require('./end-of-stream')\nconst {\n  AbortError,\n  codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE }\n} = require('../../ours/errors')\nconst { destroyer } = require('./destroy')\nconst Duplex = require('./duplex')\nconst Readable = require('./readable')\nconst Writable = require('./writable')\nconst { createDeferredPromise } = require('../../ours/util')\nconst from = require('./from')\nconst Blob = globalThis.Blob || bufferModule.Blob\nconst isBlob =\n  typeof Blob !== 'undefined'\n    ? function isBlob(b) {\n        return b instanceof Blob\n      }\n    : function isBlob(b) {\n        return false\n      }\nconst AbortController = globalThis.AbortController || require('abort-controller').AbortController\nconst { FunctionPrototypeCall } = require('../../ours/primordials')\n\n// This is needed for pre node 17.\nclass Duplexify extends Duplex {\n  constructor(options) {\n    super(options)\n\n    // https://github.com/nodejs/node/pull/34385\n\n    if ((options === null || options === undefined ? undefined : options.readable) === false) {\n      this._readableState.readable = false\n      this._readableState.ended = true\n      this._readableState.endEmitted = true\n    }\n    if ((options === null || options === undefined ? undefined : options.writable) === false) {\n      this._writableState.writable = false\n      this._writableState.ending = true\n      this._writableState.ended = true\n      this._writableState.finished = true\n    }\n  }\n}\nmodule.exports = function duplexify(body, name) {\n  if (isDuplexNodeStream(body)) {\n    return body\n  }\n  if (isReadableNodeStream(body)) {\n    return _duplexify({\n      readable: body\n    })\n  }\n  if (isWritableNodeStream(body)) {\n    return _duplexify({\n      writable: body\n    })\n  }\n  if (isNodeStream(body)) {\n    return _duplexify({\n      writable: false,\n      readable: false\n    })\n  }\n  if (isReadableStream(body)) {\n    return _duplexify({\n      readable: Readable.fromWeb(body)\n    })\n  }\n  if (isWritableStream(body)) {\n    return _duplexify({\n      writable: Writable.fromWeb(body)\n    })\n  }\n  if (typeof body === 'function') {\n    const { value, write, final, destroy } = fromAsyncGen(body)\n    if (isIterable(value)) {\n      return from(Duplexify, value, {\n        // TODO (ronag): highWaterMark?\n        objectMode: true,\n        write,\n        final,\n        destroy\n      })\n    }\n    const then = value === null || value === undefined ? undefined : value.then\n    if (typeof then === 'function') {\n      let d\n      const promise = FunctionPrototypeCall(\n        then,\n        value,\n        (val) => {\n          if (val != null) {\n            throw new ERR_INVALID_RETURN_VALUE('nully', 'body', val)\n          }\n        },\n        (err) => {\n          destroyer(d, err)\n        }\n      )\n      return (d = new Duplexify({\n        // TODO (ronag): highWaterMark?\n        objectMode: true,\n        readable: false,\n        write,\n        final(cb) {\n          final(async () => {\n            try {\n              await promise\n              process.nextTick(cb, null)\n            } catch (err) {\n              process.nextTick(cb, err)\n            }\n          })\n        },\n        destroy\n      }))\n    }\n    throw new ERR_INVALID_RETURN_VALUE('Iterable, AsyncIterable or AsyncFunction', name, value)\n  }\n  if (isBlob(body)) {\n    return duplexify(body.arrayBuffer())\n  }\n  if (isIterable(body)) {\n    return from(Duplexify, body, {\n      // TODO (ronag): highWaterMark?\n      objectMode: true,\n      writable: false\n    })\n  }\n  if (\n    isReadableStream(body === null || body === undefined ? undefined : body.readable) &&\n    isWritableStream(body === null || body === undefined ? undefined : body.writable)\n  ) {\n    return Duplexify.fromWeb(body)\n  }\n  if (\n    typeof (body === null || body === undefined ? undefined : body.writable) === 'object' ||\n    typeof (body === null || body === undefined ? undefined : body.readable) === 'object'\n  ) {\n    const readable =\n      body !== null && body !== undefined && body.readable\n        ? isReadableNodeStream(body === null || body === undefined ? undefined : body.readable)\n          ? body === null || body === undefined\n            ? undefined\n            : body.readable\n          : duplexify(body.readable)\n        : undefined\n    const writable =\n      body !== null && body !== undefined && body.writable\n        ? isWritableNodeStream(body === null || body === undefined ? undefined : body.writable)\n          ? body === null || body === undefined\n            ? undefined\n            : body.writable\n          : duplexify(body.writable)\n        : undefined\n    return _duplexify({\n      readable,\n      writable\n    })\n  }\n  const then = body === null || body === undefined ? undefined : body.then\n  if (typeof then === 'function') {\n    let d\n    FunctionPrototypeCall(\n      then,\n      body,\n      (val) => {\n        if (val != null) {\n          d.push(val)\n        }\n        d.push(null)\n      },\n      (err) => {\n        destroyer(d, err)\n      }\n    )\n    return (d = new Duplexify({\n      objectMode: true,\n      writable: false,\n      read() {}\n    }))\n  }\n  throw new ERR_INVALID_ARG_TYPE(\n    name,\n    [\n      'Blob',\n      'ReadableStream',\n      'WritableStream',\n      'Stream',\n      'Iterable',\n      'AsyncIterable',\n      'Function',\n      '{ readable, writable } pair',\n      'Promise'\n    ],\n    body\n  )\n}\nfunction fromAsyncGen(fn) {\n  let { promise, resolve } = createDeferredPromise()\n  const ac = new AbortController()\n  const signal = ac.signal\n  const value = fn(\n    (async function* () {\n      while (true) {\n        const _promise = promise\n        promise = null\n        const { chunk, done, cb } = await _promise\n        process.nextTick(cb)\n        if (done) return\n        if (signal.aborted)\n          throw new AbortError(undefined, {\n            cause: signal.reason\n          })\n        ;({ promise, resolve } = createDeferredPromise())\n        yield chunk\n      }\n    })(),\n    {\n      signal\n    }\n  )\n  return {\n    value,\n    write(chunk, encoding, cb) {\n      const _resolve = resolve\n      resolve = null\n      _resolve({\n        chunk,\n        done: false,\n        cb\n      })\n    },\n    final(cb) {\n      const _resolve = resolve\n      resolve = null\n      _resolve({\n        done: true,\n        cb\n      })\n    },\n    destroy(err, cb) {\n      ac.abort()\n      cb(err)\n    }\n  }\n}\nfunction _duplexify(pair) {\n  const r = pair.readable && typeof pair.readable.read !== 'function' ? Readable.wrap(pair.readable) : pair.readable\n  const w = pair.writable\n  let readable = !!isReadable(r)\n  let writable = !!isWritable(w)\n  let ondrain\n  let onfinish\n  let onreadable\n  let onclose\n  let d\n  function onfinished(err) {\n    const cb = onclose\n    onclose = null\n    if (cb) {\n      cb(err)\n    } else if (err) {\n      d.destroy(err)\n    }\n  }\n\n  // TODO(ronag): Avoid double buffering.\n  // Implement Writable/Readable/Duplex traits.\n  // See, https://github.com/nodejs/node/pull/33515.\n  d = new Duplexify({\n    // TODO (ronag): highWaterMark?\n    readableObjectMode: !!(r !== null && r !== undefined && r.readableObjectMode),\n    writableObjectMode: !!(w !== null && w !== undefined && w.writableObjectMode),\n    readable,\n    writable\n  })\n  if (writable) {\n    eos(w, (err) => {\n      writable = false\n      if (err) {\n        destroyer(r, err)\n      }\n      onfinished(err)\n    })\n    d._write = function (chunk, encoding, callback) {\n      if (w.write(chunk, encoding)) {\n        callback()\n      } else {\n        ondrain = callback\n      }\n    }\n    d._final = function (callback) {\n      w.end()\n      onfinish = callback\n    }\n    w.on('drain', function () {\n      if (ondrain) {\n        const cb = ondrain\n        ondrain = null\n        cb()\n      }\n    })\n    w.on('finish', function () {\n      if (onfinish) {\n        const cb = onfinish\n        onfinish = null\n        cb()\n      }\n    })\n  }\n  if (readable) {\n    eos(r, (err) => {\n      readable = false\n      if (err) {\n        destroyer(r, err)\n      }\n      onfinished(err)\n    })\n    r.on('readable', function () {\n      if (onreadable) {\n        const cb = onreadable\n        onreadable = null\n        cb()\n      }\n    })\n    r.on('end', function () {\n      d.push(null)\n    })\n    d._read = function () {\n      while (true) {\n        const buf = r.read()\n        if (buf === null) {\n          onreadable = d._read\n          return\n        }\n        if (!d.push(buf)) {\n          return\n        }\n      }\n    }\n  }\n  d._destroy = function (err, callback) {\n    if (!err && onclose !== null) {\n      err = new AbortError()\n    }\n    onreadable = null\n    ondrain = null\n    onfinish = null\n    if (onclose === null) {\n      callback(err)\n    } else {\n      onclose = callback\n      destroyer(w, err)\n      destroyer(r, err)\n    }\n  }\n  return d\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict'\n\nconst { ObjectSetPrototypeOf } = require('../../ours/primordials')\nmodule.exports = PassThrough\nconst Transform = require('./transform')\nObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype)\nObjectSetPrototypeOf(PassThrough, Transform)\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options)\n  Transform.call(this, options)\n}\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk)\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict'\n\nconst { ObjectSetPrototypeOf, Symbol } = require('../../ours/primordials')\nmodule.exports = Transform\nconst { ERR_METHOD_NOT_IMPLEMENTED } = require('../../ours/errors').codes\nconst Duplex = require('./duplex')\nconst { getHighWaterMark } = require('./state')\nObjectSetPrototypeOf(Transform.prototype, Duplex.prototype)\nObjectSetPrototypeOf(Transform, Duplex)\nconst kCallback = Symbol('kCallback')\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options)\n\n  // TODO (ronag): This should preferably always be\n  // applied but would be semver-major. Or even better;\n  // make Transform a Readable with the Writable interface.\n  const readableHighWaterMark = options ? getHighWaterMark(this, options, 'readableHighWaterMark', true) : null\n  if (readableHighWaterMark === 0) {\n    // A Duplex will buffer both on the writable and readable side while\n    // a Transform just wants to buffer hwm number of elements. To avoid\n    // buffering twice we disable buffering on the writable side.\n    options = {\n      ...options,\n      highWaterMark: null,\n      readableHighWaterMark,\n      // TODO (ronag): 0 is not optimal since we have\n      // a \"bug\" where we check needDrain before calling _write and not after.\n      // Refs: https://github.com/nodejs/node/pull/32887\n      // Refs: https://github.com/nodejs/node/pull/35941\n      writableHighWaterMark: options.writableHighWaterMark || 0\n    }\n  }\n  Duplex.call(this, options)\n\n  // We have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false\n  this[kCallback] = null\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform\n    if (typeof options.flush === 'function') this._flush = options.flush\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  // Backwards compat. Some Transform streams incorrectly implement _final\n  // instead of or in addition to _flush. By using 'prefinish' instead of\n  // implementing _final we continue supporting this unfortunate use case.\n  this.on('prefinish', prefinish)\n}\nfunction final(cb) {\n  if (typeof this._flush === 'function' && !this.destroyed) {\n    this._flush((er, data) => {\n      if (er) {\n        if (cb) {\n          cb(er)\n        } else {\n          this.destroy(er)\n        }\n        return\n      }\n      if (data != null) {\n        this.push(data)\n      }\n      this.push(null)\n      if (cb) {\n        cb()\n      }\n    })\n  } else {\n    this.push(null)\n    if (cb) {\n      cb()\n    }\n  }\n}\nfunction prefinish() {\n  if (this._final !== final) {\n    final.call(this)\n  }\n}\nTransform.prototype._final = final\nTransform.prototype._transform = function (chunk, encoding, callback) {\n  throw new ERR_METHOD_NOT_IMPLEMENTED('_transform()')\n}\nTransform.prototype._write = function (chunk, encoding, callback) {\n  const rState = this._readableState\n  const wState = this._writableState\n  const length = rState.length\n  this._transform(chunk, encoding, (err, val) => {\n    if (err) {\n      callback(err)\n      return\n    }\n    if (val != null) {\n      this.push(val)\n    }\n    if (\n      wState.ended ||\n      // Backwards compat.\n      length === rState.length ||\n      // Backwards compat.\n      rState.length < rState.highWaterMark\n    ) {\n      callback()\n    } else {\n      this[kCallback] = callback\n    }\n  })\n}\nTransform.prototype._read = function () {\n  if (this[kCallback]) {\n    const callback = this[kCallback]\n    this[kCallback] = null\n    callback()\n  }\n}\n","const N3 = require('n3');\r\nconst fs = require('fs').promises;\r\nconst { DataFactory } = N3;\r\nconst { namedNode, literal } = DataFactory;\r\n\r\nasync function convertTtlToJson(inputFile, outputFile) {\r\n    const parser = new N3.Parser();\r\n    const store = new N3.Store();\r\n    const shapes = {};\r\n\r\n    const ttlData = await fs.readFile(inputFile, 'utf8');\r\n    await new Promise((resolve, reject) => {\r\n        parser.parse(ttlData, (error, quad, prefixes) => {\r\n            if (error) return reject(error);\r\n            if (quad) store.addQuad(quad);\r\n            else resolve();\r\n        });\r\n    });\r\n\r\n    // Извлекаем NodeShape\r\n    store.getQuads(null, namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'), namedNode('http://www.w3.org/ns/shacl#NodeShape')).forEach(quad => {\r\n        const shapeId = quad.subject.value;\r\n        shapes[shapeId] = {\r\n            id: shapeId,\r\n            targetClass: null,\r\n            properties: []\r\n        };\r\n    });\r\n\r\n    // Извлекаем targetClass\r\n    store.getQuads(null, namedNode('http://www.w3.org/ns/shacl#targetClass'), null).forEach(quad => {\r\n        if (shapes[quad.subject.value]) {\r\n            shapes[quad.subject.value].targetClass = quad.object.value;\r\n        }\r\n    });\r\n\r\n    // Извлекаем свойства\r\n    store.getQuads(null, namedNode('http://www.w3.org/ns/shacl#property'), null).forEach(quad => {\r\n        const shapeId = quad.subject.value;\r\n        if (shapes[shapeId]) {\r\n            shapes[shapeId].properties.push({ propertyId: quad.object.value });\r\n        }\r\n    });\r\n\r\n    // Извлекаем детали свойств\r\n    for (const shape of Object.values(shapes)) {\r\n        for (const prop of shape.properties) {\r\n            const propQuads = store.getQuads(namedNode(prop.propertyId), null, null);\r\n            prop.path = store.getQuads(namedNode(prop.propertyId), namedNode('http://www.w3.org/ns/shacl#path'), null)[0]?.object.value;\r\n            prop.minCount = store.getQuads(namedNode(prop.propertyId), namedNode('http://www.w3.org/ns/shacl#minCount'), null)[0]?.object.value;\r\n            prop.nodeKind = store.getQuads(namedNode(prop.propertyId), namedNode('http://www.w3.org/ns/shacl#nodeKind'), null)[0]?.object.value;\r\n            prop.datatype = store.getQuads(namedNode(prop.propertyId), namedNode('http://www.w3.org/ns/shacl#datatype'), null)[0]?.object.value;\r\n            prop.class = store.getQuads(namedNode(prop.propertyId), namedNode('http://www.w3.org/ns/shacl#class'), null)[0]?.object.value;\r\n\r\n            // Обработка sh:or\r\n            const orQuads = store.getQuads(namedNode(prop.propertyId), namedNode('http://www.w3.org/ns/shacl#or'), null);\r\n            if (orQuads.length > 0) {\r\n                prop.or = [];\r\n                const orList = store.getQuads(orQuads[0].object, null, null);\r\n                orList.forEach(orItem => {\r\n                    const orNode = orItem.object;\r\n                    const orDetails = store.getQuads(orNode, null, null);\r\n                    const orProp = {};\r\n                    orDetails.forEach(detail => {\r\n                        if (detail.predicate.value === 'http://www.w3.org/ns/shacl#nodeKind') {\r\n                            orProp.nodeKind = detail.object.value;\r\n                        }\r\n                        if (detail.predicate.value === 'http://www.w3.org/ns/shacl#datatype') {\r\n                            orProp.datatype = detail.object.value;\r\n                        }\r\n                    });\r\n                    prop.or.push(orProp);\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    // Формируем итоговый JSON\r\n    const jsonOutput = { shapes: Object.values(shapes) };\r\n    await fs.writeFile(outputFile, JSON.stringify(jsonOutput, null, 2));\r\n    console.log('JSON saved to', outputFile);\r\n}\r\n\r\nconvertTtlToJson('/mnt/e/LU/Bachelor/qseoutput/dblp_books_QSE_FULL_SHACL_corrected.ttl', '/mnt/e/LU/Bachelor/dblp_books_schema.json')\r\n    .catch(err => console.error('Error:', err));","import Lexer from './N3Lexer';\nimport Parser from './N3Parser';\nimport Writer from './N3Writer';\nimport Store, { N3EntityIndex as EntityIndex } from './N3Store';\nimport StoreFactory from './N3StoreFactory';\nimport Reasoner, { getRulesFromDataset } from './N3Reasoner';\nimport StreamParser from './N3StreamParser';\nimport StreamWriter from './N3StreamWriter';\nimport * as Util from './N3Util';\nimport BaseIRI from './BaseIRI';\n\nimport {\n  default as DataFactory,\n\n  Term,\n  NamedNode,\n  Literal,\n  BlankNode,\n  Variable,\n  DefaultGraph,\n  Quad,\n  Triple,\n\n  termFromId,\n  termToId,\n} from './N3DataFactory';\n\n// Named exports\nexport {\n  Lexer,\n  Parser,\n  Writer,\n  Store,\n  StoreFactory,\n  EntityIndex,\n  StreamParser,\n  StreamWriter,\n  Util,\n  Reasoner,\n  BaseIRI,\n\n  DataFactory,\n\n  Term,\n  NamedNode,\n  Literal,\n  BlankNode,\n  Variable,\n  DefaultGraph,\n  Quad,\n  Triple,\n\n  termFromId,\n  termToId,\n  getRulesFromDataset,\n};\n\n// Export all named exports as a default object for backward compatibility\nexport default {\n  Lexer,\n  Parser,\n  Writer,\n  Store,\n  StoreFactory,\n  EntityIndex,\n  StreamParser,\n  StreamWriter,\n  Util,\n  Reasoner,\n  BaseIRI,\n\n  DataFactory,\n\n  Term,\n  NamedNode,\n  Literal,\n  BlankNode,\n  Variable,\n  DefaultGraph,\n  Quad,\n  Triple,\n\n  termFromId,\n  termToId,\n};\n","// **N3Lexer** tokenizes N3 documents.\nimport { Buffer } from 'buffer';\nimport namespaces from './IRIs';\n\nconst { xsd } = namespaces;\n\n// Regular expression and replacement string to escape N3 strings\nconst escapeSequence = /\\\\u([a-fA-F0-9]{4})|\\\\U([a-fA-F0-9]{8})|\\\\([^])/g;\nconst escapeReplacements = {\n  '\\\\': '\\\\', \"'\": \"'\", '\"': '\"',\n  'n': '\\n', 'r': '\\r', 't': '\\t', 'f': '\\f', 'b': '\\b',\n  '_': '_', '~': '~', '.': '.', '-': '-', '!': '!', '$': '$', '&': '&',\n  '(': '(', ')': ')', '*': '*', '+': '+', ',': ',', ';': ';', '=': '=',\n  '/': '/', '?': '?', '#': '#', '@': '@', '%': '%',\n};\nconst illegalIriChars = /[\\x00-\\x20<>\\\\\"\\{\\}\\|\\^\\`]/;\n\nconst lineModeRegExps = {\n  _iri: true,\n  _unescapedIri: true,\n  _simpleQuotedString: true,\n  _langcode: true,\n  _blank: true,\n  _newline: true,\n  _comment: true,\n  _whitespace: true,\n  _endOfFile: true,\n};\nconst invalidRegExp = /$0^/;\n\n// ## Constructor\nexport default class N3Lexer {\n  constructor(options) {\n    // ## Regular expressions\n    // It's slightly faster to have these as properties than as in-scope variables\n    this._iri = /^<((?:[^ <>{}\\\\]|\\\\[uU])+)>[ \\t]*/; // IRI with escape sequences; needs sanity check after unescaping\n    this._unescapedIri = /^<([^\\x00-\\x20<>\\\\\"\\{\\}\\|\\^\\`]*)>[ \\t]*/; // IRI without escape sequences; no unescaping\n    this._simpleQuotedString = /^\"([^\"\\\\\\r\\n]*)\"(?=[^\"])/; // string without escape sequences\n    this._simpleApostropheString = /^'([^'\\\\\\r\\n]*)'(?=[^'])/;\n    this._langcode = /^@([a-z]+(?:-[a-z0-9]+)*)(?=[^a-z0-9\\-])/i;\n    this._prefix = /^((?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)?:(?=[#\\s<])/;\n    this._prefixed = /^((?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)?:((?:(?:[0-:A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~])(?:(?:[\\.\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~])*(?:[\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~]))?)?)(?:[ \\t]+|(?=\\.?[,;!\\^\\s#()\\[\\]\\{\\}\"'<>]))/;\n    this._variable = /^\\?(?:(?:[A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:[\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)(?=[.,;!\\^\\s#()\\[\\]\\{\\}\"'<>])/;\n    this._blank = /^_:((?:[0-9A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)(?:[ \\t]+|(?=\\.?[,;:\\s#()\\[\\]\\{\\}\"'<>]))/;\n    this._number = /^[\\-+]?(?:(\\d+\\.\\d*|\\.?\\d+)[eE][\\-+]?|\\d*(\\.)?)\\d+(?=\\.?[,;:\\s#()\\[\\]\\{\\}\"'<>])/;\n    this._boolean = /^(?:true|false)(?=[.,;\\s#()\\[\\]\\{\\}\"'<>])/;\n    this._keyword = /^@[a-z]+(?=[\\s#<:])/i;\n    this._sparqlKeyword = /^(?:PREFIX|BASE|GRAPH)(?=[\\s#<])/i;\n    this._shortPredicates = /^a(?=[\\s#()\\[\\]\\{\\}\"'<>])/;\n    this._newline = /^[ \\t]*(?:#[^\\n\\r]*)?(?:\\r\\n|\\n|\\r)[ \\t]*/;\n    this._comment = /#([^\\n\\r]*)/;\n    this._whitespace = /^[ \\t]+/;\n    this._endOfFile = /^(?:#[^\\n\\r]*)?$/;\n    options = options || {};\n\n    // Whether the log:isImpliedBy predicate is supported\n    this._isImpliedBy = options.isImpliedBy;\n\n    // In line mode (N-Triples or N-Quads), only simple features may be parsed\n    if (this._lineMode = !!options.lineMode) {\n      this._n3Mode = false;\n      // Don't tokenize special literals\n      for (const key in this) {\n        if (!(key in lineModeRegExps) && this[key] instanceof RegExp)\n          this[key] = invalidRegExp;\n      }\n    }\n    // When not in line mode, enable N3 functionality by default\n    else {\n      this._n3Mode = options.n3 !== false;\n    }\n    // Don't output comment tokens by default\n    this.comments = !!options.comments;\n    // Cache the last tested closing position of long literals\n    this._literalClosingPos = 0;\n  }\n\n  // ## Private methods\n\n  // ### `_tokenizeToEnd` tokenizes as for as possible, emitting tokens through the callback\n  _tokenizeToEnd(callback, inputFinished) {\n    // Continue parsing as far as possible; the loop will return eventually\n    let input = this._input;\n    let currentLineLength = input.length;\n    while (true) {\n      // Count and skip whitespace lines\n      let whiteSpaceMatch, comment;\n      while (whiteSpaceMatch = this._newline.exec(input)) {\n        // Try to find a comment\n        if (this.comments && (comment = this._comment.exec(whiteSpaceMatch[0])))\n          emitToken('comment', comment[1], '', this._line, whiteSpaceMatch[0].length);\n        // Advance the input\n        input = input.substr(whiteSpaceMatch[0].length, input.length);\n        currentLineLength = input.length;\n        this._line++;\n      }\n      // Skip whitespace on current line\n      if (!whiteSpaceMatch && (whiteSpaceMatch = this._whitespace.exec(input)))\n        input = input.substr(whiteSpaceMatch[0].length, input.length);\n\n      // Stop for now if we're at the end\n      if (this._endOfFile.test(input)) {\n        // If the input is finished, emit EOF\n        if (inputFinished) {\n          // Try to find a final comment\n          if (this.comments && (comment = this._comment.exec(input)))\n            emitToken('comment', comment[1], '', this._line, input.length);\n          input = null;\n          emitToken('eof', '', '', this._line, 0);\n        }\n        return this._input = input;\n      }\n\n      // Look for specific token types based on the first character\n      const line = this._line, firstChar = input[0];\n      let type = '', value = '', prefix = '',\n          match = null, matchLength = 0, inconclusive = false;\n      switch (firstChar) {\n      case '^':\n        // We need at least 3 tokens lookahead to distinguish ^^<IRI> and ^^pre:fixed\n        if (input.length < 3)\n          break;\n        // Try to match a type\n        else if (input[1] === '^') {\n          this._previousMarker = '^^';\n          // Move to type IRI or prefixed name\n          input = input.substr(2);\n          if (input[0] !== '<') {\n            inconclusive = true;\n            break;\n          }\n        }\n        // If no type, it must be a path expression\n        else {\n          if (this._n3Mode) {\n            matchLength = 1;\n            type = '^';\n          }\n          break;\n        }\n        // Fall through in case the type is an IRI\n      case '<':\n        // Try to find a full IRI without escape sequences\n        if (match = this._unescapedIri.exec(input))\n          type = 'IRI', value = match[1];\n        // Try to find a full IRI with escape sequences\n        else if (match = this._iri.exec(input)) {\n          value = this._unescape(match[1]);\n          if (value === null || illegalIriChars.test(value))\n            return reportSyntaxError(this);\n          type = 'IRI';\n        }\n        // Try to find a nested triple\n        else if (input.length > 1 && input[1] === '<')\n          type = '<<', matchLength = 2;\n        // Try to find a backwards implication arrow\n        else if (this._n3Mode && input.length > 1 && input[1] === '=') {\n          matchLength = 2;\n          if (this._isImpliedBy) type = 'abbreviation', value = '<';\n          else type = 'inverse', value = '>';\n        }\n        break;\n\n      case '>':\n        if (input.length > 1 && input[1] === '>')\n          type = '>>', matchLength = 2;\n        break;\n\n      case '_':\n        // Try to find a blank node. Since it can contain (but not end with) a dot,\n        // we always need a non-dot character before deciding it is a blank node.\n        // Therefore, try inserting a space if we're at the end of the input.\n        if ((match = this._blank.exec(input)) ||\n            inputFinished && (match = this._blank.exec(`${input} `)))\n          type = 'blank', prefix = '_', value = match[1];\n        break;\n\n      case '\"':\n        // Try to find a literal without escape sequences\n        if (match = this._simpleQuotedString.exec(input))\n          value = match[1];\n        // Try to find a literal wrapped in three pairs of quotes\n        else {\n          ({ value, matchLength } = this._parseLiteral(input));\n          if (value === null)\n            return reportSyntaxError(this);\n        }\n        if (match !== null || matchLength !== 0) {\n          type = 'literal';\n          this._literalClosingPos = 0;\n        }\n        break;\n\n      case \"'\":\n        if (!this._lineMode) {\n          // Try to find a literal without escape sequences\n          if (match = this._simpleApostropheString.exec(input))\n            value = match[1];\n          // Try to find a literal wrapped in three pairs of quotes\n          else {\n            ({ value, matchLength } = this._parseLiteral(input));\n            if (value === null)\n              return reportSyntaxError(this);\n          }\n          if (match !== null || matchLength !== 0) {\n            type = 'literal';\n            this._literalClosingPos = 0;\n          }\n        }\n        break;\n\n      case '?':\n        // Try to find a variable\n        if (this._n3Mode && (match = this._variable.exec(input)))\n          type = 'var', value = match[0];\n        break;\n\n      case '@':\n        // Try to find a language code\n        if (this._previousMarker === 'literal' && (match = this._langcode.exec(input)))\n          type = 'langcode', value = match[1];\n        // Try to find a keyword\n        else if (match = this._keyword.exec(input))\n          type = match[0];\n        break;\n\n      case '.':\n        // Try to find a dot as punctuation\n        if (input.length === 1 ? inputFinished : (input[1] < '0' || input[1] > '9')) {\n          type = '.';\n          matchLength = 1;\n          break;\n        }\n        // Fall through to numerical case (could be a decimal dot)\n\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      case '+':\n      case '-':\n        // Try to find a number. Since it can contain (but not end with) a dot,\n        // we always need a non-dot character before deciding it is a number.\n        // Therefore, try inserting a space if we're at the end of the input.\n        if (match = this._number.exec(input) ||\n            inputFinished && (match = this._number.exec(`${input} `))) {\n          type = 'literal', value = match[0];\n          prefix = (typeof match[1] === 'string' ? xsd.double :\n                    (typeof match[2] === 'string' ? xsd.decimal : xsd.integer));\n        }\n        break;\n\n      case 'B':\n      case 'b':\n      case 'p':\n      case 'P':\n      case 'G':\n      case 'g':\n        // Try to find a SPARQL-style keyword\n        if (match = this._sparqlKeyword.exec(input))\n          type = match[0].toUpperCase();\n        else\n          inconclusive = true;\n        break;\n\n      case 'f':\n      case 't':\n        // Try to match a boolean\n        if (match = this._boolean.exec(input))\n          type = 'literal', value = match[0], prefix = xsd.boolean;\n        else\n          inconclusive = true;\n        break;\n\n      case 'a':\n        // Try to find an abbreviated predicate\n        if (match = this._shortPredicates.exec(input))\n          type = 'abbreviation', value = 'a';\n        else\n          inconclusive = true;\n        break;\n\n      case '=':\n        // Try to find an implication arrow or equals sign\n        if (this._n3Mode && input.length > 1) {\n          type = 'abbreviation';\n          if (input[1] !== '>')\n            matchLength = 1, value = '=';\n          else\n            matchLength = 2, value = '>';\n        }\n        break;\n\n      case '!':\n        if (!this._n3Mode)\n          break;\n      case ',':\n      case ';':\n      case '[':\n      case ']':\n      case '(':\n      case ')':\n      case '}':\n        if (!this._lineMode) {\n          matchLength = 1;\n          type = firstChar;\n        }\n        break;\n      case '{':\n        // We need at least 2 tokens lookahead to distinguish \"{|\" and \"{ \"\n        if (!this._lineMode && input.length >= 2) {\n          // Try to find a quoted triple annotation start\n          if (input[1] === '|')\n            type = '{|', matchLength = 2;\n          else\n            type = firstChar, matchLength = 1;\n        }\n        break;\n      case '|':\n        // We need 2 tokens lookahead to parse \"|}\"\n        // Try to find a quoted triple annotation end\n        if (input.length >= 2 && input[1] === '}')\n          type = '|}', matchLength = 2;\n        break;\n\n      default:\n        inconclusive = true;\n      }\n\n      // Some first characters do not allow an immediate decision, so inspect more\n      if (inconclusive) {\n        // Try to find a prefix\n        if ((this._previousMarker === '@prefix' || this._previousMarker === 'PREFIX') &&\n            (match = this._prefix.exec(input)))\n          type = 'prefix', value = match[1] || '';\n        // Try to find a prefixed name. Since it can contain (but not end with) a dot,\n        // we always need a non-dot character before deciding it is a prefixed name.\n        // Therefore, try inserting a space if we're at the end of the input.\n        else if ((match = this._prefixed.exec(input)) ||\n                 inputFinished && (match = this._prefixed.exec(`${input} `)))\n          type = 'prefixed', prefix = match[1] || '', value = this._unescape(match[2]);\n      }\n\n      // A type token is special: it can only be emitted after an IRI or prefixed name is read\n      if (this._previousMarker === '^^') {\n        switch (type) {\n        case 'prefixed': type = 'type';    break;\n        case 'IRI':      type = 'typeIRI'; break;\n        default:         type = '';\n        }\n      }\n\n      // What if nothing of the above was found?\n      if (!type) {\n        // We could be in streaming mode, and then we just wait for more input to arrive.\n        // Otherwise, a syntax error has occurred in the input.\n        // One exception: error on an unaccounted linebreak (= not inside a triple-quoted literal).\n        if (inputFinished || (!/^'''|^\"\"\"/.test(input) && /\\n|\\r/.test(input)))\n          return reportSyntaxError(this);\n        else\n          return this._input = input;\n      }\n\n      // Emit the parsed token\n      const length = matchLength || match[0].length;\n      const token = emitToken(type, value, prefix, line, length);\n      this.previousToken = token;\n      this._previousMarker = type;\n\n      // Advance to next part to tokenize\n      input = input.substr(length, input.length);\n    }\n\n    // Emits the token through the callback\n    function emitToken(type, value, prefix, line, length) {\n      const start = input ? currentLineLength - input.length : currentLineLength;\n      const end = start + length;\n      const token = { type, value, prefix, line, start, end };\n      callback(null, token);\n      return token;\n    }\n    // Signals the syntax error through the callback\n    function reportSyntaxError(self) { callback(self._syntaxError(/^\\S*/.exec(input)[0])); }\n  }\n\n  // ### `_unescape` replaces N3 escape codes by their corresponding characters\n  _unescape(item) {\n    let invalid = false;\n    const replaced = item.replace(escapeSequence, (sequence, unicode4, unicode8, escapedChar) => {\n      // 4-digit unicode character\n      if (typeof unicode4 === 'string')\n        return String.fromCharCode(Number.parseInt(unicode4, 16));\n      // 8-digit unicode character\n      if (typeof unicode8 === 'string') {\n        let charCode = Number.parseInt(unicode8, 16);\n        return charCode <= 0xFFFF ? String.fromCharCode(Number.parseInt(unicode8, 16)) :\n          String.fromCharCode(0xD800 + ((charCode -= 0x10000) >> 10), 0xDC00 + (charCode & 0x3FF));\n      }\n      // fixed escape sequence\n      if (escapedChar in escapeReplacements)\n        return escapeReplacements[escapedChar];\n      // invalid escape sequence\n      invalid = true;\n      return '';\n    });\n    return invalid ? null : replaced;\n  }\n\n  // ### `_parseLiteral` parses a literal into an unescaped value\n  _parseLiteral(input) {\n    // Ensure we have enough lookahead to identify triple-quoted strings\n    if (input.length >= 3) {\n      // Identify the opening quote(s)\n      const opening = input.match(/^(?:\"\"\"|\"|'''|'|)/)[0];\n      const openingLength = opening.length;\n\n      // Find the next candidate closing quotes\n      let closingPos = Math.max(this._literalClosingPos, openingLength);\n      while ((closingPos = input.indexOf(opening, closingPos)) > 0) {\n        // Count backslashes right before the closing quotes\n        let backslashCount = 0;\n        while (input[closingPos - backslashCount - 1] === '\\\\')\n          backslashCount++;\n\n        // An even number of backslashes (in particular 0)\n        // means these are actual, non-escaped closing quotes\n        if (backslashCount % 2 === 0) {\n          // Extract and unescape the value\n          const raw = input.substring(openingLength, closingPos);\n          const lines = raw.split(/\\r\\n|\\r|\\n/).length - 1;\n          const matchLength = closingPos + openingLength;\n          // Only triple-quoted strings can be multi-line\n          if (openingLength === 1 && lines !== 0 ||\n              openingLength === 3 && this._lineMode)\n            break;\n          this._line += lines;\n          return { value: this._unescape(raw), matchLength };\n        }\n        closingPos++;\n      }\n      this._literalClosingPos = input.length - openingLength + 1;\n    }\n    return { value: '', matchLength: 0 };\n  }\n\n  // ### `_syntaxError` creates a syntax error for the given issue\n  _syntaxError(issue) {\n    this._input = null;\n    const err = new Error(`Unexpected \"${issue}\" on line ${this._line}.`);\n    err.context = {\n      token: undefined,\n      line: this._line,\n      previousToken: this.previousToken,\n    };\n    return err;\n  }\n\n  // ### Strips off any starting UTF BOM mark.\n  _readStartingBom(input) {\n    return input.startsWith('\\ufeff') ? input.substr(1) : input;\n  }\n\n  // ## Public methods\n\n  // ### `tokenize` starts the transformation of an N3 document into an array of tokens.\n  // The input can be a string or a stream.\n  tokenize(input, callback) {\n    this._line = 1;\n\n    // If the input is a string, continuously emit tokens through the callback until the end\n    if (typeof input === 'string') {\n      this._input = this._readStartingBom(input);\n      // If a callback was passed, asynchronously call it\n      if (typeof callback === 'function')\n        queueMicrotask(() => this._tokenizeToEnd(callback, true));\n      // If no callback was passed, tokenize synchronously and return\n      else {\n        const tokens = [];\n        let error;\n        this._tokenizeToEnd((e, t) => e ? (error = e) : tokens.push(t), true);\n        if (error) throw error;\n        return tokens;\n      }\n    }\n    // Otherwise, the input must be a stream\n    else {\n      this._pendingBuffer = null;\n      if (typeof input.setEncoding === 'function')\n        input.setEncoding('utf8');\n      // Adds the data chunk to the buffer and parses as far as possible\n      input.on('data', data => {\n        if (this._input !== null && data.length !== 0) {\n          // Prepend any previous pending writes\n          if (this._pendingBuffer) {\n            data = Buffer.concat([this._pendingBuffer, data]);\n            this._pendingBuffer = null;\n          }\n          // Hold if the buffer ends in an incomplete unicode sequence\n          if (data[data.length - 1] & 0x80) {\n            this._pendingBuffer = data;\n          }\n          // Otherwise, tokenize as far as possible\n          else {\n            // Only read a BOM at the start\n            if (typeof this._input === 'undefined')\n              this._input = this._readStartingBom(typeof data === 'string' ? data : data.toString());\n            else\n              this._input += data;\n            this._tokenizeToEnd(callback, false);\n          }\n        }\n      });\n      // Parses until the end\n      input.on('end', () => {\n        if (typeof this._input === 'string')\n          this._tokenizeToEnd(callback, true);\n      });\n      input.on('error', callback);\n    }\n  }\n}\n","const RDF  = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',\n    XSD  = 'http://www.w3.org/2001/XMLSchema#',\n    SWAP = 'http://www.w3.org/2000/10/swap/';\n\nexport default {\n  xsd: {\n    decimal: `${XSD}decimal`,\n    boolean: `${XSD}boolean`,\n    double:  `${XSD}double`,\n    integer: `${XSD}integer`,\n    string:  `${XSD}string`,\n  },\n  rdf: {\n    type:       `${RDF}type`,\n    nil:        `${RDF}nil`,\n    first:      `${RDF}first`,\n    rest:       `${RDF}rest`,\n    langString: `${RDF}langString`,\n  },\n  owl: {\n    sameAs: 'http://www.w3.org/2002/07/owl#sameAs',\n  },\n  r: {\n    forSome: `${SWAP}reify#forSome`,\n    forAll:  `${SWAP}reify#forAll`,\n  },\n  log: {\n    implies: `${SWAP}log#implies`,\n    isImpliedBy: `${SWAP}log#isImpliedBy`,\n  },\n};\n","// **N3Parser** parses N3 documents.\nimport N3Lexer from './N3Lexer';\nimport N3DataFactory from './N3DataFactory';\nimport namespaces from './IRIs';\n\nlet blankNodePrefix = 0;\n\n// ## Constructor\nexport default class N3Parser {\n  constructor(options) {\n    this._contextStack = [];\n    this._graph = null;\n\n    // Set the document IRI\n    options = options || {};\n    this._setBase(options.baseIRI);\n    options.factory && initDataFactory(this, options.factory);\n\n    // Set supported features depending on the format\n    const format = (typeof options.format === 'string') ?\n                 options.format.match(/\\w*$/)[0].toLowerCase() : '',\n        isTurtle = /turtle/.test(format), isTriG = /trig/.test(format),\n        isNTriples = /triple/.test(format), isNQuads = /quad/.test(format),\n        isN3 = this._n3Mode = /n3/.test(format),\n        isLineMode = isNTriples || isNQuads;\n    if (!(this._supportsNamedGraphs = !(isTurtle || isN3)))\n      this._readPredicateOrNamedGraph = this._readPredicate;\n    // Support triples in other graphs\n    this._supportsQuads = !(isTurtle || isTriG || isNTriples || isN3);\n    // Whether the log:isImpliedBy predicate is supported\n    this._isImpliedBy = options.isImpliedBy;\n    // Support nesting of triples\n    this._supportsRDFStar = format === '' || /star|\\*$/.test(format);\n    // Disable relative IRIs in N-Triples or N-Quads mode\n    if (isLineMode)\n      this._resolveRelativeIRI = iri => { return null; };\n    this._blankNodePrefix = typeof options.blankNodePrefix !== 'string' ? '' :\n                              options.blankNodePrefix.replace(/^(?!_:)/, '_:');\n    this._lexer = options.lexer || new N3Lexer({ lineMode: isLineMode, n3: isN3, isImpliedBy: this._isImpliedBy });\n    // Disable explicit quantifiers by default\n    this._explicitQuantifiers = !!options.explicitQuantifiers;\n  }\n\n  // ## Static class methods\n\n  // ### `_resetBlankNodePrefix` restarts blank node prefix identification\n  static _resetBlankNodePrefix() {\n    blankNodePrefix = 0;\n  }\n\n  // ## Private methods\n\n  // ### `_setBase` sets the base IRI to resolve relative IRIs\n  _setBase(baseIRI) {\n    if (!baseIRI) {\n      this._base = '';\n      this._basePath = '';\n    }\n    else {\n      // Remove fragment if present\n      const fragmentPos = baseIRI.indexOf('#');\n      if (fragmentPos >= 0)\n        baseIRI = baseIRI.substr(0, fragmentPos);\n      // Set base IRI and its components\n      this._base = baseIRI;\n      this._basePath   = baseIRI.indexOf('/') < 0 ? baseIRI :\n                         baseIRI.replace(/[^\\/?]*(?:\\?.*)?$/, '');\n      baseIRI = baseIRI.match(/^(?:([a-z][a-z0-9+.-]*:))?(?:\\/\\/[^\\/]*)?/i);\n      this._baseRoot   = baseIRI[0];\n      this._baseScheme = baseIRI[1];\n    }\n  }\n\n  // ### `_saveContext` stores the current parsing context\n  // when entering a new scope (list, blank node, formula)\n  _saveContext(type, graph, subject, predicate, object) {\n    const n3Mode = this._n3Mode;\n    this._contextStack.push({\n      type,\n      subject, predicate, object, graph,\n      inverse: n3Mode ? this._inversePredicate : false,\n      blankPrefix: n3Mode ? this._prefixes._ : '',\n      quantified: n3Mode ? this._quantified : null,\n    });\n    // The settings below only apply to N3 streams\n    if (n3Mode) {\n      // Every new scope resets the predicate direction\n      this._inversePredicate = false;\n      // In N3, blank nodes are scoped to a formula\n      // (using a dot as separator, as a blank node label cannot start with it)\n      this._prefixes._ = (this._graph ? `${this._graph.value}.` : '.');\n      // Quantifiers are scoped to a formula\n      this._quantified = Object.create(this._quantified);\n    }\n  }\n\n  // ### `_restoreContext` restores the parent context\n  // when leaving a scope (list, blank node, formula)\n  _restoreContext(type, token) {\n    // Obtain the previous context\n    const context = this._contextStack.pop();\n    if (!context || context.type !== type)\n      return this._error(`Unexpected ${token.type}`, token);\n\n    // Restore the quad of the previous context\n    this._subject   = context.subject;\n    this._predicate = context.predicate;\n    this._object    = context.object;\n    this._graph     = context.graph;\n\n    // Restore N3 context settings\n    if (this._n3Mode) {\n      this._inversePredicate = context.inverse;\n      this._prefixes._ = context.blankPrefix;\n      this._quantified = context.quantified;\n    }\n  }\n\n  // ### `_readInTopContext` reads a token when in the top context\n  _readInTopContext(token) {\n    switch (token.type) {\n    // If an EOF token arrives in the top context, signal that we're done\n    case 'eof':\n      if (this._graph !== null)\n        return this._error('Unclosed graph', token);\n      delete this._prefixes._;\n      return this._callback(null, null, this._prefixes);\n    // It could be a prefix declaration\n    case 'PREFIX':\n      this._sparqlStyle = true;\n    case '@prefix':\n      return this._readPrefix;\n    // It could be a base declaration\n    case 'BASE':\n      this._sparqlStyle = true;\n    case '@base':\n      return this._readBaseIRI;\n    // It could be a graph\n    case '{':\n      if (this._supportsNamedGraphs) {\n        this._graph = '';\n        this._subject = null;\n        return this._readSubject;\n      }\n    case 'GRAPH':\n      if (this._supportsNamedGraphs)\n        return this._readNamedGraphLabel;\n    // Otherwise, the next token must be a subject\n    default:\n      return this._readSubject(token);\n    }\n  }\n\n  // ### `_readEntity` reads an IRI, prefixed name, blank node, or variable\n  _readEntity(token, quantifier) {\n    let value;\n    switch (token.type) {\n    // Read a relative or absolute IRI\n    case 'IRI':\n    case 'typeIRI':\n      const iri = this._resolveIRI(token.value);\n      if (iri === null)\n        return this._error('Invalid IRI', token);\n      value = this._factory.namedNode(iri);\n      break;\n    // Read a prefixed name\n    case 'type':\n    case 'prefixed':\n      const prefix = this._prefixes[token.prefix];\n      if (prefix === undefined)\n        return this._error(`Undefined prefix \"${token.prefix}:\"`, token);\n      value = this._factory.namedNode(prefix + token.value);\n      break;\n    // Read a blank node\n    case 'blank':\n      value = this._factory.blankNode(this._prefixes[token.prefix] + token.value);\n      break;\n    // Read a variable\n    case 'var':\n      value = this._factory.variable(token.value.substr(1));\n      break;\n    // Everything else is not an entity\n    default:\n      return this._error(`Expected entity but got ${token.type}`, token);\n    }\n    // In N3 mode, replace the entity if it is quantified\n    if (!quantifier && this._n3Mode && (value.id in this._quantified))\n      value = this._quantified[value.id];\n    return value;\n  }\n\n  // ### `_readSubject` reads a quad's subject\n  _readSubject(token) {\n    this._predicate = null;\n    switch (token.type) {\n    case '[':\n      // Start a new quad with a new blank node as subject\n      this._saveContext('blank', this._graph,\n                        this._subject = this._factory.blankNode(), null, null);\n      return this._readBlankNodeHead;\n    case '(':\n      // Start a new list\n      this._saveContext('list', this._graph, this.RDF_NIL, null, null);\n      this._subject = null;\n      return this._readListItem;\n    case '{':\n      // Start a new formula\n      if (!this._n3Mode)\n        return this._error('Unexpected graph', token);\n      this._saveContext('formula', this._graph,\n                        this._graph = this._factory.blankNode(), null, null);\n      return this._readSubject;\n    case '}':\n       // No subject; the graph in which we are reading is closed instead\n      return this._readPunctuation(token);\n    case '@forSome':\n      if (!this._n3Mode)\n        return this._error('Unexpected \"@forSome\"', token);\n      this._subject = null;\n      this._predicate = this.N3_FORSOME;\n      this._quantifier = 'blankNode';\n      return this._readQuantifierList;\n    case '@forAll':\n      if (!this._n3Mode)\n        return this._error('Unexpected \"@forAll\"', token);\n      this._subject = null;\n      this._predicate = this.N3_FORALL;\n      this._quantifier = 'variable';\n      return this._readQuantifierList;\n    case 'literal':\n      if (!this._n3Mode)\n        return this._error('Unexpected literal', token);\n\n      if (token.prefix.length === 0) {\n        this._literalValue = token.value;\n        return this._completeSubjectLiteral;\n      }\n      else\n        this._subject = this._factory.literal(token.value, this._factory.namedNode(token.prefix));\n\n      break;\n    case '<<':\n      if (!this._supportsRDFStar)\n        return this._error('Unexpected RDF-star syntax', token);\n      this._saveContext('<<', this._graph, null, null, null);\n      this._graph = null;\n      return this._readSubject;\n    default:\n      // Read the subject entity\n      if ((this._subject = this._readEntity(token)) === undefined)\n        return;\n      // In N3 mode, the subject might be a path\n      if (this._n3Mode)\n        return this._getPathReader(this._readPredicateOrNamedGraph);\n    }\n\n    // The next token must be a predicate,\n    // or, if the subject was actually a graph IRI, a named graph\n    return this._readPredicateOrNamedGraph;\n  }\n\n  // ### `_readPredicate` reads a quad's predicate\n  _readPredicate(token) {\n    const type = token.type;\n    switch (type) {\n    case 'inverse':\n      this._inversePredicate = true;\n    case 'abbreviation':\n      this._predicate = this.ABBREVIATIONS[token.value];\n      break;\n    case '.':\n    case ']':\n    case '}':\n      // Expected predicate didn't come, must have been trailing semicolon\n      if (this._predicate === null)\n        return this._error(`Unexpected ${type}`, token);\n      this._subject = null;\n      return type === ']' ? this._readBlankNodeTail(token) : this._readPunctuation(token);\n    case ';':\n      // Additional semicolons can be safely ignored\n      return this._predicate !== null ? this._readPredicate :\n             this._error('Expected predicate but got ;', token);\n    case '[':\n      if (this._n3Mode) {\n        // Start a new quad with a new blank node as subject\n        this._saveContext('blank', this._graph, this._subject,\n                          this._subject = this._factory.blankNode(), null);\n        return this._readBlankNodeHead;\n      }\n    case 'blank':\n      if (!this._n3Mode)\n        return this._error('Disallowed blank node as predicate', token);\n    default:\n      if ((this._predicate = this._readEntity(token)) === undefined)\n        return;\n    }\n    // The next token must be an object\n    return this._readObject;\n  }\n\n  // ### `_readObject` reads a quad's object\n  _readObject(token) {\n    switch (token.type) {\n    case 'literal':\n      // Regular literal, can still get a datatype or language\n      if (token.prefix.length === 0) {\n        this._literalValue = token.value;\n        return this._readDataTypeOrLang;\n      }\n      // Pre-datatyped string literal (prefix stores the datatype)\n      else\n        this._object = this._factory.literal(token.value, this._factory.namedNode(token.prefix));\n      break;\n    case '[':\n      // Start a new quad with a new blank node as subject\n      this._saveContext('blank', this._graph, this._subject, this._predicate,\n                        this._subject = this._factory.blankNode());\n      return this._readBlankNodeHead;\n    case '(':\n      // Start a new list\n      this._saveContext('list', this._graph, this._subject, this._predicate, this.RDF_NIL);\n      this._subject = null;\n      return this._readListItem;\n    case '{':\n      // Start a new formula\n      if (!this._n3Mode)\n        return this._error('Unexpected graph', token);\n      this._saveContext('formula', this._graph, this._subject, this._predicate,\n                        this._graph = this._factory.blankNode());\n      return this._readSubject;\n    case '<<':\n      if (!this._supportsRDFStar)\n        return this._error('Unexpected RDF-star syntax', token);\n      this._saveContext('<<', this._graph, this._subject, this._predicate, null);\n      this._graph = null;\n      return this._readSubject;\n    default:\n      // Read the object entity\n      if ((this._object = this._readEntity(token)) === undefined)\n        return;\n      // In N3 mode, the object might be a path\n      if (this._n3Mode)\n        return this._getPathReader(this._getContextEndReader());\n    }\n    return this._getContextEndReader();\n  }\n\n  // ### `_readPredicateOrNamedGraph` reads a quad's predicate, or a named graph\n  _readPredicateOrNamedGraph(token) {\n    return token.type === '{' ? this._readGraph(token) : this._readPredicate(token);\n  }\n\n  // ### `_readGraph` reads a graph\n  _readGraph(token) {\n    if (token.type !== '{')\n      return this._error(`Expected graph but got ${token.type}`, token);\n    // The \"subject\" we read is actually the GRAPH's label\n    this._graph = this._subject, this._subject = null;\n    return this._readSubject;\n  }\n\n  // ### `_readBlankNodeHead` reads the head of a blank node\n  _readBlankNodeHead(token) {\n    if (token.type === ']') {\n      this._subject = null;\n      return this._readBlankNodeTail(token);\n    }\n    else {\n      this._predicate = null;\n      return this._readPredicate(token);\n    }\n  }\n\n  // ### `_readBlankNodeTail` reads the end of a blank node\n  _readBlankNodeTail(token) {\n    if (token.type !== ']')\n      return this._readBlankNodePunctuation(token);\n\n    // Store blank node quad\n    if (this._subject !== null)\n      this._emit(this._subject, this._predicate, this._object, this._graph);\n\n    // Restore the parent context containing this blank node\n    const empty = this._predicate === null;\n    this._restoreContext('blank', token);\n    // If the blank node was the object, restore previous context and read punctuation\n    if (this._object !== null)\n      return this._getContextEndReader();\n    // If the blank node was the predicate, continue reading the object\n    else if (this._predicate !== null)\n      return this._readObject;\n    // If the blank node was the subject, continue reading the predicate\n    else\n      // If the blank node was empty, it could be a named graph label\n      return empty ? this._readPredicateOrNamedGraph : this._readPredicateAfterBlank;\n  }\n\n  // ### `_readPredicateAfterBlank` reads a predicate after an anonymous blank node\n  _readPredicateAfterBlank(token) {\n    switch (token.type) {\n    case '.':\n    case '}':\n      // No predicate is coming if the triple is terminated here\n      this._subject = null;\n      return this._readPunctuation(token);\n    default:\n      return this._readPredicate(token);\n    }\n  }\n\n  // ### `_readListItem` reads items from a list\n  _readListItem(token) {\n    let item = null,                      // The item of the list\n        list = null,                      // The list itself\n        next = this._readListItem;        // The next function to execute\n    const previousList = this._subject,   // The previous list that contains this list\n        stack = this._contextStack,       // The stack of parent contexts\n        parent = stack[stack.length - 1]; // The parent containing the current list\n\n    switch (token.type) {\n    case '[':\n      // Stack the current list quad and start a new quad with a blank node as subject\n      this._saveContext('blank', this._graph,\n                        list = this._factory.blankNode(), this.RDF_FIRST,\n                        this._subject = item = this._factory.blankNode());\n      next = this._readBlankNodeHead;\n      break;\n    case '(':\n      // Stack the current list quad and start a new list\n      this._saveContext('list', this._graph,\n                        list = this._factory.blankNode(), this.RDF_FIRST, this.RDF_NIL);\n      this._subject = null;\n      break;\n    case ')':\n      // Closing the list; restore the parent context\n      this._restoreContext('list', token);\n      // If this list is contained within a parent list, return the membership quad here.\n      // This will be `<parent list element> rdf:first <this list>.`.\n      if (stack.length !== 0 && stack[stack.length - 1].type === 'list')\n        this._emit(this._subject, this._predicate, this._object, this._graph);\n      // Was this list the parent's subject?\n      if (this._predicate === null) {\n        // The next token is the predicate\n        next = this._readPredicate;\n        // No list tail if this was an empty list\n        if (this._subject === this.RDF_NIL)\n          return next;\n      }\n      // The list was in the parent context's object\n      else {\n        next = this._getContextEndReader();\n        // No list tail if this was an empty list\n        if (this._object === this.RDF_NIL)\n          return next;\n      }\n      // Close the list by making the head nil\n      list = this.RDF_NIL;\n      break;\n    case 'literal':\n      // Regular literal, can still get a datatype or language\n      if (token.prefix.length === 0) {\n        this._literalValue = token.value;\n        next = this._readListItemDataTypeOrLang;\n      }\n      // Pre-datatyped string literal (prefix stores the datatype)\n      else {\n        item = this._factory.literal(token.value, this._factory.namedNode(token.prefix));\n        next = this._getContextEndReader();\n      }\n      break;\n    case '{':\n      // Start a new formula\n      if (!this._n3Mode)\n        return this._error('Unexpected graph', token);\n      this._saveContext('formula', this._graph, this._subject, this._predicate,\n                        this._graph = this._factory.blankNode());\n      return this._readSubject;\n    default:\n      if ((item = this._readEntity(token)) === undefined)\n        return;\n    }\n\n     // Create a new blank node if no item head was assigned yet\n    if (list === null)\n      this._subject = list = this._factory.blankNode();\n\n    // Is this the first element of the list?\n    if (previousList === null) {\n      // This list is either the subject or the object of its parent\n      if (parent.predicate === null)\n        parent.subject = list;\n      else\n        parent.object = list;\n    }\n    else {\n      // Continue the previous list with the current list\n      this._emit(previousList, this.RDF_REST, list, this._graph);\n    }\n    // If an item was read, add it to the list\n    if (item !== null) {\n      // In N3 mode, the item might be a path\n      if (this._n3Mode && (token.type === 'IRI' || token.type === 'prefixed')) {\n        // Create a new context to add the item's path\n        this._saveContext('item', this._graph, list, this.RDF_FIRST, item);\n        this._subject = item, this._predicate = null;\n        // _readPath will restore the context and output the item\n        return this._getPathReader(this._readListItem);\n      }\n      // Output the item\n      this._emit(list, this.RDF_FIRST, item, this._graph);\n    }\n    return next;\n  }\n\n  // ### `_readDataTypeOrLang` reads an _optional_ datatype or language\n  _readDataTypeOrLang(token) {\n    return this._completeObjectLiteral(token, false);\n  }\n\n\n  // ### `_readListItemDataTypeOrLang` reads an _optional_ datatype or language in a list\n  _readListItemDataTypeOrLang(token) {\n    return this._completeObjectLiteral(token, true);\n  }\n\n  // ### `_completeLiteral` completes a literal with an optional datatype or language\n  _completeLiteral(token) {\n    // Create a simple string literal by default\n    let literal = this._factory.literal(this._literalValue);\n\n    switch (token.type) {\n    // Create a datatyped literal\n    case 'type':\n    case 'typeIRI':\n      const datatype = this._readEntity(token);\n      if (datatype === undefined) return; // No datatype means an error occurred\n      literal = this._factory.literal(this._literalValue, datatype);\n      token = null;\n      break;\n    // Create a language-tagged string\n    case 'langcode':\n      literal = this._factory.literal(this._literalValue, token.value);\n      token = null;\n      break;\n    }\n\n    return { token, literal };\n  }\n\n  // Completes a literal in subject position\n  _completeSubjectLiteral(token) {\n    this._subject = this._completeLiteral(token).literal;\n    return this._readPredicateOrNamedGraph;\n  }\n\n  // Completes a literal in object position\n  _completeObjectLiteral(token, listItem) {\n    const completed = this._completeLiteral(token);\n    if (!completed)\n      return;\n    this._object = completed.literal;\n\n    // If this literal was part of a list, write the item\n    // (we could also check the context stack, but passing in a flag is faster)\n    if (listItem)\n      this._emit(this._subject, this.RDF_FIRST, this._object, this._graph);\n    // If the token was consumed, continue with the rest of the input\n    if (completed.token === null)\n      return this._getContextEndReader();\n    // Otherwise, consume the token now\n    else {\n      this._readCallback = this._getContextEndReader();\n      return this._readCallback(completed.token);\n    }\n  }\n\n  // ### `_readFormulaTail` reads the end of a formula\n  _readFormulaTail(token) {\n    if (token.type !== '}')\n      return this._readPunctuation(token);\n\n    // Store the last quad of the formula\n    if (this._subject !== null)\n      this._emit(this._subject, this._predicate, this._object, this._graph);\n\n    // Restore the parent context containing this formula\n    this._restoreContext('formula', token);\n    // If the formula was the subject, continue reading the predicate.\n    // If the formula was the object, read punctuation.\n    return this._object === null ? this._readPredicate : this._getContextEndReader();\n  }\n\n  // ### `_readPunctuation` reads punctuation between quads or quad parts\n  _readPunctuation(token) {\n    let next, graph = this._graph;\n    const subject = this._subject, inversePredicate = this._inversePredicate;\n    switch (token.type) {\n    // A closing brace ends a graph\n    case '}':\n      if (this._graph === null)\n        return this._error('Unexpected graph closing', token);\n      if (this._n3Mode)\n        return this._readFormulaTail(token);\n      this._graph = null;\n    // A dot just ends the statement, without sharing anything with the next\n    case '.':\n      this._subject = null;\n      next = this._contextStack.length ? this._readSubject : this._readInTopContext;\n      if (inversePredicate) this._inversePredicate = false;\n      break;\n    // Semicolon means the subject is shared; predicate and object are different\n    case ';':\n      next = this._readPredicate;\n      break;\n    // Comma means both the subject and predicate are shared; the object is different\n    case ',':\n      next = this._readObject;\n      break;\n    // {| means that the current triple is annotated with predicate-object pairs.\n    case '{|':\n      if (!this._supportsRDFStar)\n        return this._error('Unexpected RDF-star syntax', token);\n      // Continue using the last triple as quoted triple subject for the predicate-object pairs.\n      const predicate = this._predicate, object = this._object;\n      this._subject = this._factory.quad(subject, predicate, object, this.DEFAULTGRAPH);\n      next = this._readPredicate;\n      break;\n    // |} means that the current quoted triple in annotation syntax is finalized.\n    case '|}':\n      if (this._subject.termType !== 'Quad')\n        return this._error('Unexpected asserted triple closing', token);\n      this._subject = null;\n      next = this._readPunctuation;\n      break;\n    default:\n      // An entity means this is a quad (only allowed if not already inside a graph)\n      if (this._supportsQuads && this._graph === null && (graph = this._readEntity(token)) !== undefined) {\n        next = this._readQuadPunctuation;\n        break;\n      }\n      return this._error(`Expected punctuation to follow \"${this._object.id}\"`, token);\n    }\n    // A quad has been completed now, so return it\n    if (subject !== null) {\n      const predicate = this._predicate, object = this._object;\n      if (!inversePredicate)\n        this._emit(subject, predicate, object,  graph);\n      else\n        this._emit(object,  predicate, subject, graph);\n    }\n    return next;\n  }\n\n    // ### `_readBlankNodePunctuation` reads punctuation in a blank node\n  _readBlankNodePunctuation(token) {\n    let next;\n    switch (token.type) {\n    // Semicolon means the subject is shared; predicate and object are different\n    case ';':\n      next = this._readPredicate;\n      break;\n    // Comma means both the subject and predicate are shared; the object is different\n    case ',':\n      next = this._readObject;\n      break;\n    default:\n      return this._error(`Expected punctuation to follow \"${this._object.id}\"`, token);\n    }\n    // A quad has been completed now, so return it\n    this._emit(this._subject, this._predicate, this._object, this._graph);\n    return next;\n  }\n\n  // ### `_readQuadPunctuation` reads punctuation after a quad\n  _readQuadPunctuation(token) {\n    if (token.type !== '.')\n      return this._error('Expected dot to follow quad', token);\n    return this._readInTopContext;\n  }\n\n  // ### `_readPrefix` reads the prefix of a prefix declaration\n  _readPrefix(token) {\n    if (token.type !== 'prefix')\n      return this._error('Expected prefix to follow @prefix', token);\n    this._prefix = token.value;\n    return this._readPrefixIRI;\n  }\n\n  // ### `_readPrefixIRI` reads the IRI of a prefix declaration\n  _readPrefixIRI(token) {\n    if (token.type !== 'IRI')\n      return this._error(`Expected IRI to follow prefix \"${this._prefix}:\"`, token);\n    const prefixNode = this._readEntity(token);\n    this._prefixes[this._prefix] = prefixNode.value;\n    this._prefixCallback(this._prefix, prefixNode);\n    return this._readDeclarationPunctuation;\n  }\n\n  // ### `_readBaseIRI` reads the IRI of a base declaration\n  _readBaseIRI(token) {\n    const iri = token.type === 'IRI' && this._resolveIRI(token.value);\n    if (!iri)\n      return this._error('Expected valid IRI to follow base declaration', token);\n    this._setBase(iri);\n    return this._readDeclarationPunctuation;\n  }\n\n  // ### `_readNamedGraphLabel` reads the label of a named graph\n  _readNamedGraphLabel(token) {\n    switch (token.type) {\n    case 'IRI':\n    case 'blank':\n    case 'prefixed':\n      return this._readSubject(token), this._readGraph;\n    case '[':\n      return this._readNamedGraphBlankLabel;\n    default:\n      return this._error('Invalid graph label', token);\n    }\n  }\n\n  // ### `_readNamedGraphLabel` reads a blank node label of a named graph\n  _readNamedGraphBlankLabel(token) {\n    if (token.type !== ']')\n      return this._error('Invalid graph label', token);\n    this._subject = this._factory.blankNode();\n    return this._readGraph;\n  }\n\n  // ### `_readDeclarationPunctuation` reads the punctuation of a declaration\n  _readDeclarationPunctuation(token) {\n    // SPARQL-style declarations don't have punctuation\n    if (this._sparqlStyle) {\n      this._sparqlStyle = false;\n      return this._readInTopContext(token);\n    }\n\n    if (token.type !== '.')\n      return this._error('Expected declaration to end with a dot', token);\n    return this._readInTopContext;\n  }\n\n  // Reads a list of quantified symbols from a @forSome or @forAll statement\n  _readQuantifierList(token) {\n    let entity;\n    switch (token.type) {\n    case 'IRI':\n    case 'prefixed':\n      if ((entity = this._readEntity(token, true)) !== undefined)\n        break;\n    default:\n      return this._error(`Unexpected ${token.type}`, token);\n    }\n    // Without explicit quantifiers, map entities to a quantified entity\n    if (!this._explicitQuantifiers)\n      this._quantified[entity.id] = this._factory[this._quantifier](this._factory.blankNode().value);\n    // With explicit quantifiers, output the reified quantifier\n    else {\n      // If this is the first item, start a new quantifier list\n      if (this._subject === null)\n        this._emit(this._graph || this.DEFAULTGRAPH, this._predicate,\n                   this._subject = this._factory.blankNode(), this.QUANTIFIERS_GRAPH);\n      // Otherwise, continue the previous list\n      else\n        this._emit(this._subject, this.RDF_REST,\n                   this._subject = this._factory.blankNode(), this.QUANTIFIERS_GRAPH);\n      // Output the list item\n      this._emit(this._subject, this.RDF_FIRST, entity, this.QUANTIFIERS_GRAPH);\n    }\n    return this._readQuantifierPunctuation;\n  }\n\n  // Reads punctuation from a @forSome or @forAll statement\n  _readQuantifierPunctuation(token) {\n    // Read more quantifiers\n    if (token.type === ',')\n      return this._readQuantifierList;\n    // End of the quantifier list\n    else {\n      // With explicit quantifiers, close the quantifier list\n      if (this._explicitQuantifiers) {\n        this._emit(this._subject, this.RDF_REST, this.RDF_NIL, this.QUANTIFIERS_GRAPH);\n        this._subject = null;\n      }\n      // Read a dot\n      this._readCallback = this._getContextEndReader();\n      return this._readCallback(token);\n    }\n  }\n\n  // ### `_getPathReader` reads a potential path and then resumes with the given function\n  _getPathReader(afterPath) {\n    this._afterPath = afterPath;\n    return this._readPath;\n  }\n\n  // ### `_readPath` reads a potential path\n  _readPath(token) {\n    switch (token.type) {\n    // Forward path\n    case '!': return this._readForwardPath;\n    // Backward path\n    case '^': return this._readBackwardPath;\n    // Not a path; resume reading where we left off\n    default:\n      const stack = this._contextStack, parent = stack.length && stack[stack.length - 1];\n      // If we were reading a list item, we still need to output it\n      if (parent && parent.type === 'item') {\n        // The list item is the remaining subejct after reading the path\n        const item = this._subject;\n        // Switch back to the context of the list\n        this._restoreContext('item', token);\n        // Output the list item\n        this._emit(this._subject, this.RDF_FIRST, item, this._graph);\n      }\n      return this._afterPath(token);\n    }\n  }\n\n  // ### `_readForwardPath` reads a '!' path\n  _readForwardPath(token) {\n    let subject, predicate;\n    const object = this._factory.blankNode();\n    // The next token is the predicate\n    if ((predicate = this._readEntity(token)) === undefined)\n      return;\n    // If we were reading a subject, replace the subject by the path's object\n    if (this._predicate === null)\n      subject = this._subject, this._subject = object;\n    // If we were reading an object, replace the subject by the path's object\n    else\n      subject = this._object,  this._object  = object;\n    // Emit the path's current quad and read its next section\n    this._emit(subject, predicate, object, this._graph);\n    return this._readPath;\n  }\n\n  // ### `_readBackwardPath` reads a '^' path\n  _readBackwardPath(token) {\n    const subject = this._factory.blankNode();\n    let predicate, object;\n    // The next token is the predicate\n    if ((predicate = this._readEntity(token)) === undefined)\n      return;\n    // If we were reading a subject, replace the subject by the path's subject\n    if (this._predicate === null)\n      object = this._subject, this._subject = subject;\n    // If we were reading an object, replace the subject by the path's subject\n    else\n      object = this._object,  this._object  = subject;\n    // Emit the path's current quad and read its next section\n    this._emit(subject, predicate, object, this._graph);\n    return this._readPath;\n  }\n\n  // ### `_readRDFStarTailOrGraph` reads the graph of a nested RDF-star quad or the end of a nested RDF-star triple\n  _readRDFStarTailOrGraph(token) {\n    if (token.type !== '>>') {\n      // An entity means this is a quad (only allowed if not already inside a graph)\n      if (this._supportsQuads && this._graph === null && (this._graph = this._readEntity(token)) !== undefined)\n        return this._readRDFStarTail;\n      return this._error(`Expected >> to follow \"${this._object.id}\"`, token);\n    }\n    return this._readRDFStarTail(token);\n  }\n\n  // ### `_readRDFStarTail` reads the end of a nested RDF-star triple\n  _readRDFStarTail(token) {\n    if (token.type !== '>>')\n      return this._error(`Expected >> but got ${token.type}`, token);\n    // Read the quad and restore the previous context\n    const quad = this._factory.quad(this._subject, this._predicate, this._object,\n      this._graph || this.DEFAULTGRAPH);\n    this._restoreContext('<<', token);\n    // If the triple was the subject, continue by reading the predicate.\n    if (this._subject === null) {\n      this._subject = quad;\n      return this._readPredicate;\n    }\n    // If the triple was the object, read context end.\n    else {\n      this._object = quad;\n      return this._getContextEndReader();\n    }\n  }\n\n  // ### `_getContextEndReader` gets the next reader function at the end of a context\n  _getContextEndReader() {\n    const contextStack = this._contextStack;\n    if (!contextStack.length)\n      return this._readPunctuation;\n\n    switch (contextStack[contextStack.length - 1].type) {\n    case 'blank':\n      return this._readBlankNodeTail;\n    case 'list':\n      return this._readListItem;\n    case 'formula':\n      return this._readFormulaTail;\n    case '<<':\n      return this._readRDFStarTailOrGraph;\n    }\n  }\n\n  // ### `_emit` sends a quad through the callback\n  _emit(subject, predicate, object, graph) {\n    this._callback(null, this._factory.quad(subject, predicate, object, graph || this.DEFAULTGRAPH));\n  }\n\n  // ### `_error` emits an error message through the callback\n  _error(message, token) {\n    const err = new Error(`${message} on line ${token.line}.`);\n    err.context = {\n      token: token,\n      line: token.line,\n      previousToken: this._lexer.previousToken,\n    };\n    this._callback(err);\n    this._callback = noop;\n  }\n\n  // ### `_resolveIRI` resolves an IRI against the base path\n  _resolveIRI(iri) {\n    return /^[a-z][a-z0-9+.-]*:/i.test(iri) ? iri : this._resolveRelativeIRI(iri);\n  }\n\n  // ### `_resolveRelativeIRI` resolves an IRI against the base path,\n  // assuming that a base path has been set and that the IRI is indeed relative\n  _resolveRelativeIRI(iri) {\n    // An empty relative IRI indicates the base IRI\n    if (!iri.length)\n      return this._base;\n    // Decide resolving strategy based in the first character\n    switch (iri[0]) {\n    // Resolve relative fragment IRIs against the base IRI\n    case '#': return this._base + iri;\n    // Resolve relative query string IRIs by replacing the query string\n    case '?': return this._base.replace(/(?:\\?.*)?$/, iri);\n    // Resolve root-relative IRIs at the root of the base IRI\n    case '/':\n      // Resolve scheme-relative IRIs to the scheme\n      return (iri[1] === '/' ? this._baseScheme : this._baseRoot) + this._removeDotSegments(iri);\n    // Resolve all other IRIs at the base IRI's path\n    default:\n      // Relative IRIs cannot contain a colon in the first path segment\n      return (/^[^/:]*:/.test(iri)) ? null : this._removeDotSegments(this._basePath + iri);\n    }\n  }\n\n  // ### `_removeDotSegments` resolves './' and '../' path segments in an IRI as per RFC3986\n  _removeDotSegments(iri) {\n    // Don't modify the IRI if it does not contain any dot segments\n    if (!/(^|\\/)\\.\\.?($|[/#?])/.test(iri))\n      return iri;\n\n    // Start with an imaginary slash before the IRI in order to resolve trailing './' and '../'\n    const length = iri.length;\n    let result = '', i = -1, pathStart = -1, segmentStart = 0, next = '/';\n\n    while (i < length) {\n      switch (next) {\n      // The path starts with the first slash after the authority\n      case ':':\n        if (pathStart < 0) {\n          // Skip two slashes before the authority\n          if (iri[++i] === '/' && iri[++i] === '/')\n            // Skip to slash after the authority\n            while ((pathStart = i + 1) < length && iri[pathStart] !== '/')\n              i = pathStart;\n        }\n        break;\n      // Don't modify a query string or fragment\n      case '?':\n      case '#':\n        i = length;\n        break;\n      // Handle '/.' or '/..' path segments\n      case '/':\n        if (iri[i + 1] === '.') {\n          next = iri[++i + 1];\n          switch (next) {\n          // Remove a '/.' segment\n          case '/':\n            result += iri.substring(segmentStart, i - 1);\n            segmentStart = i + 1;\n            break;\n          // Remove a trailing '/.' segment\n          case undefined:\n          case '?':\n          case '#':\n            return result + iri.substring(segmentStart, i) + iri.substr(i + 1);\n          // Remove a '/..' segment\n          case '.':\n            next = iri[++i + 1];\n            if (next === undefined || next === '/' || next === '?' || next === '#') {\n              result += iri.substring(segmentStart, i - 2);\n              // Try to remove the parent path from result\n              if ((segmentStart = result.lastIndexOf('/')) >= pathStart)\n                result = result.substr(0, segmentStart);\n              // Remove a trailing '/..' segment\n              if (next !== '/')\n                return `${result}/${iri.substr(i + 1)}`;\n              segmentStart = i + 1;\n            }\n          }\n        }\n      }\n      next = iri[++i];\n    }\n    return result + iri.substring(segmentStart);\n  }\n\n  // ## Public methods\n\n  // ### `parse` parses the N3 input and emits each parsed quad through the onQuad callback.\n  parse(input, quadCallback, prefixCallback) {\n    // The second parameter accepts an object { onQuad: ..., onPrefix: ..., onComment: ...}\n    // As a second and third parameter it still accepts a separate quadCallback and prefixCallback for backward compatibility as well\n    let onQuad, onPrefix, onComment;\n    if (quadCallback && (quadCallback.onQuad || quadCallback.onPrefix || quadCallback.onComment)) {\n      onQuad = quadCallback.onQuad;\n      onPrefix = quadCallback.onPrefix;\n      onComment = quadCallback.onComment;\n    }\n    else {\n      onQuad = quadCallback;\n      onPrefix = prefixCallback;\n    }\n    // The read callback is the next function to be executed when a token arrives.\n    // We start reading in the top context.\n    this._readCallback = this._readInTopContext;\n    this._sparqlStyle = false;\n    this._prefixes = Object.create(null);\n    this._prefixes._ = this._blankNodePrefix ? this._blankNodePrefix.substr(2)\n                                             : `b${blankNodePrefix++}_`;\n    this._prefixCallback = onPrefix || noop;\n    this._inversePredicate = false;\n    this._quantified = Object.create(null);\n\n    // Parse synchronously if no quad callback is given\n    if (!onQuad) {\n      const quads = [];\n      let error;\n      this._callback = (e, t) => { e ? (error = e) : t && quads.push(t); };\n      this._lexer.tokenize(input).every(token => {\n        return this._readCallback = this._readCallback(token);\n      });\n      if (error) throw error;\n      return quads;\n    }\n\n    let processNextToken = (error, token) => {\n      if (error !== null)\n        this._callback(error), this._callback = noop;\n      else if (this._readCallback)\n        this._readCallback = this._readCallback(token);\n    };\n\n    // Enable checking for comments on every token when a commentCallback has been set\n    if (onComment) {\n      // Enable the lexer to return comments as tokens first (disabled by default)\n      this._lexer.comments = true;\n      // Patch the processNextToken function\n      processNextToken = (error, token) => {\n        if (error !== null)\n          this._callback(error), this._callback = noop;\n        else if (this._readCallback) {\n          if (token.type === 'comment')\n            onComment(token.value);\n          else\n            this._readCallback = this._readCallback(token);\n        }\n      };\n    }\n\n    // Parse asynchronously otherwise, executing the read callback when a token arrives\n    this._callback = onQuad;\n    this._lexer.tokenize(input, processNextToken);\n  }\n}\n\n// The empty function\nfunction noop() {}\n\n// Initializes the parser with the given data factory\nfunction initDataFactory(parser, factory) {\n  parser._factory = factory;\n\n  parser.DEFAULTGRAPH = factory.defaultGraph();\n\n  // Set common named nodes\n  parser.RDF_FIRST  = factory.namedNode(namespaces.rdf.first);\n  parser.RDF_REST   = factory.namedNode(namespaces.rdf.rest);\n  parser.RDF_NIL    = factory.namedNode(namespaces.rdf.nil);\n  parser.N3_FORALL  = factory.namedNode(namespaces.r.forAll);\n  parser.N3_FORSOME = factory.namedNode(namespaces.r.forSome);\n  parser.ABBREVIATIONS = {\n    'a': factory.namedNode(namespaces.rdf.type),\n    '=': factory.namedNode(namespaces.owl.sameAs),\n    '>': factory.namedNode(namespaces.log.implies),\n    '<': factory.namedNode(namespaces.log.isImpliedBy),\n  };\n  parser.QUANTIFIERS_GRAPH = factory.namedNode('urn:n3:quantifiers');\n}\ninitDataFactory(N3Parser.prototype, N3DataFactory);\n","// N3.js implementations of the RDF/JS core data types\n// See http://rdf.js.org/data-model-spec/\n\nimport namespaces from './IRIs';\n\nconst { rdf, xsd } = namespaces;\n\n// eslint-disable-next-line prefer-const\nlet DEFAULTGRAPH;\nlet _blankNodeCounter = 0;\n\nconst escapedLiteral = /^\"(.*\".*)(?=\"[^\"]*$)/;\n\n// ## DataFactory singleton\nconst DataFactory = {\n  namedNode,\n  blankNode,\n  variable,\n  literal,\n  defaultGraph,\n  quad,\n  triple: quad,\n  fromTerm,\n  fromQuad,\n};\nexport default DataFactory;\n\n// ## Term constructor\nexport class Term {\n  constructor(id) {\n    this.id = id;\n  }\n\n  // ### The value of this term\n  get value() {\n    return this.id;\n  }\n\n  // ### Returns whether this object represents the same term as the other\n  equals(other) {\n    // If both terms were created by this library,\n    // equality can be computed through ids\n    if (other instanceof Term)\n      return this.id === other.id;\n    // Otherwise, compare term type and value\n    return !!other && this.termType === other.termType &&\n                      this.value    === other.value;\n  }\n\n  // ### Implement hashCode for Immutable.js, since we implement `equals`\n  // https://immutable-js.com/docs/v4.0.0/ValueObject/#hashCode()\n  hashCode() {\n    return 0;\n  }\n\n  // ### Returns a plain object representation of this term\n  toJSON() {\n    return {\n      termType: this.termType,\n      value:    this.value,\n    };\n  }\n}\n\n\n// ## NamedNode constructor\nexport class NamedNode extends Term {\n  // ### The term type of this term\n  get termType() {\n    return 'NamedNode';\n  }\n}\n\n// ## Literal constructor\nexport class Literal extends Term {\n  // ### The term type of this term\n  get termType() {\n    return 'Literal';\n  }\n\n  // ### The text value of this literal\n  get value() {\n    return this.id.substring(1, this.id.lastIndexOf('\"'));\n  }\n\n  // ### The language of this literal\n  get language() {\n    // Find the last quotation mark (e.g., '\"abc\"@en-us')\n    const id = this.id;\n    let atPos = id.lastIndexOf('\"') + 1;\n    // If \"@\" it follows, return the remaining substring; empty otherwise\n    return atPos < id.length && id[atPos++] === '@' ? id.substr(atPos).toLowerCase() : '';\n  }\n\n  // ### The datatype IRI of this literal\n  get datatype() {\n    return new NamedNode(this.datatypeString);\n  }\n\n  // ### The datatype string of this literal\n  get datatypeString() {\n    // Find the last quotation mark (e.g., '\"abc\"^^http://ex.org/types#t')\n    const id = this.id, dtPos = id.lastIndexOf('\"') + 1;\n    const char = dtPos < id.length ? id[dtPos] : '';\n    // If \"^\" it follows, return the remaining substring\n    return char === '^' ? id.substr(dtPos + 2) :\n           // If \"@\" follows, return rdf:langString; xsd:string otherwise\n           (char !== '@' ? xsd.string : rdf.langString);\n  }\n\n  // ### Returns whether this object represents the same term as the other\n  equals(other) {\n    // If both literals were created by this library,\n    // equality can be computed through ids\n    if (other instanceof Literal)\n      return this.id === other.id;\n    // Otherwise, compare term type, value, language, and datatype\n    return !!other && !!other.datatype &&\n                      this.termType === other.termType &&\n                      this.value    === other.value    &&\n                      this.language === other.language &&\n                      this.datatype.value === other.datatype.value;\n  }\n\n  toJSON() {\n    return {\n      termType: this.termType,\n      value:    this.value,\n      language: this.language,\n      datatype: { termType: 'NamedNode', value: this.datatypeString },\n    };\n  }\n}\n\n// ## BlankNode constructor\nexport class BlankNode extends Term {\n  constructor(name) {\n    super(`_:${name}`);\n  }\n\n  // ### The term type of this term\n  get termType() {\n    return 'BlankNode';\n  }\n\n  // ### The name of this blank node\n  get value() {\n    return this.id.substr(2);\n  }\n}\n\nexport class Variable extends Term {\n  constructor(name) {\n    super(`?${name}`);\n  }\n\n  // ### The term type of this term\n  get termType() {\n    return 'Variable';\n  }\n\n  // ### The name of this variable\n  get value() {\n    return this.id.substr(1);\n  }\n}\n\n// ## DefaultGraph constructor\nexport class DefaultGraph extends Term {\n  constructor() {\n    super('');\n    return DEFAULTGRAPH || this;\n  }\n\n  // ### The term type of this term\n  get termType() {\n    return 'DefaultGraph';\n  }\n\n  // ### Returns whether this object represents the same term as the other\n  equals(other) {\n    // If both terms were created by this library,\n    // equality can be computed through strict equality;\n    // otherwise, compare term types.\n    return (this === other) || (!!other && (this.termType === other.termType));\n  }\n}\n\n// ## DefaultGraph singleton\nDEFAULTGRAPH = new DefaultGraph();\n\n// ### Constructs a term from the given internal string ID\n// The third 'nested' parameter of this function is to aid\n// with recursion over nested terms. It should not be used\n// by consumers of this library.\n// See https://github.com/rdfjs/N3.js/pull/311#discussion_r1061042725\nexport function termFromId(id, factory, nested) {\n  factory = factory || DataFactory;\n\n  // Falsy value or empty string indicate the default graph\n  if (!id)\n    return factory.defaultGraph();\n\n  // Identify the term type based on the first character\n  switch (id[0]) {\n  case '?':\n    return factory.variable(id.substr(1));\n  case '_':\n    return factory.blankNode(id.substr(2));\n  case '\"':\n    // Shortcut for internal literals\n    if (factory === DataFactory)\n      return new Literal(id);\n    // Literal without datatype or language\n    if (id[id.length - 1] === '\"')\n      return factory.literal(id.substr(1, id.length - 2));\n    // Literal with datatype or language\n    const endPos = id.lastIndexOf('\"', id.length - 1);\n    return factory.literal(id.substr(1, endPos - 1),\n            id[endPos + 1] === '@' ? id.substr(endPos + 2)\n                                   : factory.namedNode(id.substr(endPos + 3)));\n  case '[':\n    id = JSON.parse(id);\n    break;\n  default:\n    if (!nested || !Array.isArray(id)) {\n      return factory.namedNode(id);\n    }\n  }\n  return factory.quad(\n    termFromId(id[0], factory, true),\n    termFromId(id[1], factory, true),\n    termFromId(id[2], factory, true),\n    id[3] && termFromId(id[3], factory, true),\n  );\n}\n\n// ### Constructs an internal string ID from the given term or ID string\n// The third 'nested' parameter of this function is to aid\n// with recursion over nested terms. It should not be used\n// by consumers of this library.\n// See https://github.com/rdfjs/N3.js/pull/311#discussion_r1061042725\nexport function termToId(term, nested) {\n  if (typeof term === 'string')\n    return term;\n  if (term instanceof Term && term.termType !== 'Quad')\n    return term.id;\n  if (!term)\n    return DEFAULTGRAPH.id;\n\n  // Term instantiated with another library\n  switch (term.termType) {\n  case 'NamedNode':    return term.value;\n  case 'BlankNode':    return `_:${term.value}`;\n  case 'Variable':     return `?${term.value}`;\n  case 'DefaultGraph': return '';\n  case 'Literal':      return `\"${term.value}\"${\n    term.language ? `@${term.language}` :\n      (term.datatype && term.datatype.value !== xsd.string ? `^^${term.datatype.value}` : '')}`;\n  case 'Quad':\n    const res = [\n      termToId(term.subject, true),\n      termToId(term.predicate, true),\n      termToId(term.object, true),\n    ];\n    if (term.graph && term.graph.termType !== 'DefaultGraph') {\n      res.push(termToId(term.graph, true));\n    }\n    return nested ? res : JSON.stringify(res);\n  default: throw new Error(`Unexpected termType: ${term.termType}`);\n  }\n}\n\n\n// ## Quad constructor\nexport class Quad extends Term {\n  constructor(subject, predicate, object, graph) {\n    super('');\n    this._subject   = subject;\n    this._predicate = predicate;\n    this._object    = object;\n    this._graph     = graph || DEFAULTGRAPH;\n  }\n\n  // ### The term type of this term\n  get termType() {\n    return 'Quad';\n  }\n\n  get subject() {\n    return this._subject;\n  }\n\n  get predicate() {\n    return this._predicate;\n  }\n\n  get object() {\n    return this._object;\n  }\n\n  get graph() {\n    return this._graph;\n  }\n\n  // ### Returns a plain object representation of this quad\n  toJSON() {\n    return {\n      termType:  this.termType,\n      subject:   this._subject.toJSON(),\n      predicate: this._predicate.toJSON(),\n      object:    this._object.toJSON(),\n      graph:     this._graph.toJSON(),\n    };\n  }\n\n  // ### Returns whether this object represents the same quad as the other\n  equals(other) {\n    return !!other && this._subject.equals(other.subject)     &&\n                      this._predicate.equals(other.predicate) &&\n                      this._object.equals(other.object)       &&\n                      this._graph.equals(other.graph);\n  }\n}\nexport { Quad as Triple };\n\n// ### Escapes the quotes within the given literal\nexport function escapeQuotes(id) {\n  return id.replace(escapedLiteral, (_, quoted) => `\"${quoted.replace(/\"/g, '\"\"')}`);\n}\n\n// ### Unescapes the quotes within the given literal\nexport function unescapeQuotes(id) {\n  return id.replace(escapedLiteral, (_, quoted) => `\"${quoted.replace(/\"\"/g, '\"')}`);\n}\n\n// ### Creates an IRI\nfunction namedNode(iri) {\n  return new NamedNode(iri);\n}\n\n// ### Creates a blank node\nfunction blankNode(name) {\n  return new BlankNode(name || `n3-${_blankNodeCounter++}`);\n}\n\n// ### Creates a literal\nfunction literal(value, languageOrDataType) {\n  // Create a language-tagged string\n  if (typeof languageOrDataType === 'string')\n    return new Literal(`\"${value}\"@${languageOrDataType.toLowerCase()}`);\n\n  // Automatically determine datatype for booleans and numbers\n  let datatype = languageOrDataType ? languageOrDataType.value : '';\n  if (datatype === '') {\n    // Convert a boolean\n    if (typeof value === 'boolean')\n      datatype = xsd.boolean;\n    // Convert an integer or double\n    else if (typeof value === 'number') {\n      if (Number.isFinite(value))\n        datatype = Number.isInteger(value) ? xsd.integer : xsd.double;\n      else {\n        datatype = xsd.double;\n        if (!Number.isNaN(value))\n          value = value > 0 ? 'INF' : '-INF';\n      }\n    }\n  }\n\n  // Create a datatyped literal\n  return (datatype === '' || datatype === xsd.string) ?\n    new Literal(`\"${value}\"`) :\n    new Literal(`\"${value}\"^^${datatype}`);\n}\n\n// ### Creates a variable\nfunction variable(name) {\n  return new Variable(name);\n}\n\n// ### Returns the default graph\nfunction defaultGraph() {\n  return DEFAULTGRAPH;\n}\n\n// ### Creates a quad\nfunction quad(subject, predicate, object, graph) {\n  return new Quad(subject, predicate, object, graph);\n}\n\nexport function fromTerm(term) {\n  if (term instanceof Term)\n    return term;\n\n  // Term instantiated with another library\n  switch (term.termType) {\n  case 'NamedNode':    return namedNode(term.value);\n  case 'BlankNode':    return blankNode(term.value);\n  case 'Variable':     return variable(term.value);\n  case 'DefaultGraph': return DEFAULTGRAPH;\n  case 'Literal':      return literal(term.value, term.language || term.datatype);\n  case 'Quad':         return fromQuad(term);\n  default:             throw new Error(`Unexpected termType: ${term.termType}`);\n  }\n}\n\nexport function fromQuad(inQuad) {\n  if (inQuad instanceof Quad)\n    return inQuad;\n\n  if (inQuad.termType !== 'Quad')\n    throw new Error(`Unexpected termType: ${inQuad.termType}`);\n\n  return quad(fromTerm(inQuad.subject), fromTerm(inQuad.predicate), fromTerm(inQuad.object), fromTerm(inQuad.graph));\n}\n","// **N3Writer** writes N3 documents.\nimport namespaces from './IRIs';\nimport { default as N3DataFactory, Term } from './N3DataFactory';\nimport { isDefaultGraph } from './N3Util';\nimport BaseIRI from './BaseIRI';\nimport { escapeRegex } from './Util';\n\nconst DEFAULTGRAPH = N3DataFactory.defaultGraph();\n\nconst { rdf, xsd } = namespaces;\n\n// Characters in literals that require escaping\nconst escape    = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019\\ud800-\\udbff]/,\n    escapeAll = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019]|[\\ud800-\\udbff][\\udc00-\\udfff]/g,\n    escapedCharacters = {\n      '\\\\': '\\\\\\\\', '\"': '\\\\\"', '\\t': '\\\\t',\n      '\\n': '\\\\n', '\\r': '\\\\r', '\\b': '\\\\b', '\\f': '\\\\f',\n    };\n\n// ## Placeholder class to represent already pretty-printed terms\nclass SerializedTerm extends Term {\n  // Pretty-printed nodes are not equal to any other node\n  // (e.g., [] does not equal [])\n  equals(other) {\n    return other === this;\n  }\n}\n\n// ## Constructor\nexport default class N3Writer {\n  constructor(outputStream, options) {\n    // ### `_prefixRegex` matches a prefixed name or IRI that begins with one of the added prefixes\n    this._prefixRegex = /$0^/;\n\n    // Shift arguments if the first argument is not a stream\n    if (outputStream && typeof outputStream.write !== 'function')\n      options = outputStream, outputStream = null;\n    options = options || {};\n    this._lists = options.lists;\n\n    // If no output stream given, send the output as string through the end callback\n    if (!outputStream) {\n      let output = '';\n      this._outputStream = {\n        write(chunk, encoding, done) { output += chunk; done && done(); },\n        end: done => { done && done(null, output); },\n      };\n      this._endStream = true;\n    }\n    else {\n      this._outputStream = outputStream;\n      this._endStream = options.end === undefined ? true : !!options.end;\n    }\n\n    // Initialize writer, depending on the format\n    this._subject = null;\n    if (!(/triple|quad/i).test(options.format)) {\n      this._lineMode = false;\n      this._graph = DEFAULTGRAPH;\n      this._prefixIRIs = Object.create(null);\n      options.prefixes && this.addPrefixes(options.prefixes);\n      if (options.baseIRI) {\n        this._baseIri = new BaseIRI(options.baseIRI);\n      }\n    }\n    else {\n      this._lineMode = true;\n      this._writeQuad = this._writeQuadLine;\n    }\n  }\n\n  // ## Private methods\n\n  // ### Whether the current graph is the default graph\n  get _inDefaultGraph() {\n    return DEFAULTGRAPH.equals(this._graph);\n  }\n\n  // ### `_write` writes the argument to the output stream\n  _write(string, callback) {\n    this._outputStream.write(string, 'utf8', callback);\n  }\n\n  // ### `_writeQuad` writes the quad to the output stream\n  _writeQuad(subject, predicate, object, graph, done) {\n    try {\n      // Write the graph's label if it has changed\n      if (!graph.equals(this._graph)) {\n        // Close the previous graph and start the new one\n        this._write((this._subject === null ? '' : (this._inDefaultGraph ? '.\\n' : '\\n}\\n')) +\n                    (DEFAULTGRAPH.equals(graph) ? '' : `${this._encodeIriOrBlank(graph)} {\\n`));\n        this._graph = graph;\n        this._subject = null;\n      }\n      // Don't repeat the subject if it's the same\n      if (subject.equals(this._subject)) {\n        // Don't repeat the predicate if it's the same\n        if (predicate.equals(this._predicate))\n          this._write(`, ${this._encodeObject(object)}`, done);\n        // Same subject, different predicate\n        else\n          this._write(`;\\n    ${\n                      this._encodePredicate(this._predicate = predicate)} ${\n                      this._encodeObject(object)}`, done);\n      }\n      // Different subject; write the whole quad\n      else\n        this._write(`${(this._subject === null ? '' : '.\\n') +\n                    this._encodeSubject(this._subject = subject)} ${\n                    this._encodePredicate(this._predicate = predicate)} ${\n                    this._encodeObject(object)}`, done);\n    }\n    catch (error) { done && done(error); }\n  }\n\n  // ### `_writeQuadLine` writes the quad to the output stream as a single line\n  _writeQuadLine(subject, predicate, object, graph, done) {\n    // Write the quad without prefixes\n    delete this._prefixMatch;\n    this._write(this.quadToString(subject, predicate, object, graph), done);\n  }\n\n  // ### `quadToString` serializes a quad as a string\n  quadToString(subject, predicate, object, graph) {\n    return  `${this._encodeSubject(subject)} ${\n            this._encodeIriOrBlank(predicate)} ${\n            this._encodeObject(object)\n            }${graph && graph.value ? ` ${this._encodeIriOrBlank(graph)} .\\n` : ' .\\n'}`;\n  }\n\n  // ### `quadsToString` serializes an array of quads as a string\n  quadsToString(quads) {\n    let quadsString = '';\n    for (const quad of quads)\n      quadsString += this.quadToString(quad.subject, quad.predicate, quad.object, quad.graph);\n    return quadsString;\n  }\n\n  // ### `_encodeSubject` represents a subject\n  _encodeSubject(entity) {\n    return entity.termType === 'Quad' ?\n      this._encodeQuad(entity) : this._encodeIriOrBlank(entity);\n  }\n\n  // ### `_encodeIriOrBlank` represents an IRI or blank node\n  _encodeIriOrBlank(entity) {\n    // A blank node or list is represented as-is\n    if (entity.termType !== 'NamedNode') {\n      // If it is a list head, pretty-print it\n      if (this._lists && (entity.value in this._lists))\n        entity = this.list(this._lists[entity.value]);\n      return 'id' in entity ? entity.id : `_:${entity.value}`;\n    }\n    let iri = entity.value;\n    // Use relative IRIs if requested and possible\n    if (this._baseIri) {\n      iri = this._baseIri.toRelative(iri);\n    }\n    // Escape special characters\n    if (escape.test(iri))\n      iri = iri.replace(escapeAll, characterReplacer);\n    // Try to represent the IRI as prefixed name\n    const prefixMatch = this._prefixRegex.exec(iri);\n    return !prefixMatch ? `<${iri}>` :\n           (!prefixMatch[1] ? iri : this._prefixIRIs[prefixMatch[1]] + prefixMatch[2]);\n  }\n\n  // ### `_encodeLiteral` represents a literal\n  _encodeLiteral(literal) {\n    // Escape special characters\n    let value = literal.value;\n    if (escape.test(value))\n      value = value.replace(escapeAll, characterReplacer);\n\n    // Write a language-tagged literal\n    if (literal.language)\n      return `\"${value}\"@${literal.language}`;\n\n    // Write dedicated literals per data type\n    if (this._lineMode) {\n      // Only abbreviate strings in N-Triples or N-Quads\n      if (literal.datatype.value === xsd.string)\n        return `\"${value}\"`;\n    }\n    else {\n      // Use common datatype abbreviations in Turtle or TriG\n      switch (literal.datatype.value) {\n      case xsd.string:\n        return `\"${value}\"`;\n      case xsd.boolean:\n        if (value === 'true' || value === 'false')\n          return value;\n        break;\n      case xsd.integer:\n        if (/^[+-]?\\d+$/.test(value))\n          return value;\n        break;\n      case xsd.decimal:\n        if (/^[+-]?\\d*\\.\\d+$/.test(value))\n          return value;\n        break;\n      case xsd.double:\n        if (/^[+-]?(?:\\d+\\.\\d*|\\.?\\d+)[eE][+-]?\\d+$/.test(value))\n          return value;\n        break;\n      }\n    }\n\n    // Write a regular datatyped literal\n    return `\"${value}\"^^${this._encodeIriOrBlank(literal.datatype)}`;\n  }\n\n  // ### `_encodePredicate` represents a predicate\n  _encodePredicate(predicate) {\n    return predicate.value === rdf.type ? 'a' : this._encodeIriOrBlank(predicate);\n  }\n\n  // ### `_encodeObject` represents an object\n  _encodeObject(object) {\n    switch (object.termType) {\n    case 'Quad':\n      return this._encodeQuad(object);\n    case 'Literal':\n      return this._encodeLiteral(object);\n    default:\n      return this._encodeIriOrBlank(object);\n    }\n  }\n\n  // ### `_encodeQuad` encodes an RDF-star quad\n  _encodeQuad({ subject, predicate, object, graph }) {\n    return `<<${\n      this._encodeSubject(subject)} ${\n      this._encodePredicate(predicate)} ${\n      this._encodeObject(object)}${\n      isDefaultGraph(graph) ? '' : ` ${this._encodeIriOrBlank(graph)}`}>>`;\n  }\n\n  // ### `_blockedWrite` replaces `_write` after the writer has been closed\n  _blockedWrite() {\n    throw new Error('Cannot write because the writer has been closed.');\n  }\n\n  // ### `addQuad` adds the quad to the output stream\n  addQuad(subject, predicate, object, graph, done) {\n    // The quad was given as an object, so shift parameters\n    if (object === undefined)\n      this._writeQuad(subject.subject, subject.predicate, subject.object, subject.graph, predicate);\n    // The optional `graph` parameter was not provided\n    else if (typeof graph === 'function')\n      this._writeQuad(subject, predicate, object, DEFAULTGRAPH, graph);\n    // The `graph` parameter was provided\n    else\n      this._writeQuad(subject, predicate, object, graph || DEFAULTGRAPH, done);\n  }\n\n  // ### `addQuads` adds the quads to the output stream\n  addQuads(quads) {\n    for (let i = 0; i < quads.length; i++)\n      this.addQuad(quads[i]);\n  }\n\n  // ### `addPrefix` adds the prefix to the output stream\n  addPrefix(prefix, iri, done) {\n    const prefixes = {};\n    prefixes[prefix] = iri;\n    this.addPrefixes(prefixes, done);\n  }\n\n  // ### `addPrefixes` adds the prefixes to the output stream\n  addPrefixes(prefixes, done) {\n    // Ignore prefixes if not supported by the serialization\n    if (!this._prefixIRIs)\n      return done && done();\n\n    // Write all new prefixes\n    let hasPrefixes = false;\n    for (let prefix in prefixes) {\n      let iri = prefixes[prefix];\n      if (typeof iri !== 'string')\n        iri = iri.value;\n      hasPrefixes = true;\n      // Finish a possible pending quad\n      if (this._subject !== null) {\n        this._write(this._inDefaultGraph ? '.\\n' : '\\n}\\n');\n        this._subject = null, this._graph = '';\n      }\n      // Store and write the prefix\n      this._prefixIRIs[iri] = (prefix += ':');\n      this._write(`@prefix ${prefix} <${iri}>.\\n`);\n    }\n    // Recreate the prefix matcher\n    if (hasPrefixes) {\n      let IRIlist = '', prefixList = '';\n      for (const prefixIRI in this._prefixIRIs) {\n        IRIlist += IRIlist ? `|${prefixIRI}` : prefixIRI;\n        prefixList += (prefixList ? '|' : '') + this._prefixIRIs[prefixIRI];\n      }\n      IRIlist = escapeRegex(IRIlist, /[\\]\\/\\(\\)\\*\\+\\?\\.\\\\\\$]/g, '\\\\$&');\n      this._prefixRegex = new RegExp(`^(?:${prefixList})[^\\/]*$|` +\n                                     `^(${IRIlist})([_a-zA-Z0-9][\\\\-_a-zA-Z0-9]*)$`);\n    }\n    // End a prefix block with a newline\n    this._write(hasPrefixes ? '\\n' : '', done);\n  }\n\n  // ### `blank` creates a blank node with the given content\n  blank(predicate, object) {\n    let children = predicate, child, length;\n    // Empty blank node\n    if (predicate === undefined)\n      children = [];\n    // Blank node passed as blank(Term(\"predicate\"), Term(\"object\"))\n    else if (predicate.termType)\n      children = [{ predicate: predicate, object: object }];\n    // Blank node passed as blank({ predicate: predicate, object: object })\n    else if (!('length' in predicate))\n      children = [predicate];\n\n    switch (length = children.length) {\n    // Generate an empty blank node\n    case 0:\n      return new SerializedTerm('[]');\n    // Generate a non-nested one-triple blank node\n    case 1:\n      child = children[0];\n      if (!(child.object instanceof SerializedTerm))\n        return new SerializedTerm(`[ ${this._encodePredicate(child.predicate)} ${\n                                  this._encodeObject(child.object)} ]`);\n    // Generate a multi-triple or nested blank node\n    default:\n      let contents = '[';\n      // Write all triples in order\n      for (let i = 0; i < length; i++) {\n        child = children[i];\n        // Write only the object is the predicate is the same as the previous\n        if (child.predicate.equals(predicate))\n          contents += `, ${this._encodeObject(child.object)}`;\n        // Otherwise, write the predicate and the object\n        else {\n          contents += `${(i ? ';\\n  ' : '\\n  ') +\n                      this._encodePredicate(child.predicate)} ${\n                      this._encodeObject(child.object)}`;\n          predicate = child.predicate;\n        }\n      }\n      return new SerializedTerm(`${contents}\\n]`);\n    }\n  }\n\n  // ### `list` creates a list node with the given content\n  list(elements) {\n    const length = elements && elements.length || 0, contents = new Array(length);\n    for (let i = 0; i < length; i++)\n      contents[i] = this._encodeObject(elements[i]);\n    return new SerializedTerm(`(${contents.join(' ')})`);\n  }\n\n  // ### `end` signals the end of the output stream\n  end(done) {\n    // Finish a possible pending quad\n    if (this._subject !== null) {\n      this._write(this._inDefaultGraph ? '.\\n' : '\\n}\\n');\n      this._subject = null;\n    }\n    // Disallow further writing\n    this._write = this._blockedWrite;\n\n    // Try to end the underlying stream, ensuring done is called exactly one time\n    let singleDone = done && ((error, result) => { singleDone = null, done(error, result); });\n    if (this._endStream) {\n      try { return this._outputStream.end(singleDone); }\n      catch (error) { /* error closing stream */ }\n    }\n    singleDone && singleDone();\n  }\n}\n\n// Replaces a character by its escaped version\nfunction characterReplacer(character) {\n  // Replace a single character by its escaped version\n  let result = escapedCharacters[character];\n  if (result === undefined) {\n    // Replace a single character with its 4-bit unicode escape sequence\n    if (character.length === 1) {\n      result = character.charCodeAt(0).toString(16);\n      result = '\\\\u0000'.substr(0, 6 - result.length) + result;\n    }\n    // Replace a surrogate pair with its 8-bit unicode escape sequence\n    else {\n      result = ((character.charCodeAt(0) - 0xD800) * 0x400 +\n                 character.charCodeAt(1) + 0x2400).toString(16);\n      result = '\\\\U00000000'.substr(0, 10 - result.length) + result;\n    }\n  }\n  return result;\n}\n","// **N3Util** provides N3 utility functions.\n\nimport N3DataFactory from './N3DataFactory';\n\n// Tests whether the given term represents an IRI\nexport function isNamedNode(term) {\n  return !!term && term.termType === 'NamedNode';\n}\n\n// Tests whether the given term represents a blank node\nexport function isBlankNode(term) {\n  return !!term && term.termType === 'BlankNode';\n}\n\n// Tests whether the given term represents a literal\nexport function isLiteral(term) {\n  return !!term && term.termType === 'Literal';\n}\n\n// Tests whether the given term represents a variable\nexport function isVariable(term) {\n  return !!term && term.termType === 'Variable';\n}\n\n// Tests whether the given term represents the default graph\nexport function isDefaultGraph(term) {\n  return !!term && term.termType === 'DefaultGraph';\n}\n\n// Tests whether the given quad is in the default graph\nexport function inDefaultGraph(quad) {\n  return isDefaultGraph(quad.graph);\n}\n\n// Creates a function that prepends the given IRI to a local name\nexport function prefix(iri, factory) {\n  return prefixes({ '': iri.value || iri }, factory)('');\n}\n\n// Creates a function that allows registering and expanding prefixes\nexport function prefixes(defaultPrefixes, factory) {\n  // Add all of the default prefixes\n  const prefixes = Object.create(null);\n  for (const prefix in defaultPrefixes)\n    processPrefix(prefix, defaultPrefixes[prefix]);\n  // Set the default factory if none was specified\n  factory = factory || N3DataFactory;\n\n  // Registers a new prefix (if an IRI was specified)\n  // or retrieves a function that expands an existing prefix (if no IRI was specified)\n  function processPrefix(prefix, iri) {\n    // Create a new prefix if an IRI is specified or the prefix doesn't exist\n    if (typeof iri === 'string') {\n      // Create a function that expands the prefix\n      const cache = Object.create(null);\n      prefixes[prefix] = local => {\n        return cache[local] || (cache[local] = factory.namedNode(iri + local));\n      };\n    }\n    else if (!(prefix in prefixes)) {\n      throw new Error(`Unknown prefix: ${prefix}`);\n    }\n    return prefixes[prefix];\n  }\n  return processPrefix;\n}\n","import { escapeRegex } from './Util';\n\n// Do not handle base IRIs without scheme, and currently unsupported cases:\n// - file: IRIs (which could also use backslashes)\n// - IRIs containing /. or /.. or //\nconst BASE_UNSUPPORTED = /^:?[^:?#]*(?:[?#]|$)|^file:|^[^:]*:\\/*[^?#]+?\\/(?:\\.\\.?(?:\\/|$)|\\/)/i;\nconst SUFFIX_SUPPORTED = /^(?:(?:[^/?#]{3,}|\\.?[^/?#.]\\.?)(?:\\/[^/?#]{3,}|\\.?[^/?#.]\\.?)*\\/?)?(?:[?#]|$)/;\nconst CURRENT = './';\nconst PARENT = '../';\nconst QUERY = '?';\nconst FRAGMENT = '#';\n\nexport default class BaseIRI {\n  constructor(base) {\n    this.base = base;\n    this._baseLength = 0;\n    this._baseMatcher = null;\n    this._pathReplacements = new Array(base.length + 1);\n  }\n\n  static supports(base) {\n    return !BASE_UNSUPPORTED.test(base);\n  }\n\n  _getBaseMatcher() {\n    if (this._baseMatcher)\n      return this._baseMatcher;\n    if (!BaseIRI.supports(this.base))\n      return this._baseMatcher = /.^/;\n\n    // Extract the scheme\n    const scheme = /^[^:]*:\\/*/.exec(this.base)[0];\n    const regexHead = ['^', escapeRegex(scheme)];\n    const regexTail = [];\n\n    // Generate a regex for every path segment\n    const segments = [], segmenter = /[^/?#]*([/?#])/y;\n    let segment, query = 0, fragment = 0, last = segmenter.lastIndex = scheme.length;\n    while (!query && !fragment && (segment = segmenter.exec(this.base))) {\n      // Truncate base resolution path at fragment start\n      if (segment[1] === FRAGMENT)\n        fragment = segmenter.lastIndex - 1;\n      else {\n        // Create regex that matches the segment\n        regexHead.push(escapeRegex(segment[0]), '(?:');\n        regexTail.push(')?');\n\n        // Create dedicated query string replacement\n        if (segment[1] !== QUERY)\n          segments.push(last = segmenter.lastIndex);\n        else {\n          query = last = segmenter.lastIndex;\n          fragment = this.base.indexOf(FRAGMENT, query);\n          this._pathReplacements[query] = QUERY;\n        }\n      }\n    }\n\n    // Precalculate parent path substitutions\n    for (let i = 0; i < segments.length; i++)\n      this._pathReplacements[segments[i]] = PARENT.repeat(segments.length - i - 1);\n    this._pathReplacements[segments[segments.length - 1]] = CURRENT;\n\n    // Add the remainder of the base IRI (without fragment) to the regex\n    this._baseLength = fragment > 0 ? fragment : this.base.length;\n    regexHead.push(\n      escapeRegex(this.base.substring(last, this._baseLength)),\n      query ? '(?:#|$)' : '(?:[?#]|$)',\n    );\n    return this._baseMatcher = new RegExp([...regexHead, ...regexTail].join(''));\n  }\n\n  toRelative(iri) {\n    // Unsupported or non-matching base IRI\n    const match = this._getBaseMatcher().exec(iri);\n    if (!match)\n      return iri;\n\n    // Exact base IRI match\n    const length = match[0].length;\n    if (length === this._baseLength && length === iri.length)\n      return '';\n\n    // Parent path match\n    const parentPath = this._pathReplacements[length];\n    if (parentPath) {\n      const suffix = iri.substring(length);\n      // Don't abbreviate unsupported path\n      if (parentPath !== QUERY && !SUFFIX_SUPPORTED.test(suffix))\n        return iri;\n      // Omit ./ with fragment or query string\n      if (parentPath === CURRENT && /^[^?#]/.test(suffix))\n        return suffix;\n      // Append suffix to relative parent path\n      return parentPath + suffix;\n    }\n\n    // Fragment or query string, so include delimiter\n    return iri.substring(length - 1);\n  }\n}\n","export function escapeRegex(regex) {\n  return regex.replace(/[\\]\\/\\(\\)\\*\\+\\?\\.\\\\\\$]/g, '\\\\$&');\n}\n","// **N3Store** objects store N3 quads by graph in memory.\nimport { Readable } from 'readable-stream';\nimport { default as N3DataFactory, termToId, termFromId } from './N3DataFactory';\nimport namespaces from './IRIs';\nimport { isDefaultGraph } from './N3Util';\nimport N3Writer from './N3Writer';\n\nconst ITERATOR = Symbol('iter');\n\nfunction merge(target, source, depth = 4) {\n  if (depth === 0)\n    return Object.assign(target, source);\n\n  for (const key in source)\n    target[key] = merge(target[key] || Object.create(null), source[key], depth - 1);\n\n  return target;\n}\n\n/**\n * Determines the intersection of the `_graphs` index s1 and s2.\n * s1 and s2 *must* belong to Stores that share an `_entityIndex`.\n *\n * False is returned when there is no intersection; this should\n * *not* be set as the value for an index.\n */\nfunction intersect(s1, s2, depth = 4) {\n  let target = false;\n\n  for (const key in s1) {\n    if (key in s2) {\n      const intersection = depth === 0 ? null : intersect(s1[key], s2[key], depth - 1);\n      if (intersection !== false) {\n        target = target || Object.create(null);\n        target[key] = intersection;\n      }\n      // Depth 3 is the 'subjects', 'predicates' and 'objects' keys.\n      // If the 'subjects' index is empty, so will the 'predicates' and 'objects' index.\n      else if (depth === 3) {\n        return false;\n      }\n    }\n  }\n\n  return target;\n}\n\n/**\n * Determines the difference of the `_graphs` index s1 and s2.\n * s1 and s2 *must* belong to Stores that share an `_entityIndex`.\n *\n * False is returned when there is no difference; this should\n * *not* be set as the value for an index.\n */\nfunction difference(s1, s2, depth = 4) {\n  let target = false;\n\n  for (const key in s1) {\n    // When the key is not in the index, then none of the triples defined by s1[key] are\n    // in s2 and so we want to copy them over to the resultant store.\n    if (!(key in s2)) {\n      target = target || Object.create(null);\n      target[key] = depth === 0 ? null : merge({}, s1[key], depth - 1);\n    }\n    else if (depth !== 0) {\n      const diff = difference(s1[key], s2[key], depth - 1);\n      if (diff !== false) {\n        target = target || Object.create(null);\n        target[key] = diff;\n      }\n      // Depth 3 is the 'subjects', 'predicates' and 'objects' keys.\n      // If the 'subjects' index is empty, so will the 'predicates' and 'objects' index.\n      else if (depth === 3) {\n        return false;\n      }\n    }\n  }\n\n  return target;\n}\n\n// ## Constructor\nexport class N3EntityIndex {\n  constructor(options = {}) {\n    this._id = 1;\n    // `_ids` maps entities such as `http://xmlns.com/foaf/0.1/name` to numbers,\n    // saving memory by using only numbers as keys in `_graphs`\n    this._ids = Object.create(null);\n    this._ids[''] = 1;\n     // inverse of `_ids`\n    this._entities = Object.create(null);\n    this._entities[1] = '';\n    // `_blankNodeIndex` is the index of the last automatically named blank node\n    this._blankNodeIndex = 0;\n    this._factory = options.factory || N3DataFactory;\n  }\n\n  _termFromId(id) {\n    if (id[0] === '.') {\n      const entities = this._entities;\n      const terms = id.split('.');\n      const q = this._factory.quad(\n        this._termFromId(entities[terms[1]]),\n        this._termFromId(entities[terms[2]]),\n        this._termFromId(entities[terms[3]]),\n        terms[4] && this._termFromId(entities[terms[4]]),\n      );\n      return q;\n    }\n    return termFromId(id, this._factory);\n  }\n\n  _termToNumericId(term) {\n    if (term.termType === 'Quad') {\n      const s = this._termToNumericId(term.subject),\n          p = this._termToNumericId(term.predicate),\n          o = this._termToNumericId(term.object);\n      let g;\n\n      return s && p && o && (isDefaultGraph(term.graph) || (g = this._termToNumericId(term.graph))) &&\n        this._ids[g ? `.${s}.${p}.${o}.${g}` : `.${s}.${p}.${o}`];\n    }\n    return this._ids[termToId(term)];\n  }\n\n  _termToNewNumericId(term) {\n    // This assumes that no graph term is present - we may wish to error if there is one\n    const str = term && term.termType === 'Quad' ?\n      `.${this._termToNewNumericId(term.subject)}.${this._termToNewNumericId(term.predicate)}.${this._termToNewNumericId(term.object)}${\n        isDefaultGraph(term.graph) ? '' : `.${this._termToNewNumericId(term.graph)}`\n      }`\n      : termToId(term);\n\n    return this._ids[str] || (this._ids[this._entities[++this._id] = str] = this._id);\n  }\n\n  createBlankNode(suggestedName) {\n    let name, index;\n    // Generate a name based on the suggested name\n    if (suggestedName) {\n      name = suggestedName = `_:${suggestedName}`, index = 1;\n      while (this._ids[name])\n        name = suggestedName + index++;\n    }\n    // Generate a generic blank node name\n    else {\n      do { name = `_:b${this._blankNodeIndex++}`; }\n      while (this._ids[name]);\n    }\n    // Add the blank node to the entities, avoiding the generation of duplicates\n    this._ids[name] = ++this._id;\n    this._entities[this._id] = name;\n    return this._factory.blankNode(name.substr(2));\n  }\n}\n\n// ## Constructor\nexport default class N3Store {\n  constructor(quads, options) {\n    // The number of quads is initially zero\n    this._size = 0;\n    // `_graphs` contains subject, predicate, and object indexes per graph\n    this._graphs = Object.create(null);\n\n    // Shift parameters if `quads` is not given\n    if (!options && quads && !quads[0] && !(typeof quads.match === 'function'))\n      options = quads, quads = null;\n    options = options || {};\n    this._factory = options.factory || N3DataFactory;\n    this._entityIndex = options.entityIndex || new N3EntityIndex({ factory: this._factory });\n    this._entities = this._entityIndex._entities;\n    this._termFromId = this._entityIndex._termFromId.bind(this._entityIndex);\n    this._termToNumericId = this._entityIndex._termToNumericId.bind(this._entityIndex);\n    this._termToNewNumericId = this._entityIndex._termToNewNumericId.bind(this._entityIndex);\n\n    // Add quads if passed\n    if (quads)\n      this.addAll(quads);\n  }\n\n  // ## Public properties\n\n  // ### `size` returns the number of quads in the store\n  get size() {\n    // Return the quad count if if was cached\n    let size = this._size;\n    if (size !== null)\n      return size;\n\n    // Calculate the number of quads by counting to the deepest level\n    size = 0;\n    const graphs = this._graphs;\n    let subjects, subject;\n    for (const graphKey in graphs)\n      for (const subjectKey in (subjects = graphs[graphKey].subjects))\n        for (const predicateKey in (subject = subjects[subjectKey]))\n          size += Object.keys(subject[predicateKey]).length;\n    return this._size = size;\n  }\n\n  // ## Private methods\n\n  // ### `_addToIndex` adds a quad to a three-layered index.\n  // Returns if the index has changed, if the entry did not already exist.\n  _addToIndex(index0, key0, key1, key2) {\n    // Create layers as necessary\n    const index1 = index0[key0] || (index0[key0] = {});\n    const index2 = index1[key1] || (index1[key1] = {});\n    // Setting the key to _any_ value signals the presence of the quad\n    const existed = key2 in index2;\n    if (!existed)\n      index2[key2] = null;\n    return !existed;\n  }\n\n  // ### `_removeFromIndex` removes a quad from a three-layered index\n  _removeFromIndex(index0, key0, key1, key2) {\n    // Remove the quad from the index\n    const index1 = index0[key0], index2 = index1[key1];\n    delete index2[key2];\n\n    // Remove intermediary index layers if they are empty\n    for (const key in index2) return;\n    delete index1[key1];\n    for (const key in index1) return;\n    delete index0[key0];\n  }\n\n  // ### `_findInIndex` finds a set of quads in a three-layered index.\n  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n  // Any of these keys can be undefined, which is interpreted as a wildcard.\n  // `name0`, `name1`, and `name2` are the names of the keys at each level,\n  // used when reconstructing the resulting quad\n  // (for instance: _subject_, _predicate_, and _object_).\n  // Finally, `graphId` will be the graph of the created quads.\n  *_findInIndex(index0, key0, key1, key2, name0, name1, name2, graphId) {\n    let tmp, index1, index2;\n    const entityKeys = this._entities;\n    const graph = this._termFromId(entityKeys[graphId]);\n    const parts = { subject: null, predicate: null, object: null };\n\n    // If a key is specified, use only that part of index 0.\n    if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];\n    for (const value0 in index0) {\n      if (index1 = index0[value0]) {\n        parts[name0] = this._termFromId(entityKeys[value0]);\n        // If a key is specified, use only that part of index 1.\n        if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];\n        for (const value1 in index1) {\n          if (index2 = index1[value1]) {\n            parts[name1] = this._termFromId(entityKeys[value1]);\n            // If a key is specified, use only that part of index 2, if it exists.\n            const values = key2 ? (key2 in index2 ? [key2] : []) : Object.keys(index2);\n            // Create quads for all items found in index 2.\n            for (let l = 0; l < values.length; l++) {\n              parts[name2] = this._termFromId(entityKeys[values[l]]);\n              yield this._factory.quad(parts.subject, parts.predicate, parts.object, graph);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // ### `_loop` executes the callback on all keys of index 0\n  _loop(index0, callback) {\n    for (const key0 in index0)\n      callback(key0);\n  }\n\n  // ### `_loopByKey0` executes the callback on all keys of a certain entry in index 0\n  _loopByKey0(index0, key0, callback) {\n    let index1, key1;\n    if (index1 = index0[key0]) {\n      for (key1 in index1)\n        callback(key1);\n    }\n  }\n\n  // ### `_loopByKey1` executes the callback on given keys of all entries in index 0\n  _loopByKey1(index0, key1, callback) {\n    let key0, index1;\n    for (key0 in index0) {\n      index1 = index0[key0];\n      if (index1[key1])\n        callback(key0);\n    }\n  }\n\n  // ### `_loopBy2Keys` executes the callback on given keys of certain entries in index 2\n  _loopBy2Keys(index0, key0, key1, callback) {\n    let index1, index2, key2;\n    if ((index1 = index0[key0]) && (index2 = index1[key1])) {\n      for (key2 in index2)\n        callback(key2);\n    }\n  }\n\n  // ### `_countInIndex` counts matching quads in a three-layered index.\n  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n  // Any of these keys can be undefined, which is interpreted as a wildcard.\n  _countInIndex(index0, key0, key1, key2) {\n    let count = 0, tmp, index1, index2;\n\n    // If a key is specified, count only that part of index 0\n    if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];\n    for (const value0 in index0) {\n      if (index1 = index0[value0]) {\n        // If a key is specified, count only that part of index 1\n        if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];\n        for (const value1 in index1) {\n          if (index2 = index1[value1]) {\n            // If a key is specified, count the quad if it exists\n            if (key2) (key2 in index2) && count++;\n            // Otherwise, count all quads\n            else count += Object.keys(index2).length;\n          }\n        }\n      }\n    }\n    return count;\n  }\n\n  // ### `_getGraphs` returns an array with the given graph,\n  // or all graphs if the argument is null or undefined.\n  _getGraphs(graph) {\n    graph = graph === '' ? 1 : (graph && (this._termToNumericId(graph) || -1));\n    return typeof graph !== 'number' ? this._graphs : { [graph]: this._graphs[graph] };\n  }\n\n  // ### `_uniqueEntities` returns a function that accepts an entity ID\n  // and passes the corresponding entity to callback if it hasn't occurred before.\n  _uniqueEntities(callback) {\n    const uniqueIds = Object.create(null);\n    return id => {\n      if (!(id in uniqueIds)) {\n        uniqueIds[id] = true;\n        callback(this._termFromId(this._entities[id], this._factory));\n      }\n    };\n  }\n\n  // ## Public methods\n\n  // ### `add` adds the specified quad to the dataset.\n  // Returns the dataset instance it was called on.\n  // Existing quads, as defined in Quad.equals, will be ignored.\n  add(quad) {\n    this.addQuad(quad);\n    return this;\n  }\n\n  // ### `addQuad` adds a new quad to the store.\n  // Returns if the quad index has changed, if the quad did not already exist.\n  addQuad(subject, predicate, object, graph) {\n    // Shift arguments if a quad object is given instead of components\n    if (!predicate)\n      graph = subject.graph, object = subject.object,\n        predicate = subject.predicate, subject = subject.subject;\n\n    // Convert terms to internal string representation\n    graph = graph ? this._termToNewNumericId(graph) : 1;\n\n    // Find the graph that will contain the triple\n    let graphItem = this._graphs[graph];\n    // Create the graph if it doesn't exist yet\n    if (!graphItem) {\n      graphItem = this._graphs[graph] = { subjects: {}, predicates: {}, objects: {} };\n      // Freezing a graph helps subsequent `add` performance,\n      // and properties will never be modified anyway\n      Object.freeze(graphItem);\n    }\n\n    // Since entities can often be long IRIs, we avoid storing them in every index.\n    // Instead, we have a separate index that maps entities to numbers,\n    // which are then used as keys in the other indexes.\n    subject   = this._termToNewNumericId(subject);\n    predicate = this._termToNewNumericId(predicate);\n    object    = this._termToNewNumericId(object);\n\n    if (!this._addToIndex(graphItem.subjects,   subject,   predicate, object))\n      return false;\n    this._addToIndex(graphItem.predicates, predicate, object,    subject);\n    this._addToIndex(graphItem.objects,    object,    subject,   predicate);\n\n    // The cached quad count is now invalid\n    this._size = null;\n    return true;\n  }\n\n  // ### `addQuads` adds multiple quads to the store\n  addQuads(quads) {\n    for (let i = 0; i < quads.length; i++)\n      this.addQuad(quads[i]);\n  }\n\n  // ### `delete` removes the specified quad from the dataset.\n  // Returns the dataset instance it was called on.\n  delete(quad) {\n    this.removeQuad(quad);\n    return this;\n  }\n\n  // ### `has` determines whether a dataset includes a certain quad or quad pattern.\n  has(subjectOrQuad, predicate, object, graph) {\n    if (subjectOrQuad && subjectOrQuad.subject)\n      ({ subject: subjectOrQuad, predicate, object, graph } = subjectOrQuad);\n    return !this.readQuads(subjectOrQuad, predicate, object, graph).next().done;\n  }\n\n  // ### `import` adds a stream of quads to the store\n  import(stream) {\n    stream.on('data', quad => { this.addQuad(quad); });\n    return stream;\n  }\n\n  // ### `removeQuad` removes a quad from the store if it exists\n  removeQuad(subject, predicate, object, graph) {\n    // Shift arguments if a quad object is given instead of components\n    if (!predicate)\n      ({ subject, predicate, object, graph } = subject);\n    // Convert terms to internal string representation\n    graph = graph ? this._termToNumericId(graph) : 1;\n\n    // Find internal identifiers for all components\n    // and verify the quad exists.\n    const graphs = this._graphs;\n    let graphItem, subjects, predicates;\n    if (!(subject    = subject && this._termToNumericId(subject)) || !(predicate = predicate && this._termToNumericId(predicate)) ||\n        !(object     = object && this._termToNumericId(object))  || !(graphItem = graphs[graph])  ||\n        !(subjects   = graphItem.subjects[subject]) ||\n        !(predicates = subjects[predicate]) ||\n        !(object in predicates))\n      return false;\n\n    // Remove it from all indexes\n    this._removeFromIndex(graphItem.subjects,   subject,   predicate, object);\n    this._removeFromIndex(graphItem.predicates, predicate, object,    subject);\n    this._removeFromIndex(graphItem.objects,    object,    subject,   predicate);\n    if (this._size !== null) this._size--;\n\n    // Remove the graph if it is empty\n    for (subject in graphItem.subjects) return true;\n    delete graphs[graph];\n    return true;\n  }\n\n  // ### `removeQuads` removes multiple quads from the store\n  removeQuads(quads) {\n    for (let i = 0; i < quads.length; i++)\n      this.removeQuad(quads[i]);\n  }\n\n  // ### `remove` removes a stream of quads from the store\n  remove(stream) {\n    stream.on('data', quad => { this.removeQuad(quad); });\n    return stream;\n  }\n\n  // ### `removeMatches` removes all matching quads from the store\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  removeMatches(subject, predicate, object, graph) {\n    const stream = new Readable({ objectMode: true });\n\n    const iterable = this.readQuads(subject, predicate, object, graph);\n    stream._read = size => {\n      while (--size >= 0) {\n        const { done, value } = iterable.next();\n        if (done) {\n          stream.push(null);\n          return;\n        }\n        stream.push(value);\n      }\n    };\n\n    return this.remove(stream);\n  }\n\n  // ### `deleteGraph` removes all triples with the given graph from the store\n  deleteGraph(graph) {\n    return this.removeMatches(null, null, null, graph);\n  }\n\n  // ### `getQuads` returns an array of quads matching a pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  getQuads(subject, predicate, object, graph) {\n    return [...this.readQuads(subject, predicate, object, graph)];\n  }\n\n  /**\n   * `readQuads` returns a generator of quads matching a pattern.\n   * Setting any field to `undefined` or `null` indicates a wildcard.\n   * @deprecated Use `match` instead.\n   */\n  *readQuads(subject, predicate, object, graph) {\n    const graphs = this._getGraphs(graph);\n    let content, subjectId, predicateId, objectId;\n\n    // Translate IRIs to internal index keys.\n    if (subject   && !(subjectId   = this._termToNumericId(subject))   ||\n        predicate && !(predicateId = this._termToNumericId(predicate)) ||\n        object    && !(objectId    = this._termToNumericId(object)))\n      return;\n\n    for (const graphId in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graphId]) {\n        // Choose the optimal index, based on what fields are present\n        if (subjectId) {\n          if (objectId)\n            // If subject and object are given, the object index will be the fastest\n            yield* this._findInIndex(content.objects, objectId, subjectId, predicateId,\n                              'object', 'subject', 'predicate', graphId);\n          else\n            // If only subject and possibly predicate are given, the subject index will be the fastest\n            yield* this._findInIndex(content.subjects, subjectId, predicateId, null,\n                              'subject', 'predicate', 'object', graphId);\n        }\n        else if (predicateId)\n          // If only predicate and possibly object are given, the predicate index will be the fastest\n          yield* this._findInIndex(content.predicates, predicateId, objectId, null,\n                            'predicate', 'object', 'subject', graphId);\n        else if (objectId)\n          // If only object is given, the object index will be the fastest\n          yield* this._findInIndex(content.objects, objectId, null, null,\n                            'object', 'subject', 'predicate', graphId);\n        else\n          // If nothing is given, iterate subjects and predicates first\n          yield* this._findInIndex(content.subjects, null, null, null,\n                            'subject', 'predicate', 'object', graphId);\n      }\n    }\n  }\n\n  // ### `match` returns a new dataset that is comprised of all quads in the current instance matching the given arguments.\n  // The logic described in Quad Matching is applied for each quad in this dataset to check if it should be included in the output dataset.\n  // Note: This method always returns a new DatasetCore, even if that dataset contains no quads.\n  // Note: Since a DatasetCore is an unordered set, the order of the quads within the returned sequence is arbitrary.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  // For backwards compatibility, the object return also implements the Readable stream interface.\n  match(subject, predicate, object, graph) {\n    return new DatasetCoreAndReadableStream(this, subject, predicate, object, graph, { entityIndex: this._entityIndex });\n  }\n\n  // ### `countQuads` returns the number of quads matching a pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  countQuads(subject, predicate, object, graph) {\n    const graphs = this._getGraphs(graph);\n    let count = 0, content, subjectId, predicateId, objectId;\n\n    // Translate IRIs to internal index keys.\n    if (subject   && !(subjectId   = this._termToNumericId(subject))   ||\n        predicate && !(predicateId = this._termToNumericId(predicate)) ||\n        object    && !(objectId    = this._termToNumericId(object)))\n      return 0;\n\n    for (const graphId in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graphId]) {\n        // Choose the optimal index, based on what fields are present\n        if (subject) {\n          if (object)\n            // If subject and object are given, the object index will be the fastest\n            count += this._countInIndex(content.objects, objectId, subjectId, predicateId);\n          else\n            // If only subject and possibly predicate are given, the subject index will be the fastest\n            count += this._countInIndex(content.subjects, subjectId, predicateId, objectId);\n        }\n        else if (predicate) {\n          // If only predicate and possibly object are given, the predicate index will be the fastest\n          count += this._countInIndex(content.predicates, predicateId, objectId, subjectId);\n        }\n        else {\n          // If only object is possibly given, the object index will be the fastest\n          count += this._countInIndex(content.objects, objectId, subjectId, predicateId);\n        }\n      }\n    }\n    return count;\n  }\n\n  // ### `forEach` executes the callback on all quads.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  forEach(callback, subject, predicate, object, graph) {\n    this.some(quad => {\n      callback(quad, this);\n      return false;\n    }, subject, predicate, object, graph);\n  }\n\n  // ### `every` executes the callback on all quads,\n  // and returns `true` if it returns truthy for all them.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  every(callback, subject, predicate, object, graph) {\n    return !this.some(quad => !callback(quad, this), subject, predicate, object, graph);\n  }\n\n  // ### `some` executes the callback on all quads,\n  // and returns `true` if it returns truthy for any of them.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  some(callback, subject, predicate, object, graph) {\n    for (const quad of this.readQuads(subject, predicate, object, graph))\n      if (callback(quad, this))\n        return true;\n    return false;\n  }\n\n  // ### `getSubjects` returns all subjects that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  getSubjects(predicate, object, graph) {\n    const results = [];\n    this.forSubjects(s => { results.push(s); }, predicate, object, graph);\n    return results;\n  }\n\n  // ### `forSubjects` executes the callback on all subjects that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  forSubjects(callback, predicate, object, graph) {\n    const graphs = this._getGraphs(graph);\n    let content, predicateId, objectId;\n    callback = this._uniqueEntities(callback);\n\n    // Translate IRIs to internal index keys.\n    if (predicate && !(predicateId = this._termToNumericId(predicate)) ||\n        object    && !(objectId    = this._termToNumericId(object)))\n      return;\n\n    for (graph in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graph]) {\n        // Choose optimal index based on which fields are wildcards\n        if (predicateId) {\n          if (objectId)\n            // If predicate and object are given, the POS index is best.\n            this._loopBy2Keys(content.predicates, predicateId, objectId, callback);\n          else\n            // If only predicate is given, the SPO index is best.\n            this._loopByKey1(content.subjects, predicateId, callback);\n        }\n        else if (objectId)\n          // If only object is given, the OSP index is best.\n          this._loopByKey0(content.objects, objectId, callback);\n        else\n          // If no params given, iterate all the subjects\n          this._loop(content.subjects, callback);\n      }\n    }\n  }\n\n  // ### `getPredicates` returns all predicates that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  getPredicates(subject, object, graph) {\n    const results = [];\n    this.forPredicates(p => { results.push(p); }, subject, object, graph);\n    return results;\n  }\n\n  // ### `forPredicates` executes the callback on all predicates that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  forPredicates(callback, subject, object, graph) {\n    const graphs = this._getGraphs(graph);\n    let content, subjectId, objectId;\n    callback = this._uniqueEntities(callback);\n\n    // Translate IRIs to internal index keys.\n    if (subject   && !(subjectId   = this._termToNumericId(subject))   ||\n        object    && !(objectId    = this._termToNumericId(object)))\n      return;\n\n    for (graph in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graph]) {\n        // Choose optimal index based on which fields are wildcards\n        if (subjectId) {\n          if (objectId)\n            // If subject and object are given, the OSP index is best.\n            this._loopBy2Keys(content.objects, objectId, subjectId, callback);\n          else\n            // If only subject is given, the SPO index is best.\n            this._loopByKey0(content.subjects, subjectId, callback);\n        }\n        else if (objectId)\n          // If only object is given, the POS index is best.\n          this._loopByKey1(content.predicates, objectId, callback);\n        else\n          // If no params given, iterate all the predicates.\n          this._loop(content.predicates, callback);\n      }\n    }\n  }\n\n  // ### `getObjects` returns all objects that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  getObjects(subject, predicate, graph) {\n    const results = [];\n    this.forObjects(o => { results.push(o); }, subject, predicate, graph);\n    return results;\n  }\n\n  // ### `forObjects` executes the callback on all objects that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  forObjects(callback, subject, predicate, graph) {\n    const graphs = this._getGraphs(graph);\n    let content, subjectId, predicateId;\n    callback = this._uniqueEntities(callback);\n\n    // Translate IRIs to internal index keys.\n    if (subject   && !(subjectId   = this._termToNumericId(subject))   ||\n        predicate && !(predicateId = this._termToNumericId(predicate)))\n      return;\n\n    for (graph in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graph]) {\n        // Choose optimal index based on which fields are wildcards\n        if (subjectId) {\n          if (predicateId)\n            // If subject and predicate are given, the SPO index is best.\n            this._loopBy2Keys(content.subjects, subjectId, predicateId, callback);\n          else\n            // If only subject is given, the OSP index is best.\n            this._loopByKey1(content.objects, subjectId, callback);\n        }\n        else if (predicateId)\n          // If only predicate is given, the POS index is best.\n          this._loopByKey0(content.predicates, predicateId, callback);\n        else\n          // If no params given, iterate all the objects.\n          this._loop(content.objects, callback);\n      }\n    }\n  }\n\n  // ### `getGraphs` returns all graphs that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  getGraphs(subject, predicate, object) {\n    const results = [];\n    this.forGraphs(g => { results.push(g); }, subject, predicate, object);\n    return results;\n  }\n\n  // ### `forGraphs` executes the callback on all graphs that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  forGraphs(callback, subject, predicate, object) {\n    for (const graph in this._graphs) {\n      this.some(quad => {\n        callback(quad.graph);\n        return true; // Halt iteration of some()\n      }, subject, predicate, object, this._termFromId(this._entities[graph]));\n    }\n  }\n\n  // ### `createBlankNode` creates a new blank node, returning its name\n  createBlankNode(suggestedName) {\n    return this._entityIndex.createBlankNode(suggestedName);\n  }\n\n  // ### `extractLists` finds and removes all list triples\n  // and returns the items per list.\n  extractLists({ remove = false, ignoreErrors = false } = {}) {\n    const lists = {}; // has scalar keys so could be a simple Object\n    const onError = ignoreErrors ? (() => true) :\n                  ((node, message) => { throw new Error(`${node.value} ${message}`); });\n\n    // Traverse each list from its tail\n    const tails = this.getQuads(null, namespaces.rdf.rest, namespaces.rdf.nil, null);\n    const toRemove = remove ? [...tails] : [];\n    tails.forEach(tailQuad => {\n      const items = [];             // the members found as objects of rdf:first quads\n      let malformed = false;      // signals whether the current list is malformed\n      let head;                   // the head of the list (_:b1 in above example)\n      let headPos;                // set to subject or object when head is set\n      const graph = tailQuad.graph; // make sure list is in exactly one graph\n\n      // Traverse the list from tail to end\n      let current = tailQuad.subject;\n      while (current && !malformed) {\n        const objectQuads = this.getQuads(null, null, current, null);\n        const subjectQuads = this.getQuads(current, null, null, null);\n        let quad, first = null, rest = null, parent = null;\n\n        // Find the first and rest of this list node\n        for (let i = 0; i < subjectQuads.length && !malformed; i++) {\n          quad = subjectQuads[i];\n          if (!quad.graph.equals(graph))\n            malformed = onError(current, 'not confined to single graph');\n          else if (head)\n            malformed = onError(current, 'has non-list arcs out');\n\n          // one rdf:first\n          else if (quad.predicate.value === namespaces.rdf.first) {\n            if (first)\n              malformed = onError(current, 'has multiple rdf:first arcs');\n            else\n              toRemove.push(first = quad);\n          }\n\n          // one rdf:rest\n          else if (quad.predicate.value === namespaces.rdf.rest) {\n            if (rest)\n              malformed = onError(current, 'has multiple rdf:rest arcs');\n            else\n              toRemove.push(rest = quad);\n          }\n\n          // alien triple\n          else if (objectQuads.length)\n            malformed = onError(current, 'can\\'t be subject and object');\n          else {\n            head = quad; // e.g. { (1 2 3) :p :o }\n            headPos = 'subject';\n          }\n        }\n\n        // { :s :p (1 2) } arrives here with no head\n        // { (1 2) :p :o } arrives here with head set to the list.\n        for (let i = 0; i < objectQuads.length && !malformed; ++i) {\n          quad = objectQuads[i];\n          if (head)\n            malformed = onError(current, 'can\\'t have coreferences');\n          // one rdf:rest\n          else if (quad.predicate.value === namespaces.rdf.rest) {\n            if (parent)\n              malformed = onError(current, 'has incoming rdf:rest arcs');\n            else\n              parent = quad;\n          }\n          else {\n            head = quad; // e.g. { :s :p (1 2) }\n            headPos = 'object';\n          }\n        }\n\n        // Store the list item and continue with parent\n        if (!first)\n          malformed = onError(current, 'has no list head');\n        else\n          items.unshift(first.object);\n        current = parent && parent.subject;\n      }\n\n      // Don't remove any quads if the list is malformed\n      if (malformed)\n        remove = false;\n      // Store the list under the value of its head\n      else if (head)\n        lists[head[headPos].value] = items;\n    });\n\n    // Remove list quads if requested\n    if (remove)\n      this.removeQuads(toRemove);\n    return lists;\n  }\n\n  /**\n   * Returns `true` if the current dataset is a superset of the given dataset; in other words, returns `true` if\n   * the given dataset is a subset of, i.e., is contained within, the current dataset.\n   *\n   * Blank Nodes will be normalized.\n   */\n  addAll(quads) {\n    if (quads instanceof DatasetCoreAndReadableStream)\n      quads = quads.filtered;\n\n    if (Array.isArray(quads))\n      this.addQuads(quads);\n    else if (quads instanceof N3Store && quads._entityIndex === this._entityIndex) {\n      if (quads._size !== 0) {\n        this._graphs = merge(this._graphs, quads._graphs);\n        this._size = null; // Invalidate the cached size\n      }\n    }\n    else {\n      for (const quad of quads)\n        this.add(quad);\n    }\n    return this;\n  }\n\n  /**\n   * Returns `true` if the current dataset is a superset of the given dataset; in other words, returns `true` if\n   * the given dataset is a subset of, i.e., is contained within, the current dataset.\n   *\n   * Blank Nodes will be normalized.\n   */\n  contains(other) {\n    if (other instanceof DatasetCoreAndReadableStream)\n      other = other.filtered;\n\n    if (other === this)\n      return true;\n\n    if (!(other instanceof N3Store) || this._entityIndex !== other._entityIndex)\n      return other.every(quad => this.has(quad));\n\n    const g1 = this._graphs, g2 = other._graphs;\n    let s1, s2, p1, p2, o1;\n    for (const graph in g2) {\n      if (!(s1 = g1[graph])) return false;\n      s1 = s1.subjects;\n      for (const subject in (s2 = g2[graph].subjects)) {\n        if (!(p1 = s1[subject])) return false;\n        for (const predicate in (p2 = s2[subject])) {\n          if (!(o1 = p1[predicate])) return false;\n          for (const object in p2[predicate])\n            if (!(object in o1)) return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * This method removes the quads in the current dataset that match the given arguments.\n   *\n   * The logic described in {@link https://rdf.js.org/dataset-spec/#quad-matching|Quad Matching} is applied for each\n   * quad in this dataset, to select the quads which will be deleted.\n   *\n   * @param subject   The optional exact subject to match.\n   * @param predicate The optional exact predicate to match.\n   * @param object    The optional exact object to match.\n   * @param graph     The optional exact graph to match.\n   */\n  deleteMatches(subject, predicate, object, graph) {\n    for (const quad of this.match(subject, predicate, object, graph))\n      this.removeQuad(quad);\n    return this;\n  }\n\n  /**\n   * Returns a new dataset that contains all quads from the current dataset that are not included in the given dataset.\n   */\n  difference(other) {\n    if (other && other instanceof DatasetCoreAndReadableStream)\n      other = other.filtered;\n\n    if (other === this)\n      return new N3Store({ entityIndex: this._entityIndex });\n\n    if ((other instanceof N3Store) && other._entityIndex === this._entityIndex) {\n      const store = new N3Store({ entityIndex: this._entityIndex });\n      const graphs = difference(this._graphs, other._graphs);\n      if (graphs) {\n        store._graphs = graphs;\n        store._size = null;\n      }\n      return store;\n    }\n\n    return this.filter(quad => !other.has(quad));\n  }\n\n  /**\n   * Returns true if the current dataset contains the same graph structure as the given dataset.\n   *\n   * Blank Nodes will be normalized.\n   */\n  equals(other) {\n    if (other instanceof DatasetCoreAndReadableStream)\n      other = other.filtered;\n\n    return other === this || (this.size === other.size && this.contains(other));\n  }\n\n  /**\n   * Creates a new dataset with all the quads that pass the test implemented by the provided `iteratee`.\n   *\n   * This method is aligned with Array.prototype.filter() in ECMAScript-262.\n   */\n  filter(iteratee) {\n    const store = new N3Store({ entityIndex: this._entityIndex });\n    for (const quad of this)\n      if (iteratee(quad, this))\n        store.add(quad);\n    return store;\n  }\n\n  /**\n   * Returns a new dataset containing all quads from the current dataset that are also included in the given dataset.\n   */\n  intersection(other) {\n    if (other instanceof DatasetCoreAndReadableStream)\n      other = other.filtered;\n\n    if (other === this) {\n      const store = new N3Store({ entityIndex: this._entityIndex });\n      store._graphs = merge(Object.create(null), this._graphs);\n      store._size = this._size;\n      return store;\n    }\n    else if ((other instanceof N3Store) && this._entityIndex === other._entityIndex) {\n      const store = new N3Store({ entityIndex: this._entityIndex });\n      const graphs = intersect(other._graphs, this._graphs);\n      if (graphs) {\n        store._graphs = graphs;\n        store._size = null;\n      }\n      return store;\n    }\n\n    return this.filter(quad => other.has(quad));\n  }\n\n  /**\n   * Returns a new dataset containing all quads returned by applying `iteratee` to each quad in the current dataset.\n   */\n  map(iteratee) {\n    const store = new N3Store({ entityIndex: this._entityIndex });\n    for (const quad of this)\n      store.add(iteratee(quad, this));\n    return store;\n  }\n\n  /**\n   * This method calls the `iteratee` method on each `quad` of the `Dataset`. The first time the `iteratee` method\n   * is called, the `accumulator` value is the `initialValue`, or, if not given, equals the first quad of the `Dataset`.\n   * The return value of each call to the `iteratee` method is used as the `accumulator` value for the next call.\n   *\n   * This method returns the return value of the last `iteratee` call.\n   *\n   * This method is aligned with `Array.prototype.reduce()` in ECMAScript-262.\n   */\n  reduce(callback, initialValue) {\n    const iter = this.readQuads();\n    let accumulator = initialValue === undefined ? iter.next().value : initialValue;\n    for (const quad of iter)\n      accumulator = callback(accumulator, quad, this);\n    return accumulator;\n  }\n\n  /**\n   * Returns the set of quads within the dataset as a host-language-native sequence, for example an `Array` in\n   * ECMAScript-262.\n   *\n   * Since a `Dataset` is an unordered set, the order of the quads within the returned sequence is arbitrary.\n   */\n  toArray() {\n    return this.getQuads();\n  }\n\n  /**\n   * Returns an N-Quads string representation of the dataset, preprocessed with the\n   * {@link https://json-ld.github.io/normalization/spec/|RDF Dataset Normalization} algorithm.\n   */\n  toCanonical() {\n    throw new Error('not implemented');\n  }\n\n  /**\n   * Returns a stream that contains all quads of the dataset.\n   */\n  toStream() {\n    return this.match();\n  }\n\n  /**\n   * Returns an N-Quads string representation of the dataset.\n   *\n   * No prior normalization is required, therefore the results for the same quads may vary depending on the `Dataset`\n   * implementation.\n   */\n  toString() {\n    return (new N3Writer()).quadsToString(this);\n  }\n\n  /**\n   * Returns a new `Dataset` that is a concatenation of this dataset and the quads given as an argument.\n   */\n  union(quads) {\n    const store = new N3Store({ entityIndex: this._entityIndex });\n    store._graphs = merge(Object.create(null), this._graphs);\n    store._size = this._size;\n\n    store.addAll(quads);\n    return store;\n  }\n\n  // ### Store is an iterable.\n  // Can be used where iterables are expected: for...of loops, array spread operator,\n  // `yield*`, and destructuring assignment (order is not guaranteed).\n  *[Symbol.iterator]() {\n    yield* this.readQuads();\n  }\n}\n\n/**\n * Returns a subset of the `index` with that part of the index\n * matching the `ids` array. `ids` contains 3 elements that are\n * either numerical ids; or `null`.\n *\n * `false` is returned when there are no matching indices; this should\n * *not* be set as the value for an index.\n */\nfunction indexMatch(index, ids, depth = 0) {\n  const ind = ids[depth];\n  if (ind && !(ind in index))\n    return false;\n\n  let target = false;\n  for (const key in (ind ? { [ind]: index[ind] } : index)) {\n    const result = depth === 2 ? null : indexMatch(index[key], ids, depth + 1);\n\n    if (result !== false) {\n      target = target || Object.create(null);\n      target[key] = result;\n    }\n  }\n  return target;\n}\n\n/**\n * A class that implements both DatasetCore and Readable.\n */\nclass DatasetCoreAndReadableStream extends Readable {\n  constructor(n3Store, subject, predicate, object, graph, options) {\n    super({ objectMode: true });\n    Object.assign(this, { n3Store, subject, predicate, object, graph, options });\n  }\n\n  get filtered() {\n    if (!this._filtered) {\n      const { n3Store, graph, object, predicate, subject } = this;\n      const newStore = this._filtered = new N3Store({ factory: n3Store._factory, entityIndex: this.options.entityIndex });\n\n      let subjectId, predicateId, objectId;\n\n      // Translate IRIs to internal index keys.\n      if (subject   && !(subjectId   = newStore._termToNumericId(subject))   ||\n          predicate && !(predicateId = newStore._termToNumericId(predicate)) ||\n          object    && !(objectId    = newStore._termToNumericId(object)))\n        return newStore;\n\n      const graphs = n3Store._getGraphs(graph);\n      for (const graphKey in graphs) {\n        let subjects, predicates, objects, content;\n        if (content = graphs[graphKey]) {\n          if (!subjectId && predicateId) {\n            if (predicates = indexMatch(content.predicates, [predicateId, objectId, subjectId])) {\n              subjects = indexMatch(content.subjects, [subjectId, predicateId, objectId]);\n              objects = indexMatch(content.objects, [objectId, subjectId, predicateId]);\n            }\n          }\n          else if (objectId) {\n            if (objects = indexMatch(content.objects, [objectId, subjectId, predicateId])) {\n              subjects = indexMatch(content.subjects, [subjectId, predicateId, objectId]);\n              predicates = indexMatch(content.predicates, [predicateId, objectId, subjectId]);\n            }\n          }\n          else if (subjects = indexMatch(content.subjects, [subjectId, predicateId, objectId])) {\n            predicates = indexMatch(content.predicates, [predicateId, objectId, subjectId]);\n            objects = indexMatch(content.objects, [objectId, subjectId, predicateId]);\n          }\n\n          if (subjects)\n            newStore._graphs[graphKey] = { subjects, predicates, objects };\n        }\n      }\n      newStore._size = null;\n    }\n    return this._filtered;\n  }\n\n  get size() {\n    return this.filtered.size;\n  }\n\n  _read(size) {\n    if (size > 0 && !this[ITERATOR])\n      this[ITERATOR] = this[Symbol.iterator]();\n    const iterable = this[ITERATOR];\n    while (--size >= 0) {\n      const { done, value } = iterable.next();\n      if (done) {\n        this.push(null);\n        return;\n      }\n      this.push(value);\n    }\n  }\n\n  addAll(quads) {\n    return this.filtered.addAll(quads);\n  }\n\n  contains(other) {\n    return this.filtered.contains(other);\n  }\n\n  deleteMatches(subject, predicate, object, graph) {\n    return this.filtered.deleteMatches(subject, predicate, object, graph);\n  }\n\n  difference(other) {\n    return this.filtered.difference(other);\n  }\n\n  equals(other) {\n    return this.filtered.equals(other);\n  }\n\n  every(callback, subject, predicate, object, graph) {\n    return this.filtered.every(callback, subject, predicate, object, graph);\n  }\n\n  filter(iteratee) {\n    return this.filtered.filter(iteratee);\n  }\n\n  forEach(callback, subject, predicate, object, graph) {\n    return this.filtered.forEach(callback, subject, predicate, object, graph);\n  }\n\n  import(stream) {\n    return this.filtered.import(stream);\n  }\n\n  intersection(other) {\n    return this.filtered.intersection(other);\n  }\n\n  map(iteratee) {\n    return this.filtered.map(iteratee);\n  }\n\n  some(callback, subject, predicate, object, graph) {\n    return this.filtered.some(callback, subject, predicate, object, graph);\n  }\n\n  toCanonical() {\n    return this.filtered.toCanonical();\n  }\n\n  toStream() {\n    return this._filtered ?\n      this._filtered.toStream()\n      : this.n3Store.match(this.subject, this.predicate, this.object, this.graph);\n  }\n\n  union(quads) {\n    return this._filtered ?\n      this._filtered.union(quads)\n      : this.n3Store.match(this.subject, this.predicate, this.object, this.graph).addAll(quads);\n  }\n\n  toArray() {\n    return this._filtered ? this._filtered.toArray() : this.n3Store.getQuads(this.subject, this.predicate, this.object, this.graph);\n  }\n\n  reduce(callback, initialValue) {\n    return this.filtered.reduce(callback, initialValue);\n  }\n\n  toString() {\n    return (new N3Writer()).quadsToString(this);\n  }\n\n  add(quad) {\n    return this.filtered.add(quad);\n  }\n\n  delete(quad) {\n    return this.filtered.delete(quad);\n  }\n\n  has(quad) {\n    return this.filtered.has(quad);\n  }\n\n  match(subject, predicate, object, graph) {\n    return new DatasetCoreAndReadableStream(this.filtered, subject, predicate, object, graph, this.options);\n  }\n\n  *[Symbol.iterator]() {\n    yield* this._filtered || this.n3Store.readQuads(this.subject, this.predicate, this.object, this.graph);\n  }\n}\n","'use strict'\n\nconst CustomStream = require('../stream')\nconst promises = require('../stream/promises')\nconst originalDestroy = CustomStream.Readable.destroy\nmodule.exports = CustomStream.Readable\n\n// Explicit export naming is needed for ESM\nmodule.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer\nmodule.exports._isUint8Array = CustomStream._isUint8Array\nmodule.exports.isDisturbed = CustomStream.isDisturbed\nmodule.exports.isErrored = CustomStream.isErrored\nmodule.exports.isReadable = CustomStream.isReadable\nmodule.exports.Readable = CustomStream.Readable\nmodule.exports.Writable = CustomStream.Writable\nmodule.exports.Duplex = CustomStream.Duplex\nmodule.exports.Transform = CustomStream.Transform\nmodule.exports.PassThrough = CustomStream.PassThrough\nmodule.exports.addAbortSignal = CustomStream.addAbortSignal\nmodule.exports.finished = CustomStream.finished\nmodule.exports.destroy = CustomStream.destroy\nmodule.exports.destroy = originalDestroy\nmodule.exports.pipeline = CustomStream.pipeline\nmodule.exports.compose = CustomStream.compose\nObject.defineProperty(CustomStream, 'promises', {\n  configurable: true,\n  enumerable: true,\n  get() {\n    return promises\n  }\n})\nmodule.exports.Stream = CustomStream.Stream\n\n// Allow default importing\nmodule.exports.default = module.exports\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict'\n\n/* replacement start */\n\nconst { Buffer } = require('buffer')\n\n/* replacement end */\n\nconst { ObjectDefineProperty, ObjectKeys, ReflectApply } = require('./ours/primordials')\nconst {\n  promisify: { custom: customPromisify }\n} = require('./ours/util')\nconst { streamReturningOperators, promiseReturningOperators } = require('./internal/streams/operators')\nconst {\n  codes: { ERR_ILLEGAL_CONSTRUCTOR }\n} = require('./ours/errors')\nconst compose = require('./internal/streams/compose')\nconst { setDefaultHighWaterMark, getDefaultHighWaterMark } = require('./internal/streams/state')\nconst { pipeline } = require('./internal/streams/pipeline')\nconst { destroyer } = require('./internal/streams/destroy')\nconst eos = require('./internal/streams/end-of-stream')\nconst internalBuffer = {}\nconst promises = require('./stream/promises')\nconst utils = require('./internal/streams/utils')\nconst Stream = (module.exports = require('./internal/streams/legacy').Stream)\nStream.isDestroyed = utils.isDestroyed\nStream.isDisturbed = utils.isDisturbed\nStream.isErrored = utils.isErrored\nStream.isReadable = utils.isReadable\nStream.isWritable = utils.isWritable\nStream.Readable = require('./internal/streams/readable')\nfor (const key of ObjectKeys(streamReturningOperators)) {\n  const op = streamReturningOperators[key]\n  function fn(...args) {\n    if (new.target) {\n      throw ERR_ILLEGAL_CONSTRUCTOR()\n    }\n    return Stream.Readable.from(ReflectApply(op, this, args))\n  }\n  ObjectDefineProperty(fn, 'name', {\n    __proto__: null,\n    value: op.name\n  })\n  ObjectDefineProperty(fn, 'length', {\n    __proto__: null,\n    value: op.length\n  })\n  ObjectDefineProperty(Stream.Readable.prototype, key, {\n    __proto__: null,\n    value: fn,\n    enumerable: false,\n    configurable: true,\n    writable: true\n  })\n}\nfor (const key of ObjectKeys(promiseReturningOperators)) {\n  const op = promiseReturningOperators[key]\n  function fn(...args) {\n    if (new.target) {\n      throw ERR_ILLEGAL_CONSTRUCTOR()\n    }\n    return ReflectApply(op, this, args)\n  }\n  ObjectDefineProperty(fn, 'name', {\n    __proto__: null,\n    value: op.name\n  })\n  ObjectDefineProperty(fn, 'length', {\n    __proto__: null,\n    value: op.length\n  })\n  ObjectDefineProperty(Stream.Readable.prototype, key, {\n    __proto__: null,\n    value: fn,\n    enumerable: false,\n    configurable: true,\n    writable: true\n  })\n}\nStream.Writable = require('./internal/streams/writable')\nStream.Duplex = require('./internal/streams/duplex')\nStream.Transform = require('./internal/streams/transform')\nStream.PassThrough = require('./internal/streams/passthrough')\nStream.pipeline = pipeline\nconst { addAbortSignal } = require('./internal/streams/add-abort-signal')\nStream.addAbortSignal = addAbortSignal\nStream.finished = eos\nStream.destroy = destroyer\nStream.compose = compose\nStream.setDefaultHighWaterMark = setDefaultHighWaterMark\nStream.getDefaultHighWaterMark = getDefaultHighWaterMark\nObjectDefineProperty(Stream, 'promises', {\n  __proto__: null,\n  configurable: true,\n  enumerable: true,\n  get() {\n    return promises\n  }\n})\nObjectDefineProperty(pipeline, customPromisify, {\n  __proto__: null,\n  enumerable: true,\n  get() {\n    return promises.pipeline\n  }\n})\nObjectDefineProperty(eos, customPromisify, {\n  __proto__: null,\n  enumerable: true,\n  get() {\n    return promises.finished\n  }\n})\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream\nStream._isUint8Array = function isUint8Array(value) {\n  return value instanceof Uint8Array\n}\nStream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)\n}\n","'use strict'\n\nconst AbortController = globalThis.AbortController || require('abort-controller').AbortController\nconst {\n  codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },\n  AbortError\n} = require('../../ours/errors')\nconst { validateAbortSignal, validateInteger, validateObject } = require('../validators')\nconst kWeakHandler = require('../../ours/primordials').Symbol('kWeak')\nconst kResistStopPropagation = require('../../ours/primordials').Symbol('kResistStopPropagation')\nconst { finished } = require('./end-of-stream')\nconst staticCompose = require('./compose')\nconst { addAbortSignalNoValidate } = require('./add-abort-signal')\nconst { isWritable, isNodeStream } = require('./utils')\nconst { deprecate } = require('../../ours/util')\nconst {\n  ArrayPrototypePush,\n  Boolean,\n  MathFloor,\n  Number,\n  NumberIsNaN,\n  Promise,\n  PromiseReject,\n  PromiseResolve,\n  PromisePrototypeThen,\n  Symbol\n} = require('../../ours/primordials')\nconst kEmpty = Symbol('kEmpty')\nconst kEof = Symbol('kEof')\nfunction compose(stream, options) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  if (isNodeStream(stream) && !isWritable(stream)) {\n    throw new ERR_INVALID_ARG_VALUE('stream', stream, 'must be writable')\n  }\n  const composedStream = staticCompose(this, stream)\n  if (options !== null && options !== undefined && options.signal) {\n    // Not validating as we already validated before\n    addAbortSignalNoValidate(options.signal, composedStream)\n  }\n  return composedStream\n}\nfunction map(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)\n  }\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  let concurrency = 1\n  if ((options === null || options === undefined ? undefined : options.concurrency) != null) {\n    concurrency = MathFloor(options.concurrency)\n  }\n  let highWaterMark = concurrency - 1\n  if ((options === null || options === undefined ? undefined : options.highWaterMark) != null) {\n    highWaterMark = MathFloor(options.highWaterMark)\n  }\n  validateInteger(concurrency, 'options.concurrency', 1)\n  validateInteger(highWaterMark, 'options.highWaterMark', 0)\n  highWaterMark += concurrency\n  return async function* map() {\n    const signal = require('../../ours/util').AbortSignalAny(\n      [options === null || options === undefined ? undefined : options.signal].filter(Boolean)\n    )\n    const stream = this\n    const queue = []\n    const signalOpt = {\n      signal\n    }\n    let next\n    let resume\n    let done = false\n    let cnt = 0\n    function onCatch() {\n      done = true\n      afterItemProcessed()\n    }\n    function afterItemProcessed() {\n      cnt -= 1\n      maybeResume()\n    }\n    function maybeResume() {\n      if (resume && !done && cnt < concurrency && queue.length < highWaterMark) {\n        resume()\n        resume = null\n      }\n    }\n    async function pump() {\n      try {\n        for await (let val of stream) {\n          if (done) {\n            return\n          }\n          if (signal.aborted) {\n            throw new AbortError()\n          }\n          try {\n            val = fn(val, signalOpt)\n            if (val === kEmpty) {\n              continue\n            }\n            val = PromiseResolve(val)\n          } catch (err) {\n            val = PromiseReject(err)\n          }\n          cnt += 1\n          PromisePrototypeThen(val, afterItemProcessed, onCatch)\n          queue.push(val)\n          if (next) {\n            next()\n            next = null\n          }\n          if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {\n            await new Promise((resolve) => {\n              resume = resolve\n            })\n          }\n        }\n        queue.push(kEof)\n      } catch (err) {\n        const val = PromiseReject(err)\n        PromisePrototypeThen(val, afterItemProcessed, onCatch)\n        queue.push(val)\n      } finally {\n        done = true\n        if (next) {\n          next()\n          next = null\n        }\n      }\n    }\n    pump()\n    try {\n      while (true) {\n        while (queue.length > 0) {\n          const val = await queue[0]\n          if (val === kEof) {\n            return\n          }\n          if (signal.aborted) {\n            throw new AbortError()\n          }\n          if (val !== kEmpty) {\n            yield val\n          }\n          queue.shift()\n          maybeResume()\n        }\n        await new Promise((resolve) => {\n          next = resolve\n        })\n      }\n    } finally {\n      done = true\n      if (resume) {\n        resume()\n        resume = null\n      }\n    }\n  }.call(this)\n}\nfunction asIndexedPairs(options = undefined) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  return async function* asIndexedPairs() {\n    let index = 0\n    for await (const val of this) {\n      var _options$signal\n      if (\n        options !== null &&\n        options !== undefined &&\n        (_options$signal = options.signal) !== null &&\n        _options$signal !== undefined &&\n        _options$signal.aborted\n      ) {\n        throw new AbortError({\n          cause: options.signal.reason\n        })\n      }\n      yield [index++, val]\n    }\n  }.call(this)\n}\nasync function some(fn, options = undefined) {\n  for await (const unused of filter.call(this, fn, options)) {\n    return true\n  }\n  return false\n}\nasync function every(fn, options = undefined) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)\n  }\n  // https://en.wikipedia.org/wiki/De_Morgan%27s_laws\n  return !(await some.call(\n    this,\n    async (...args) => {\n      return !(await fn(...args))\n    },\n    options\n  ))\n}\nasync function find(fn, options) {\n  for await (const result of filter.call(this, fn, options)) {\n    return result\n  }\n  return undefined\n}\nasync function forEach(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)\n  }\n  async function forEachFn(value, options) {\n    await fn(value, options)\n    return kEmpty\n  }\n  // eslint-disable-next-line no-unused-vars\n  for await (const unused of map.call(this, forEachFn, options));\n}\nfunction filter(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)\n  }\n  async function filterFn(value, options) {\n    if (await fn(value, options)) {\n      return value\n    }\n    return kEmpty\n  }\n  return map.call(this, filterFn, options)\n}\n\n// Specific to provide better error to reduce since the argument is only\n// missing if the stream has no items in it - but the code is still appropriate\nclass ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {\n  constructor() {\n    super('reduce')\n    this.message = 'Reduce of an empty stream requires an initial value'\n  }\n}\nasync function reduce(reducer, initialValue, options) {\n  var _options$signal2\n  if (typeof reducer !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('reducer', ['Function', 'AsyncFunction'], reducer)\n  }\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  let hasInitialValue = arguments.length > 1\n  if (\n    options !== null &&\n    options !== undefined &&\n    (_options$signal2 = options.signal) !== null &&\n    _options$signal2 !== undefined &&\n    _options$signal2.aborted\n  ) {\n    const err = new AbortError(undefined, {\n      cause: options.signal.reason\n    })\n    this.once('error', () => {}) // The error is already propagated\n    await finished(this.destroy(err))\n    throw err\n  }\n  const ac = new AbortController()\n  const signal = ac.signal\n  if (options !== null && options !== undefined && options.signal) {\n    const opts = {\n      once: true,\n      [kWeakHandler]: this,\n      [kResistStopPropagation]: true\n    }\n    options.signal.addEventListener('abort', () => ac.abort(), opts)\n  }\n  let gotAnyItemFromStream = false\n  try {\n    for await (const value of this) {\n      var _options$signal3\n      gotAnyItemFromStream = true\n      if (\n        options !== null &&\n        options !== undefined &&\n        (_options$signal3 = options.signal) !== null &&\n        _options$signal3 !== undefined &&\n        _options$signal3.aborted\n      ) {\n        throw new AbortError()\n      }\n      if (!hasInitialValue) {\n        initialValue = value\n        hasInitialValue = true\n      } else {\n        initialValue = await reducer(initialValue, value, {\n          signal\n        })\n      }\n    }\n    if (!gotAnyItemFromStream && !hasInitialValue) {\n      throw new ReduceAwareErrMissingArgs()\n    }\n  } finally {\n    ac.abort()\n  }\n  return initialValue\n}\nasync function toArray(options) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  const result = []\n  for await (const val of this) {\n    var _options$signal4\n    if (\n      options !== null &&\n      options !== undefined &&\n      (_options$signal4 = options.signal) !== null &&\n      _options$signal4 !== undefined &&\n      _options$signal4.aborted\n    ) {\n      throw new AbortError(undefined, {\n        cause: options.signal.reason\n      })\n    }\n    ArrayPrototypePush(result, val)\n  }\n  return result\n}\nfunction flatMap(fn, options) {\n  const values = map.call(this, fn, options)\n  return async function* flatMap() {\n    for await (const val of values) {\n      yield* val\n    }\n  }.call(this)\n}\nfunction toIntegerOrInfinity(number) {\n  // We coerce here to align with the spec\n  // https://github.com/tc39/proposal-iterator-helpers/issues/169\n  number = Number(number)\n  if (NumberIsNaN(number)) {\n    return 0\n  }\n  if (number < 0) {\n    throw new ERR_OUT_OF_RANGE('number', '>= 0', number)\n  }\n  return number\n}\nfunction drop(number, options = undefined) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  number = toIntegerOrInfinity(number)\n  return async function* drop() {\n    var _options$signal5\n    if (\n      options !== null &&\n      options !== undefined &&\n      (_options$signal5 = options.signal) !== null &&\n      _options$signal5 !== undefined &&\n      _options$signal5.aborted\n    ) {\n      throw new AbortError()\n    }\n    for await (const val of this) {\n      var _options$signal6\n      if (\n        options !== null &&\n        options !== undefined &&\n        (_options$signal6 = options.signal) !== null &&\n        _options$signal6 !== undefined &&\n        _options$signal6.aborted\n      ) {\n        throw new AbortError()\n      }\n      if (number-- <= 0) {\n        yield val\n      }\n    }\n  }.call(this)\n}\nfunction take(number, options = undefined) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  number = toIntegerOrInfinity(number)\n  return async function* take() {\n    var _options$signal7\n    if (\n      options !== null &&\n      options !== undefined &&\n      (_options$signal7 = options.signal) !== null &&\n      _options$signal7 !== undefined &&\n      _options$signal7.aborted\n    ) {\n      throw new AbortError()\n    }\n    for await (const val of this) {\n      var _options$signal8\n      if (\n        options !== null &&\n        options !== undefined &&\n        (_options$signal8 = options.signal) !== null &&\n        _options$signal8 !== undefined &&\n        _options$signal8.aborted\n      ) {\n        throw new AbortError()\n      }\n      if (number-- > 0) {\n        yield val\n      }\n\n      // Don't get another item from iterator in case we reached the end\n      if (number <= 0) {\n        return\n      }\n    }\n  }.call(this)\n}\nmodule.exports.streamReturningOperators = {\n  asIndexedPairs: deprecate(asIndexedPairs, 'readable.asIndexedPairs will be removed in a future version.'),\n  drop,\n  filter,\n  flatMap,\n  map,\n  take,\n  compose\n}\nmodule.exports.promiseReturningOperators = {\n  every,\n  forEach,\n  reduce,\n  toArray,\n  some,\n  find\n}\n","'use strict'\n\nconst { pipeline } = require('./pipeline')\nconst Duplex = require('./duplex')\nconst { destroyer } = require('./destroy')\nconst {\n  isNodeStream,\n  isReadable,\n  isWritable,\n  isWebStream,\n  isTransformStream,\n  isWritableStream,\n  isReadableStream\n} = require('./utils')\nconst {\n  AbortError,\n  codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }\n} = require('../../ours/errors')\nconst eos = require('./end-of-stream')\nmodule.exports = function compose(...streams) {\n  if (streams.length === 0) {\n    throw new ERR_MISSING_ARGS('streams')\n  }\n  if (streams.length === 1) {\n    return Duplex.from(streams[0])\n  }\n  const orgStreams = [...streams]\n  if (typeof streams[0] === 'function') {\n    streams[0] = Duplex.from(streams[0])\n  }\n  if (typeof streams[streams.length - 1] === 'function') {\n    const idx = streams.length - 1\n    streams[idx] = Duplex.from(streams[idx])\n  }\n  for (let n = 0; n < streams.length; ++n) {\n    if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {\n      // TODO(ronag): Add checks for non streams.\n      continue\n    }\n    if (\n      n < streams.length - 1 &&\n      !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n]))\n    ) {\n      throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], 'must be readable')\n    }\n    if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {\n      throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], 'must be writable')\n    }\n  }\n  let ondrain\n  let onfinish\n  let onreadable\n  let onclose\n  let d\n  function onfinished(err) {\n    const cb = onclose\n    onclose = null\n    if (cb) {\n      cb(err)\n    } else if (err) {\n      d.destroy(err)\n    } else if (!readable && !writable) {\n      d.destroy()\n    }\n  }\n  const head = streams[0]\n  const tail = pipeline(streams, onfinished)\n  const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head))\n  const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail))\n\n  // TODO(ronag): Avoid double buffering.\n  // Implement Writable/Readable/Duplex traits.\n  // See, https://github.com/nodejs/node/pull/33515.\n  d = new Duplex({\n    // TODO (ronag): highWaterMark?\n    writableObjectMode: !!(head !== null && head !== undefined && head.writableObjectMode),\n    readableObjectMode: !!(tail !== null && tail !== undefined && tail.readableObjectMode),\n    writable,\n    readable\n  })\n  if (writable) {\n    if (isNodeStream(head)) {\n      d._write = function (chunk, encoding, callback) {\n        if (head.write(chunk, encoding)) {\n          callback()\n        } else {\n          ondrain = callback\n        }\n      }\n      d._final = function (callback) {\n        head.end()\n        onfinish = callback\n      }\n      head.on('drain', function () {\n        if (ondrain) {\n          const cb = ondrain\n          ondrain = null\n          cb()\n        }\n      })\n    } else if (isWebStream(head)) {\n      const writable = isTransformStream(head) ? head.writable : head\n      const writer = writable.getWriter()\n      d._write = async function (chunk, encoding, callback) {\n        try {\n          await writer.ready\n          writer.write(chunk).catch(() => {})\n          callback()\n        } catch (err) {\n          callback(err)\n        }\n      }\n      d._final = async function (callback) {\n        try {\n          await writer.ready\n          writer.close().catch(() => {})\n          onfinish = callback\n        } catch (err) {\n          callback(err)\n        }\n      }\n    }\n    const toRead = isTransformStream(tail) ? tail.readable : tail\n    eos(toRead, () => {\n      if (onfinish) {\n        const cb = onfinish\n        onfinish = null\n        cb()\n      }\n    })\n  }\n  if (readable) {\n    if (isNodeStream(tail)) {\n      tail.on('readable', function () {\n        if (onreadable) {\n          const cb = onreadable\n          onreadable = null\n          cb()\n        }\n      })\n      tail.on('end', function () {\n        d.push(null)\n      })\n      d._read = function () {\n        while (true) {\n          const buf = tail.read()\n          if (buf === null) {\n            onreadable = d._read\n            return\n          }\n          if (!d.push(buf)) {\n            return\n          }\n        }\n      }\n    } else if (isWebStream(tail)) {\n      const readable = isTransformStream(tail) ? tail.readable : tail\n      const reader = readable.getReader()\n      d._read = async function () {\n        while (true) {\n          try {\n            const { value, done } = await reader.read()\n            if (!d.push(value)) {\n              return\n            }\n            if (done) {\n              d.push(null)\n              return\n            }\n          } catch {\n            return\n          }\n        }\n      }\n    }\n  }\n  d._destroy = function (err, callback) {\n    if (!err && onclose !== null) {\n      err = new AbortError()\n    }\n    onreadable = null\n    ondrain = null\n    onfinish = null\n    if (onclose === null) {\n      callback(err)\n    } else {\n      onclose = callback\n      if (isNodeStream(tail)) {\n        destroyer(tail, err)\n      }\n    }\n  }\n  return d\n}\n","/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n\n;('use strict')\nconst { ArrayIsArray, Promise, SymbolAsyncIterator, SymbolDispose } = require('../../ours/primordials')\nconst eos = require('./end-of-stream')\nconst { once } = require('../../ours/util')\nconst destroyImpl = require('./destroy')\nconst Duplex = require('./duplex')\nconst {\n  aggregateTwoErrors,\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_RETURN_VALUE,\n    ERR_MISSING_ARGS,\n    ERR_STREAM_DESTROYED,\n    ERR_STREAM_PREMATURE_CLOSE\n  },\n  AbortError\n} = require('../../ours/errors')\nconst { validateFunction, validateAbortSignal } = require('../validators')\nconst {\n  isIterable,\n  isReadable,\n  isReadableNodeStream,\n  isNodeStream,\n  isTransformStream,\n  isWebStream,\n  isReadableStream,\n  isReadableFinished\n} = require('./utils')\nconst AbortController = globalThis.AbortController || require('abort-controller').AbortController\nlet PassThrough\nlet Readable\nlet addAbortListener\nfunction destroyer(stream, reading, writing) {\n  let finished = false\n  stream.on('close', () => {\n    finished = true\n  })\n  const cleanup = eos(\n    stream,\n    {\n      readable: reading,\n      writable: writing\n    },\n    (err) => {\n      finished = !err\n    }\n  )\n  return {\n    destroy: (err) => {\n      if (finished) return\n      finished = true\n      destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED('pipe'))\n    },\n    cleanup\n  }\n}\nfunction popCallback(streams) {\n  // Streams should never be an empty array. It should always contain at least\n  // a single stream. Therefore optimize for the average case instead of\n  // checking for length === 0 as well.\n  validateFunction(streams[streams.length - 1], 'streams[stream.length - 1]')\n  return streams.pop()\n}\nfunction makeAsyncIterable(val) {\n  if (isIterable(val)) {\n    return val\n  } else if (isReadableNodeStream(val)) {\n    // Legacy streams are not Iterable.\n    return fromReadable(val)\n  }\n  throw new ERR_INVALID_ARG_TYPE('val', ['Readable', 'Iterable', 'AsyncIterable'], val)\n}\nasync function* fromReadable(val) {\n  if (!Readable) {\n    Readable = require('./readable')\n  }\n  yield* Readable.prototype[SymbolAsyncIterator].call(val)\n}\nasync function pumpToNode(iterable, writable, finish, { end }) {\n  let error\n  let onresolve = null\n  const resume = (err) => {\n    if (err) {\n      error = err\n    }\n    if (onresolve) {\n      const callback = onresolve\n      onresolve = null\n      callback()\n    }\n  }\n  const wait = () =>\n    new Promise((resolve, reject) => {\n      if (error) {\n        reject(error)\n      } else {\n        onresolve = () => {\n          if (error) {\n            reject(error)\n          } else {\n            resolve()\n          }\n        }\n      }\n    })\n  writable.on('drain', resume)\n  const cleanup = eos(\n    writable,\n    {\n      readable: false\n    },\n    resume\n  )\n  try {\n    if (writable.writableNeedDrain) {\n      await wait()\n    }\n    for await (const chunk of iterable) {\n      if (!writable.write(chunk)) {\n        await wait()\n      }\n    }\n    if (end) {\n      writable.end()\n      await wait()\n    }\n    finish()\n  } catch (err) {\n    finish(error !== err ? aggregateTwoErrors(error, err) : err)\n  } finally {\n    cleanup()\n    writable.off('drain', resume)\n  }\n}\nasync function pumpToWeb(readable, writable, finish, { end }) {\n  if (isTransformStream(writable)) {\n    writable = writable.writable\n  }\n  // https://streams.spec.whatwg.org/#example-manual-write-with-backpressure\n  const writer = writable.getWriter()\n  try {\n    for await (const chunk of readable) {\n      await writer.ready\n      writer.write(chunk).catch(() => {})\n    }\n    await writer.ready\n    if (end) {\n      await writer.close()\n    }\n    finish()\n  } catch (err) {\n    try {\n      await writer.abort(err)\n      finish(err)\n    } catch (err) {\n      finish(err)\n    }\n  }\n}\nfunction pipeline(...streams) {\n  return pipelineImpl(streams, once(popCallback(streams)))\n}\nfunction pipelineImpl(streams, callback, opts) {\n  if (streams.length === 1 && ArrayIsArray(streams[0])) {\n    streams = streams[0]\n  }\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams')\n  }\n  const ac = new AbortController()\n  const signal = ac.signal\n  const outerSignal = opts === null || opts === undefined ? undefined : opts.signal\n\n  // Need to cleanup event listeners if last stream is readable\n  // https://github.com/nodejs/node/issues/35452\n  const lastStreamCleanup = []\n  validateAbortSignal(outerSignal, 'options.signal')\n  function abort() {\n    finishImpl(new AbortError())\n  }\n  addAbortListener = addAbortListener || require('../../ours/util').addAbortListener\n  let disposable\n  if (outerSignal) {\n    disposable = addAbortListener(outerSignal, abort)\n  }\n  let error\n  let value\n  const destroys = []\n  let finishCount = 0\n  function finish(err) {\n    finishImpl(err, --finishCount === 0)\n  }\n  function finishImpl(err, final) {\n    var _disposable\n    if (err && (!error || error.code === 'ERR_STREAM_PREMATURE_CLOSE')) {\n      error = err\n    }\n    if (!error && !final) {\n      return\n    }\n    while (destroys.length) {\n      destroys.shift()(error)\n    }\n    ;(_disposable = disposable) === null || _disposable === undefined ? undefined : _disposable[SymbolDispose]()\n    ac.abort()\n    if (final) {\n      if (!error) {\n        lastStreamCleanup.forEach((fn) => fn())\n      }\n      process.nextTick(callback, error, value)\n    }\n  }\n  let ret\n  for (let i = 0; i < streams.length; i++) {\n    const stream = streams[i]\n    const reading = i < streams.length - 1\n    const writing = i > 0\n    const end = reading || (opts === null || opts === undefined ? undefined : opts.end) !== false\n    const isLastStream = i === streams.length - 1\n    if (isNodeStream(stream)) {\n      if (end) {\n        const { destroy, cleanup } = destroyer(stream, reading, writing)\n        destroys.push(destroy)\n        if (isReadable(stream) && isLastStream) {\n          lastStreamCleanup.push(cleanup)\n        }\n      }\n\n      // Catch stream errors that occur after pipe/pump has completed.\n      function onError(err) {\n        if (err && err.name !== 'AbortError' && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n          finish(err)\n        }\n      }\n      stream.on('error', onError)\n      if (isReadable(stream) && isLastStream) {\n        lastStreamCleanup.push(() => {\n          stream.removeListener('error', onError)\n        })\n      }\n    }\n    if (i === 0) {\n      if (typeof stream === 'function') {\n        ret = stream({\n          signal\n        })\n        if (!isIterable(ret)) {\n          throw new ERR_INVALID_RETURN_VALUE('Iterable, AsyncIterable or Stream', 'source', ret)\n        }\n      } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {\n        ret = stream\n      } else {\n        ret = Duplex.from(stream)\n      }\n    } else if (typeof stream === 'function') {\n      if (isTransformStream(ret)) {\n        var _ret\n        ret = makeAsyncIterable((_ret = ret) === null || _ret === undefined ? undefined : _ret.readable)\n      } else {\n        ret = makeAsyncIterable(ret)\n      }\n      ret = stream(ret, {\n        signal\n      })\n      if (reading) {\n        if (!isIterable(ret, true)) {\n          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable', `transform[${i - 1}]`, ret)\n        }\n      } else {\n        var _ret2\n        if (!PassThrough) {\n          PassThrough = require('./passthrough')\n        }\n\n        // If the last argument to pipeline is not a stream\n        // we must create a proxy stream so that pipeline(...)\n        // always returns a stream which can be further\n        // composed through `.pipe(stream)`.\n\n        const pt = new PassThrough({\n          objectMode: true\n        })\n\n        // Handle Promises/A+ spec, `then` could be a getter that throws on\n        // second use.\n        const then = (_ret2 = ret) === null || _ret2 === undefined ? undefined : _ret2.then\n        if (typeof then === 'function') {\n          finishCount++\n          then.call(\n            ret,\n            (val) => {\n              value = val\n              if (val != null) {\n                pt.write(val)\n              }\n              if (end) {\n                pt.end()\n              }\n              process.nextTick(finish)\n            },\n            (err) => {\n              pt.destroy(err)\n              process.nextTick(finish, err)\n            }\n          )\n        } else if (isIterable(ret, true)) {\n          finishCount++\n          pumpToNode(ret, pt, finish, {\n            end\n          })\n        } else if (isReadableStream(ret) || isTransformStream(ret)) {\n          const toRead = ret.readable || ret\n          finishCount++\n          pumpToNode(toRead, pt, finish, {\n            end\n          })\n        } else {\n          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable or Promise', 'destination', ret)\n        }\n        ret = pt\n        const { destroy, cleanup } = destroyer(ret, false, true)\n        destroys.push(destroy)\n        if (isLastStream) {\n          lastStreamCleanup.push(cleanup)\n        }\n      }\n    } else if (isNodeStream(stream)) {\n      if (isReadableNodeStream(ret)) {\n        finishCount += 2\n        const cleanup = pipe(ret, stream, finish, {\n          end\n        })\n        if (isReadable(stream) && isLastStream) {\n          lastStreamCleanup.push(cleanup)\n        }\n      } else if (isTransformStream(ret) || isReadableStream(ret)) {\n        const toRead = ret.readable || ret\n        finishCount++\n        pumpToNode(toRead, stream, finish, {\n          end\n        })\n      } else if (isIterable(ret)) {\n        finishCount++\n        pumpToNode(ret, stream, finish, {\n          end\n        })\n      } else {\n        throw new ERR_INVALID_ARG_TYPE(\n          'val',\n          ['Readable', 'Iterable', 'AsyncIterable', 'ReadableStream', 'TransformStream'],\n          ret\n        )\n      }\n      ret = stream\n    } else if (isWebStream(stream)) {\n      if (isReadableNodeStream(ret)) {\n        finishCount++\n        pumpToWeb(makeAsyncIterable(ret), stream, finish, {\n          end\n        })\n      } else if (isReadableStream(ret) || isIterable(ret)) {\n        finishCount++\n        pumpToWeb(ret, stream, finish, {\n          end\n        })\n      } else if (isTransformStream(ret)) {\n        finishCount++\n        pumpToWeb(ret.readable, stream, finish, {\n          end\n        })\n      } else {\n        throw new ERR_INVALID_ARG_TYPE(\n          'val',\n          ['Readable', 'Iterable', 'AsyncIterable', 'ReadableStream', 'TransformStream'],\n          ret\n        )\n      }\n      ret = stream\n    } else {\n      ret = Duplex.from(stream)\n    }\n  }\n  if (\n    (signal !== null && signal !== undefined && signal.aborted) ||\n    (outerSignal !== null && outerSignal !== undefined && outerSignal.aborted)\n  ) {\n    process.nextTick(abort)\n  }\n  return ret\n}\nfunction pipe(src, dst, finish, { end }) {\n  let ended = false\n  dst.on('close', () => {\n    if (!ended) {\n      // Finish if the destination closes before the source has completed.\n      finish(new ERR_STREAM_PREMATURE_CLOSE())\n    }\n  })\n  src.pipe(dst, {\n    end: false\n  }) // If end is true we already will have a listener to end dst.\n\n  if (end) {\n    // Compat. Before node v10.12.0 stdio used to throw an error so\n    // pipe() did/does not end() stdio destinations.\n    // Now they allow it but \"secretly\" don't close the underlying fd.\n\n    function endFn() {\n      ended = true\n      dst.end()\n    }\n    if (isReadableFinished(src)) {\n      // End the destination if the source has already ended.\n      process.nextTick(endFn)\n    } else {\n      src.once('end', endFn)\n    }\n  } else {\n    finish()\n  }\n  eos(\n    src,\n    {\n      readable: true,\n      writable: false\n    },\n    (err) => {\n      const rState = src._readableState\n      if (\n        err &&\n        err.code === 'ERR_STREAM_PREMATURE_CLOSE' &&\n        rState &&\n        rState.ended &&\n        !rState.errored &&\n        !rState.errorEmitted\n      ) {\n        // Some readable streams will emit 'close' before 'end'. However, since\n        // this is on the readable side 'end' should still be emitted if the\n        // stream has been ended and no error emitted. This should be allowed in\n        // favor of backwards compatibility. Since the stream is piped to a\n        // destination this should not result in any observable difference.\n        // We don't need to check if this is a writable premature close since\n        // eos will only fail with premature close on the reading side for\n        // duplex streams.\n        src.once('end', finish).once('error', finish)\n      } else {\n        finish(err)\n      }\n    }\n  )\n  return eos(\n    dst,\n    {\n      readable: false,\n      writable: true\n    },\n    finish\n  )\n}\nmodule.exports = {\n  pipelineImpl,\n  pipeline\n}\n","'use strict'\n\nconst { ArrayPrototypePop, Promise } = require('../ours/primordials')\nconst { isIterable, isNodeStream, isWebStream } = require('../internal/streams/utils')\nconst { pipelineImpl: pl } = require('../internal/streams/pipeline')\nconst { finished } = require('../internal/streams/end-of-stream')\nrequire('../../lib/stream.js')\nfunction pipeline(...streams) {\n  return new Promise((resolve, reject) => {\n    let signal\n    let end\n    const lastArg = streams[streams.length - 1]\n    if (\n      lastArg &&\n      typeof lastArg === 'object' &&\n      !isNodeStream(lastArg) &&\n      !isIterable(lastArg) &&\n      !isWebStream(lastArg)\n    ) {\n      const options = ArrayPrototypePop(streams)\n      signal = options.signal\n      end = options.end\n    }\n    pl(\n      streams,\n      (err, value) => {\n        if (err) {\n          reject(err)\n        } else {\n          resolve(value)\n        }\n      },\n      {\n        signal,\n        end\n      }\n    )\n  })\n}\nmodule.exports = {\n  finished,\n  pipeline\n}\n","import N3Store from './N3Store';\n\nexport default class N3DatasetCoreFactory {\n  dataset(quads) {\n    return new N3Store(quads);\n  }\n}\n","import DF from './N3DataFactory';\n\n/**\n * Gets rules from a dataset. This will only collect horn rules declared using log:implies.\n */\nexport function getRulesFromDataset(dataset) {\n  const rules = [];\n  for (const { subject, object } of dataset.match(null, DF.namedNode('http://www.w3.org/2000/10/swap/log#implies'), null, DF.defaultGraph())) {\n    const premise = [...dataset.match(null, null, null, subject)];\n    const conclusion = [...dataset.match(null, null, null, object)];\n    rules.push({ premise, conclusion });\n  }\n  return rules;\n}\n\nexport default class N3Reasoner {\n  constructor(store) {\n    this._store = store;\n  }\n\n  _add(subject, predicate, object, graphItem, cb) {\n    // Only add to the remaining indexes if there is not already a value in the index\n    if (!this._store._addToIndex(graphItem.subjects,   subject,   predicate, object)) return;\n    this._store._addToIndex(graphItem.predicates, predicate, object,    subject);\n    this._store._addToIndex(graphItem.objects,    object,    subject,   predicate);\n    cb();\n  }\n\n  // eslint-disable-next-line no-warning-comments\n  _evaluatePremise(rule, content, cb, i = 0) {\n    let v1, v2, value, index1, index2;\n    const [val0, val1, val2] = rule.premise[i].value, index = content[rule.premise[i].content];\n    const v0 = !(value = val0.value);\n    for (value in v0 ? index : { [value]: index[value] }) {\n      if (index1 = index[value]) {\n        if (v0) val0.value = Number(value);\n        v1 = !(value = val1.value);\n        for (value in v1 ? index1 : { [value]: index1[value] }) {\n          if (index2 = index1[value]) {\n            if (v1) val1.value = Number(value);\n            v2 = !(value = val2.value);\n            for (value in v2 ? index2 : { [value]: index2[value] }) {\n              if (v2) val2.value = Number(value);\n\n              if (i === rule.premise.length - 1)\n                rule.conclusion.forEach(c => {\n                  // eslint-disable-next-line max-nested-callbacks\n                  this._add(c.subject.value, c.predicate.value, c.object.value, content, () => { cb(c); });\n                });\n              else\n                this._evaluatePremise(rule, content, cb, i + 1);\n            }\n            if (v2) val2.value = null;\n          }\n        }\n        if (v1) val1.value = null;\n      }\n    }\n    if (v0) val0.value = null;\n  }\n\n  _evaluateRules(rules, content, cb) {\n    for (let i = 0; i < rules.length; i++) {\n      this._evaluatePremise(rules[i], content, cb);\n    }\n  }\n\n  // A naive reasoning algorithm where rules are just applied by repeatedly applying rules\n  // until no more evaluations are made\n  _reasonGraphNaive(rules, content) {\n    const newRules = [];\n\n    function addRule(conclusion) {\n      if (conclusion.next)\n        conclusion.next.forEach(rule => {\n          newRules.push([conclusion.subject.value, conclusion.predicate.value, conclusion.object.value, rule]);\n        });\n    }\n\n    // eslint-disable-next-line func-style\n    const addConclusions = conclusion => {\n      conclusion.forEach(c => {\n        // eslint-disable-next-line max-nested-callbacks\n        this._add(c.subject.value, c.predicate.value, c.object.value, content, () => { addRule(c); });\n      });\n    };\n\n    this._evaluateRules(rules, content, addRule);\n\n    let r;\n    while ((r = newRules.pop()) !== undefined) {\n      const [subject, predicate, object, rule] = r;\n      const v1 = rule.basePremise.subject.value;\n      if (!v1) rule.basePremise.subject.value = subject;\n      const v2 = rule.basePremise.predicate.value;\n      if (!v2) rule.basePremise.predicate.value = predicate;\n      const v3 = rule.basePremise.object.value;\n      if (!v3) rule.basePremise.object.value = object;\n\n      if (rule.premise.length === 0) {\n        addConclusions(rule.conclusion);\n      }\n      else {\n        this._evaluatePremise(rule, content, addRule);\n      }\n\n      if (!v1) rule.basePremise.subject.value = null;\n      if (!v2) rule.basePremise.predicate.value = null;\n      if (!v3) rule.basePremise.object.value = null;\n    }\n  }\n\n  _createRule({ premise, conclusion }) {\n    const varMapping = {};\n\n    const toId = value => value.termType === 'Variable' ?\n      // If the term is a variable, then create an empty object that values can be placed into\n      (varMapping[value.value] = varMapping[value.value] || {}) :\n      // If the term is not a variable, then set the ID value\n      { value: this._store._termToNewNumericId(value) };\n\n    // eslint-disable-next-line func-style\n    const t = term => ({ subject: toId(term.subject), predicate: toId(term.predicate), object: toId(term.object) });\n\n    return {\n      premise: premise.map(p => t(p)),\n      conclusion: conclusion.map(p => t(p)),\n      variables: Object.values(varMapping),\n    };\n  }\n\n  reason(rules) {\n    if (!Array.isArray(rules)) {\n      rules = getRulesFromDataset(rules);\n    }\n    rules = rules.map(rule => this._createRule(rule));\n\n    for (const r1 of rules) {\n      for (const r2 of rules) {\n        for (let i = 0; i < r2.premise.length; i++) {\n          const p = r2.premise[i];\n          for (const c of r1.conclusion) {\n            if (termEq(p.subject, c.subject) && termEq(p.predicate, c.predicate) && termEq(p.object, c.object)) {\n              const set = new Set();\n\n              const premise = [];\n\n              // Since these *will* be substituted when we apply the rule,\n              // we need to do this, so that we index correctly in the subsequent section\n              p.subject.value = p.subject.value || 1;\n              p.object.value = p.object.value || 1;\n              p.predicate.value = p.predicate.value || 1;\n\n              for (let j = 0; j < r2.premise.length; j++) {\n                if (j !== i) {\n                  premise.push(getIndex(r2.premise[j], set));\n                }\n              }\n\n              // eslint-disable-next-line no-warning-comments\n              // TODO: Create new rule, with new indexing\n              //       Future, 'collapse' the next statements when they share a premise/base-premise\n              (c.next = c.next || []).push({\n                premise,\n                conclusion: r2.conclusion,\n                // This is a single premise of the form { subject, predicate, object },\n                // which we can use to instantiate the rule using the new data that was emitted\n                basePremise: p,\n              });\n            }\n            r2.variables.forEach(v => { v.value = null; });\n          }\n        }\n      }\n    }\n\n    for (const rule of rules) {\n      const set = new Set();\n      rule.premise = rule.premise.map(p => getIndex(p, set));\n    }\n\n    const graphs = this._store._getGraphs();\n    for (const graphId in graphs) {\n      this._reasonGraphNaive(rules, graphs[graphId]);\n    }\n\n    this._store._size = null;\n  }\n}\n\nfunction getIndex({ subject, predicate, object }, set) {\n  const s = subject.value   || set.has(subject)   || (set.add(subject), false);\n  const p = predicate.value || set.has(predicate) || (set.add(predicate), false);\n  const o = object.value    || set.has(object)    || (set.add(object), false);\n\n  return (!s && p) ? { content: 'predicates', value: [predicate, object, subject] } :\n    o ? { content: 'objects', value: [object, subject, predicate] } :\n        { content: 'subjects', value: [subject, predicate, object] };\n}\n\nfunction termEq(t1, t2) {\n  if (t1.value === null) {\n    t1.value = t2.value;\n  }\n  return t1.value === t2.value;\n}\n","// **N3StreamParser** parses a text stream into a quad stream.\nimport { Transform } from 'readable-stream';\nimport N3Parser from './N3Parser';\n\n// ## Constructor\nexport default class N3StreamParser extends Transform {\n  constructor(options) {\n    super({ decodeStrings: true });\n    this._readableState.objectMode = true;\n\n    // Set up parser with dummy stream to obtain `data` and `end` callbacks\n    const parser = new N3Parser(options);\n    let onData, onEnd;\n\n    const callbacks = {\n        // Handle quads by pushing them down the pipeline\n      onQuad: (error, quad) => { error && this.emit('error', error) || quad && this.push(quad); },\n        // Emit prefixes through the `prefix` event\n      onPrefix: (prefix, uri) => { this.emit('prefix', prefix, uri); },\n    };\n\n    if (options && options.comments)\n      callbacks.onComment = comment => { this.emit('comment', comment); };\n\n    parser.parse({\n      on: (event, callback) => {\n        switch (event) {\n        case 'data': onData = callback; break;\n        case 'end':   onEnd = callback; break;\n        }\n      },\n    }, callbacks);\n\n    // Implement Transform methods through parser callbacks\n    this._transform = (chunk, encoding, done) => { onData(chunk); done(); };\n    this._flush = done => { onEnd(); done(); };\n  }\n\n  // ### Parses a stream of strings\n  import(stream) {\n    stream.on('data',  chunk => { this.write(chunk); });\n    stream.on('end',   ()      => { this.end(); });\n    stream.on('error', error => { this.emit('error', error); });\n    return this;\n  }\n}\n","// **N3StreamWriter** serializes a quad stream into a text stream.\nimport { Transform } from 'readable-stream';\nimport N3Writer from './N3Writer';\n\n// ## Constructor\nexport default class N3StreamWriter extends Transform {\n  constructor(options) {\n    super({ encoding: 'utf8', writableObjectMode: true });\n\n    // Set up writer with a dummy stream object\n    const writer = this._writer = new N3Writer({\n      write: (quad, encoding, callback) => { this.push(quad); callback && callback(); },\n      end: callback => { this.push(null); callback && callback(); },\n    }, options);\n\n    // Implement Transform methods on top of writer\n    this._transform = (quad, encoding, done) => { writer.addQuad(quad, done); };\n    this._flush = done => { writer.end(done); };\n  }\n\n// ### Serializes a stream of quads\n  import(stream) {\n    stream.on('data',   quad => { this.write(quad); });\n    stream.on('end',    () => { this.end(); });\n    stream.on('error',  error => { this.emit('error', error); });\n    stream.on('prefix', (prefix, iri) => { this._writer.addPrefix(prefix, iri); });\n    return this;\n  }\n}\n","\"use strict\";"],"names":["$7b385df8cba0e42c$var$DEFAULTGRAPH","$5501b248b6c40ce0$var$PassThrough","$5501b248b6c40ce0$var$Readable","$5501b248b6c40ce0$var$addAbortListener","$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$4696c9d5bd46ecd2$export$42af8c323be37587","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","AggregateError","constructor","errors","Array","isArray","TypeError","message","i","length","stack","name","ArrayIsArray","self","ArrayPrototypeIncludes","el","includes","ArrayPrototypeIndexOf","indexOf","ArrayPrototypeJoin","sep","join","ArrayPrototypeMap","fn","map","ArrayPrototypePop","pop","ArrayPrototypePush","push","ArrayPrototypeSlice","start","end","slice","FunctionPrototypeCall","thisArgs","args","FunctionPrototypeSymbolHasInstance","instance","Function","prototype","Symbol","hasInstance","MathFloor","Math","floor","Number","NumberIsInteger","isInteger","NumberIsNaN","isNaN","NumberMAX_SAFE_INTEGER","MAX_SAFE_INTEGER","NumberMIN_SAFE_INTEGER","MIN_SAFE_INTEGER","NumberParseInt","parseInt","ObjectDefineProperties","props","defineProperties","ObjectDefineProperty","prop","ObjectGetOwnPropertyDescriptor","getOwnPropertyDescriptor","ObjectKeys","obj","keys","ObjectSetPrototypeOf","target","proto","setPrototypeOf","Promise","PromisePrototypeCatch","catch","PromisePrototypeThen","thenFn","catchFn","then","PromiseReject","reject","PromiseResolve","val","resolve","ReflectApply","Reflect","apply","RegExpPrototypeTest","value","test","SafeSet","Set","String","StringPrototypeSlice","StringPrototypeToLowerCase","toLowerCase","StringPrototypeToUpperCase","toUpperCase","StringPrototypeTrim","trim","SymbolFor","for","SymbolAsyncIterator","asyncIterator","SymbolHasInstance","SymbolIterator","iterator","SymbolDispose","dispose","SymbolAsyncDispose","asyncDispose","TypedArrayPrototypeSet","buf","len","Boolean","Uint8Array","$N0o3H","$adSME","$f067b0868781ced2$require$format","format","$f067b0868781ced2$require$inspect","inspect","codes","ERR_INVALID_ARG_TYPE","$f067b0868781ced2$var$ERR_INVALID_ARG_TYPE","$1by5F","$f067b0868781ced2$require$kResistStopPropagation","kResistStopPropagation","$f067b0868781ced2$require$AggregateError","$f067b0868781ced2$require$SymbolDispose","$f067b0868781ced2$var$AbortSignal","AbortSignal","$f067b0868781ced2$var$AbortController","AbortController","$f067b0868781ced2$var$AsyncFunction","getPrototypeOf","$f067b0868781ced2$var$Blob","Blob","$f067b0868781ced2$var$validateAbortSignal","signal","undefined","$f067b0868781ced2$var$validateFunction","kEmptyObject","freeze","once","callback","called","createDeferredPromise","promise","res","rej","promisify","debuglog","types","isAsyncFunction","isArrayBufferView","arr","ArrayBuffer","isView","isBlob","b","deprecate","addAbortListener","listener","removeEventListener","aborted","queueMicrotask","addEventListener","__proto__","_removeEventListener","AbortSignalAny","any","signals","ac","abort","forEach","custom","$0934e0939605d48c$export$a143d493d941bafc","$0934e0939605d48c$export$e4cf37d7f6fb9e0a","$0934e0939605d48c$export$f99ded8fe4b79145","$0934e0939605d48c$export$599f31c3813fae4d","$bQMRt","$dbnIE","$0934e0939605d48c$var$customInspectSymbol","$0934e0939605d48c$var$createBuffer","RangeError","$0934e0939605d48c$var$Buffer","arg","encodingOrOffset","$0934e0939605d48c$var$allocUnsafe","$0934e0939605d48c$var$from","$0934e0939605d48c$var$fromString","string","encoding","isEncoding","$0934e0939605d48c$var$byteLength","actual","write","$0934e0939605d48c$var$fromArrayView","arrayView","$0934e0939605d48c$var$isInstance","copy","$0934e0939605d48c$var$fromArrayBuffer","buffer","byteOffset","byteLength","$0934e0939605d48c$var$fromArrayLike","SharedArrayBuffer","valueOf","from","$0934e0939605d48c$var$fromObject","isBuffer","$0934e0939605d48c$var$checked","$0934e0939605d48c$var$numberIsNaN","type","data","toPrimitive","$0934e0939605d48c$var$assertSize","size","array","mustMatch","arguments","loweredCase","$0934e0939605d48c$var$utf8ToBytes","$0934e0939605d48c$var$base64ToBytes","$0934e0939605d48c$var$slowToString","$0934e0939605d48c$var$hexSlice","out","$0934e0939605d48c$var$hexSliceLookupTable","$0934e0939605d48c$var$utf8Slice","$0934e0939605d48c$var$asciiSlice","ret","min","fromCharCode","$0934e0939605d48c$var$latin1Slice","fromByteArray","$0934e0939605d48c$var$utf16leSlice","bytes","$0934e0939605d48c$var$swap","m","$0934e0939605d48c$var$bidirectionalIndexOf","dir","$0934e0939605d48c$var$arrayIndexOf","lastIndexOf","indexSize","arrLength","valLength","read","readUInt16BE","foundIndex","found","j","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","codePoints","$0934e0939605d48c$var$checkOffset","offset","ext","$0934e0939605d48c$var$checkInt","max","$0934e0939605d48c$var$wrtBigUInt64LE","$0934e0939605d48c$var$checkIntBI","lo","BigInt","hi","$0934e0939605d48c$var$wrtBigUInt64BE","$0934e0939605d48c$var$checkIEEE754","$0934e0939605d48c$var$writeFloat","littleEndian","noAssert","$0934e0939605d48c$var$writeDouble","alloc","TYPED_ARRAY_SUPPORT","$0934e0939605d48c$var$typedArraySupport","foo","console","error","poolSize","fill","allocUnsafe","allocUnsafeSlow","_isBuffer","compare","a","x","y","concat","list","pos","swap16","swap32","swap64","toString","toLocaleString","equals","str","replace","thisStart","thisEnd","thisCopy","targetCopy","isFinite","remaining","$0934e0939605d48c$var$hexWrite","strLen","parsed","substr","$0934e0939605d48c$var$blitBuffer","$0934e0939605d48c$var$asciiToBytes","byteArray","charCodeAt","$0934e0939605d48c$var$utf16leToBytes","units","c","toJSON","_arr","newBuf","subarray","readUintLE","readUIntLE","mul","readUintBE","readUIntBE","readUint8","readUInt8","readUint16LE","readUInt16LE","readUint16BE","readUint32LE","readUInt32LE","readUint32BE","readUInt32BE","readBigUInt64LE","$0934e0939605d48c$var$defineBigIntMethod","$0934e0939605d48c$var$validateNumber","first","last","$0934e0939605d48c$var$boundsError","readBigUInt64BE","readIntLE","pow","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readBigInt64LE","readBigInt64BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUintLE","writeUIntLE","maxBytes","writeUintBE","writeUIntBE","writeUint8","writeUInt8","writeUint16LE","writeUInt16LE","writeUint16BE","writeUInt16BE","writeUint32LE","writeUInt32LE","writeUint32BE","writeUInt32BE","writeBigUInt64LE","writeBigUInt64BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeBigInt64LE","writeBigInt64BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","copyWithin","$0934e0939605d48c$var$errors","$0934e0939605d48c$var$E","sym","getMessage","Base","writable","$0934e0939605d48c$var$addNumericalSeparator","range","ERR_OUT_OF_RANGE","ERR_BUFFER_OUT_OF_BOUNDS","input","msg","received","abs","$0934e0939605d48c$var$INVALID_BASE64_RE","Infinity","leadSurrogate","toByteArray","$0934e0939605d48c$var$base64clean","split","src","dst","alphabet","table","i16","$0934e0939605d48c$var$BufferBigIntNotDefined","$8a0a73e6b73fd0c4$export$d622b2ad8d90c771","$8a0a73e6b73fd0c4$export$6100ba28696e12de","b64","tmp","lens","$8a0a73e6b73fd0c4$var$getLens","validLen","placeHoldersLen","$8a0a73e6b73fd0c4$var$Arr","curByte","$8a0a73e6b73fd0c4$var$revLookup","uint8","extraBytes","parts","len2","$8a0a73e6b73fd0c4$var$encodeChunk","output","$8a0a73e6b73fd0c4$var$lookup","num","$8a0a73e6b73fd0c4$var$code","$8a0a73e6b73fd0c4$var$i","$8a0a73e6b73fd0c4$var$len","$998eb38f4d082829$export$aafa59e2e03f2942","$998eb38f4d082829$export$68d8715fc104d294","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","d","NaN","rt","log","LN2","_unused","replacement","shift","toFixed","JSON","stringify","ctor","is","$57fdc603f46fe300$require$format","$57fdc603f46fe300$require$inspect","$57fdc603f46fe300$require$CustomAggregateError","$57fdc603f46fe300$var$AggregateError","$57fdc603f46fe300$var$kIsNodeError","$57fdc603f46fe300$var$kTypes","$57fdc603f46fe300$var$classRegExp","$57fdc603f46fe300$var$codes","$57fdc603f46fe300$var$assert","ERR_INTERNAL_ASSERTION","$57fdc603f46fe300$var$addNumericalSeparator","$57fdc603f46fe300$var$E","NodeError","$57fdc603f46fe300$var$getMessage","key","expectedLength","match","$57fdc603f46fe300$var$hideStackFrames","hidden","$57fdc603f46fe300$var$nodeInternalPrefix","expected","endsWith","instances","other","splice","_actual$constructor","inspected","depth","colors","reason","_value$constructor","AbortError","options","aggregateTwoErrors","innerError","outerError","hideStackFrames","$40fdd0443eb0b6e5$var$AbortController","$40fdd0443eb0b6e5$var$AbortSignal","window","default","$6e2b186194ca9ee7$var$ReflectOwnKeys","$6e2b186194ca9ee7$var$R","$6e2b186194ca9ee7$var$ReflectApply","receiver","ownKeys","getOwnPropertySymbols","getOwnPropertyNames","$6e2b186194ca9ee7$var$NumberIsNaN","$6e2b186194ca9ee7$var$EventEmitter","emitter","handler","flags","errorListener","removeListener","resolver","$6e2b186194ca9ee7$var$eventTargetAgnosticAddListener","on","EventEmitter","_events","_eventsCount","_maxListeners","$6e2b186194ca9ee7$var$defaultMaxListeners","$6e2b186194ca9ee7$var$checkListener","$6e2b186194ca9ee7$var$_getMaxListeners","that","defaultMaxListeners","$6e2b186194ca9ee7$var$_addListener","prepend","events","create","newListener","emit","existing","unshift","warned","w","count","warn","$6e2b186194ca9ee7$var$onceWrapper","fired","wrapFn","$6e2b186194ca9ee7$var$_onceWrap","state","wrapped","bind","$6e2b186194ca9ee7$var$_listeners","unwrap","evlistener","$6e2b186194ca9ee7$var$unwrapListeners","$6e2b186194ca9ee7$var$arrayClone","$6e2b186194ca9ee7$var$listenerCount","wrapListener","setMaxListeners","getMaxListeners","doError","er","context","listeners","addListener","prependListener","prependOnceListener","position","originalListener","$6e2b186194ca9ee7$var$spliceOne","index","off","removeAllListeners","rawListeners","listenerCount","eventNames","$fb148bf0ab02793c$var$webStreamsAdapters","$fb148bf0ab02793c$var$duplexify","$fb148bf0ab02793c$require$ObjectDefineProperties","$fb148bf0ab02793c$require$ObjectGetOwnPropertyDescriptor","$fb148bf0ab02793c$require$ObjectKeys","$fb148bf0ab02793c$require$ObjectSetPrototypeOf","$fb148bf0ab02793c$var$Duplex","$c6GJA","$95yXm","method","allowHalfOpen","readable","_readableState","ended","endEmitted","_writableState","ending","finished","$fb148bf0ab02793c$var$lazyWebStreams","writableHighWaterMark","writableObjectMode","writableBuffer","writableLength","writableFinished","writableCorked","writableEnded","writableNeedDrain","destroyed","fromWeb","pair","newStreamDuplexFromReadableWritablePair","toWeb","duplex","newReadableWritablePairFromDuplex","body","$8d0731bae61c46b3$var$webStreamsAdapters","$ibaza","$8d0731bae61c46b3$require$ArrayPrototypeIndexOf","$8d0731bae61c46b3$require$NumberIsInteger","$8d0731bae61c46b3$require$NumberIsNaN","$8d0731bae61c46b3$require$NumberParseInt","$8d0731bae61c46b3$require$ObjectDefineProperties","$8d0731bae61c46b3$require$ObjectKeys","$8d0731bae61c46b3$require$ObjectSetPrototypeOf","$8d0731bae61c46b3$require$Promise","$8d0731bae61c46b3$require$SafeSet","$8d0731bae61c46b3$require$SymbolAsyncDispose","$8d0731bae61c46b3$require$SymbolAsyncIterator","$8d0731bae61c46b3$require$Symbol","$8d0731bae61c46b3$var$Readable","ReadableState","$8d0731bae61c46b3$var$ReadableState","$8d0731bae61c46b3$require$EE","$9sqfU","$1Tt4D","$8d0731bae61c46b3$require$Stream","Stream","$8d0731bae61c46b3$require$prependListener","$8d0731bae61c46b3$require$Buffer","Buffer","$8d0731bae61c46b3$require$addAbortSignal","$6ASt2","addAbortSignal","$9RUbc","$8d0731bae61c46b3$var$debug","$ikZyt","$7CELW","$bKeTG","$8d0731bae61c46b3$require$getHighWaterMark","getHighWaterMark","$8d0731bae61c46b3$require$getDefaultHighWaterMark","getDefaultHighWaterMark","$8d0731bae61c46b3$var$aggregateTwoErrors","$8d0731bae61c46b3$var$ERR_INVALID_ARG_TYPE","ERR_METHOD_NOT_IMPLEMENTED","$8d0731bae61c46b3$var$ERR_METHOD_NOT_IMPLEMENTED","$8d0731bae61c46b3$var$ERR_OUT_OF_RANGE","ERR_STREAM_PUSH_AFTER_EOF","$8d0731bae61c46b3$var$ERR_STREAM_PUSH_AFTER_EOF","ERR_STREAM_UNSHIFT_AFTER_END_EVENT","$8d0731bae61c46b3$var$ERR_STREAM_UNSHIFT_AFTER_END_EVENT","$8d0731bae61c46b3$var$AbortError","$8d0731bae61c46b3$require$validateObject","$geuoF","validateObject","$8d0731bae61c46b3$var$kPaused","$8d0731bae61c46b3$require$StringDecoder","$jJ0xG","StringDecoder","$ixzpt","$8d0731bae61c46b3$var$nop","errorOrDestroy","$8d0731bae61c46b3$var$errorOrDestroy","$8d0731bae61c46b3$var$makeBitMapDescriptor","bit","stream","isDuplex","$8d0731bae61c46b3$var$kEmitClose","objectMode","readableObjectMode","highWaterMark","pipes","flowing","emitClose","autoDestroy","errored","defaultEncoding","awaitDrainWriters","decoder","_read","destroy","_destroy","construct","_construct","needReadable","$8d0731bae61c46b3$var$maybeReadMore","$8d0731bae61c46b3$var$readableAddChunk","chunk","addToFront","_isUint8Array","_uint8ArrayToBuffer","$8d0731bae61c46b3$var$onEofChunk","sync","$8d0731bae61c46b3$var$emitReadable","emittedReadable","$8d0731bae61c46b3$var$emitReadable_","$8d0731bae61c46b3$var$addChunk","clear","dataEmitted","$8d0731bae61c46b3$var$howMuchToRead","nextTick","$8d0731bae61c46b3$var$flow","readingMore","constructed","$8d0731bae61c46b3$var$maybeReadMore_","reading","$8d0731bae61c46b3$var$updateReadableListening","readableListening","resumeScheduled","resume","$8d0731bae61c46b3$var$nReadingNextTick","$8d0731bae61c46b3$var$resume_","$8d0731bae61c46b3$var$streamToAsyncIterator","wrap","iter","$8d0731bae61c46b3$var$createAsyncIterator","next","cleanup","destroyOnReturn","destroyer","$8d0731bae61c46b3$var$fromList","consume","$8d0731bae61c46b3$var$endReadable","$8d0731bae61c46b3$var$endReadableNT","closeEmitted","$8d0731bae61c46b3$var$endWritableNT","wState","$8d0731bae61c46b3$var$lazyWebStreams","errorEmitted","closed","multiAwaitDrain","_undestroy","undestroy","cb","captureRejectionSymbol","readableEnded","isPaused","setEncoding","enc","content","nOrig","$8d0731bae61c46b3$var$computeNewHighWaterMark","doRead","$8d0731bae61c46b3$var$kReading","pipe","dest","pipeOpts","ondrain","endFn","doEnd","stdout","stderr","unpipe","onend","onunpipe","unpipeInfo","hasUnpiped","onclose","onfinish","onerror","ondata","cleanedUp","needDrain","pause","add","delete","dests","ev","paused","streamKeys","r","readableDidRead","readableAborted","readableHighWaterMark","readableBuffer","readableFlowing","readableLength","readableEncoding","pipesCount","_fromList","iterable","opts","readableStream","newStreamReadableFromReadableStream","streamReadable","newReadableStreamFromStreamReadable","_ref","_src$readableObjectMo","$d3c1734dacb01657$var$cachedSetTimeout","$d3c1734dacb01657$var$cachedClearTimeout","$d3c1734dacb01657$var$currentQueue","$d3c1734dacb01657$var$process","$d3c1734dacb01657$var$defaultSetTimout","$d3c1734dacb01657$var$defaultClearTimeout","setTimeout","clearTimeout","$d3c1734dacb01657$var$runTimeout","fun","$d3c1734dacb01657$var$queue","$d3c1734dacb01657$var$draining","$d3c1734dacb01657$var$queueIndex","$d3c1734dacb01657$var$cleanUpNextTick","$d3c1734dacb01657$var$drainQueue","timeout","run","$d3c1734dacb01657$var$runClearTimeout","marker","$d3c1734dacb01657$var$Item","$d3c1734dacb01657$var$noop","title","browser","env","argv","version","versions","binding","cwd","chdir","umask","$16117aedbf487121$require$ArrayIsArray","$16117aedbf487121$require$ObjectSetPrototypeOf","$16117aedbf487121$require$EE","$16117aedbf487121$var$Stream","$16117aedbf487121$var$prependListener","event","source","_isStdio","didOnEnd","$4cd05af391a20c5a$var$addAbortListener","$4cd05af391a20c5a$export$e2db56ee53255a0","$4cd05af391a20c5a$export$11956e9313f43de0","$4cd05af391a20c5a$require$SymbolDispose","$7ynhX","$4cd05af391a20c5a$require$AbortError","$4cd05af391a20c5a$require$codes","$eY1Gs","$4cd05af391a20c5a$require$isNodeStream","isNodeStream","$4cd05af391a20c5a$require$isWebStream","isWebStream","$4cd05af391a20c5a$require$kControllerErrorFunction","kControllerErrorFunction","$4cd05af391a20c5a$var$ERR_INVALID_ARG_TYPE","$4cd05af391a20c5a$var$validateAbortSignal","onAbort","cause","disposable","$ae57f9ab8f8d2285$require$SymbolAsyncIterator","$ae57f9ab8f8d2285$require$SymbolIterator","$ae57f9ab8f8d2285$require$SymbolFor","$ae57f9ab8f8d2285$var$kIsDestroyed","$ae57f9ab8f8d2285$var$kIsErrored","$ae57f9ab8f8d2285$var$kIsReadable","$ae57f9ab8f8d2285$var$kIsWritable","$ae57f9ab8f8d2285$var$kIsDisturbed","$ae57f9ab8f8d2285$var$kIsClosedPromise","$ae57f9ab8f8d2285$var$isReadableNodeStream","strict","_obj$_readableState","$ae57f9ab8f8d2285$var$isWritableNodeStream","_obj$_writableState","$ae57f9ab8f8d2285$var$isNodeStream","$ae57f9ab8f8d2285$var$isReadableStream","pipeThrough","getReader","cancel","$ae57f9ab8f8d2285$var$isWritableStream","getWriter","$ae57f9ab8f8d2285$var$isTransformStream","$ae57f9ab8f8d2285$var$isDestroyed","rState","$ae57f9ab8f8d2285$var$isWritableEnded","$ae57f9ab8f8d2285$var$isReadableFinished","$ae57f9ab8f8d2285$var$isReadable","$ae57f9ab8f8d2285$var$isWritable","$ae57f9ab8f8d2285$var$isOutgoingMessage","_closed","_defaultKeepAlive","_removedConnection","_removedContLen","$ae57f9ab8f8d2285$var$isServerResponse","_sent100","isDestroyed","kIsDestroyed","isDisturbed","_stream$kIsDisturbed","kIsDisturbed","isErrored","_ref2","_ref3","_ref4","_ref5","_stream$kIsErrored","_stream$_readableStat3","_stream$_writableStat3","_stream$_readableStat4","_stream$_writableStat4","readableErrored","writableErrored","kIsErrored","isReadable","kIsReadable","kIsClosedPromise","kIsWritable","isClosed","isDuplexNodeStream","isFinished","isIterable","isAsync","isReadableNodeStream","isReadableStream","isReadableEnded","isReadableFinished","isReadableErrored","_stream$_readableStat","_stream$_readableStat2","isWritable","isWritableNodeStream","isWritableStream","isWritableEnded","isWritableFinished","isWritableErrored","_stream$_writableStat","_stream$_writableStat2","isServerRequest","_stream$req","_consuming","_dumped","req","upgradeOrConnect","isServerResponse","willEmitClose","isTransformStream","$72f4a4664289a3fc$var$addAbortListener","$72f4a4664289a3fc$require$AbortError","$72f4a4664289a3fc$var$ERR_INVALID_ARG_TYPE","ERR_STREAM_PREMATURE_CLOSE","$72f4a4664289a3fc$var$ERR_STREAM_PREMATURE_CLOSE","$72f4a4664289a3fc$require$kEmptyObject","$72f4a4664289a3fc$require$once","$72f4a4664289a3fc$require$validateAbortSignal","validateAbortSignal","$72f4a4664289a3fc$require$validateFunction","validateFunction","$72f4a4664289a3fc$require$validateObject","$72f4a4664289a3fc$require$validateBoolean","validateBoolean","$72f4a4664289a3fc$require$Promise","$72f4a4664289a3fc$require$PromisePrototypeThen","$72f4a4664289a3fc$require$SymbolDispose","$72f4a4664289a3fc$require$isClosed","$72f4a4664289a3fc$require$isReadable","$72f4a4664289a3fc$require$isReadableNodeStream","$72f4a4664289a3fc$require$isReadableStream","$72f4a4664289a3fc$require$isReadableFinished","$72f4a4664289a3fc$require$isReadableErrored","$72f4a4664289a3fc$require$isWritable","$72f4a4664289a3fc$require$isWritableNodeStream","$72f4a4664289a3fc$require$isWritableStream","$72f4a4664289a3fc$require$isWritableFinished","$72f4a4664289a3fc$require$isWritableErrored","$72f4a4664289a3fc$require$isNodeStream","$72f4a4664289a3fc$require$_willEmitClose","$72f4a4664289a3fc$require$kIsClosedPromise","$72f4a4664289a3fc$var$nop","$72f4a4664289a3fc$var$eos","_options$readable","_options$writable","$72f4a4664289a3fc$var$eosWeb","isAborted","originalCallback","resolverFn","onlegacyfinish","readableFinished","onclosed","onrequest","setHeader","endCallback","_opts","autoCleanup","$bd158850c742705e$require$ArrayIsArray","$bd158850c742705e$require$ArrayPrototypeIncludes","$bd158850c742705e$require$ArrayPrototypeJoin","$bd158850c742705e$require$ArrayPrototypeMap","$bd158850c742705e$require$NumberIsInteger","$bd158850c742705e$require$NumberIsNaN","$bd158850c742705e$require$NumberMAX_SAFE_INTEGER","$bd158850c742705e$require$NumberMIN_SAFE_INTEGER","$bd158850c742705e$require$NumberParseInt","$bd158850c742705e$require$ObjectPrototypeHasOwnProperty","ObjectPrototypeHasOwnProperty","$bd158850c742705e$require$RegExpPrototypeExec","RegExpPrototypeExec","$bd158850c742705e$require$String","$bd158850c742705e$require$StringPrototypeToUpperCase","$bd158850c742705e$require$StringPrototypeTrim","$bd158850c742705e$var$hideStackFrames","ERR_SOCKET_BAD_PORT","$bd158850c742705e$var$ERR_SOCKET_BAD_PORT","$bd158850c742705e$var$ERR_INVALID_ARG_TYPE","ERR_INVALID_ARG_VALUE","$bd158850c742705e$var$ERR_INVALID_ARG_VALUE","$bd158850c742705e$var$ERR_OUT_OF_RANGE","ERR_UNKNOWN_SIGNAL","$bd158850c742705e$var$ERR_UNKNOWN_SIGNAL","$kDFyU","normalizeEncoding","$bd158850c742705e$var$normalizeEncoding","$bd158850c742705e$var$isAsyncFunction","$bd158850c742705e$var$isArrayBufferView","$bd158850c742705e$var$signals","$bd158850c742705e$var$octalReg","$bd158850c742705e$var$validateInteger","$bd158850c742705e$var$validateInt32","$bd158850c742705e$var$validateUint32","positive","$bd158850c742705e$var$validateString","$bd158850c742705e$var$validateOneOf","oneOf","$bd158850c742705e$var$validateBoolean","$bd158850c742705e$var$getOwnPropertyValueOrDefault","defaultValue","$bd158850c742705e$var$validateObject","allowArray","allowFunction","$bd158850c742705e$var$validateDictionary","$bd158850c742705e$var$validateArray","minLength","$bd158850c742705e$var$validateBuffer","$bd158850c742705e$var$validateAbortSignal","$bd158850c742705e$var$validateFunction","$bd158850c742705e$var$validatePlainFunction","$bd158850c742705e$var$validateUndefined","$bd158850c742705e$var$linkValueRegExp","$bd158850c742705e$var$validateLinkHeaderFormat","isInt32","isUint32","parseFileMode","def","validateArray","validateStringArray","validateBooleanArray","validateAbortSignalArray","indexedName","validateBuffer","validateDictionary","validateEncoding","normalizedEncoding","validateInt32","validateInteger","validateNumber","validateOneOf","validatePlainFunction","validatePort","port","allowZero","validateSignalName","validateString","validateUint32","validateUndefined","validateUnion","union","validateLinkHeaderValue","hints","hintsLength","result","link","$d599d7d1fba2dc7c$require$StringPrototypeSlice","$d599d7d1fba2dc7c$require$SymbolIterator","$d599d7d1fba2dc7c$require$TypedArrayPrototypeSet","$d599d7d1fba2dc7c$require$Uint8Array","$d599d7d1fba2dc7c$require$Buffer","$d599d7d1fba2dc7c$require$inspect","head","tail","entry","p","hasStrings","_getString","_getBuffer","retLen","_","customInspect","$58cbb58867ae5051$var$aggregateTwoErrors","ERR_MULTIPLE_CALLBACK","$58cbb58867ae5051$var$ERR_MULTIPLE_CALLBACK","$58cbb58867ae5051$var$AbortError","$58cbb58867ae5051$require$Symbol","$58cbb58867ae5051$require$kIsDestroyed","$58cbb58867ae5051$require$isDestroyed","$58cbb58867ae5051$require$isFinished","$58cbb58867ae5051$require$isServerRequest","$58cbb58867ae5051$var$kDestroy","$58cbb58867ae5051$var$kConstruct","$58cbb58867ae5051$var$checkError","$58cbb58867ae5051$var$_destroy","onDestroy","$58cbb58867ae5051$var$emitErrorCloseNT","$58cbb58867ae5051$var$emitCloseNT","$58cbb58867ae5051$var$emitErrorNT","$58cbb58867ae5051$var$errorOrDestroy","$58cbb58867ae5051$var$constructNT","onConstruct","$58cbb58867ae5051$var$emitConstructNT","$58cbb58867ae5051$var$isRequest","$58cbb58867ae5051$var$emitCloseLegacy","$58cbb58867ae5051$var$emitErrorCloseLegacy","socket","close","finalCalled","prefinished","$88cf8bd7837b28dd$require$MathFloor","$88cf8bd7837b28dd$require$NumberIsInteger","$88cf8bd7837b28dd$require$validateInteger","$88cf8bd7837b28dd$var$ERR_INVALID_ARG_VALUE","$88cf8bd7837b28dd$var$defaultHighWaterMarkBytes","$88cf8bd7837b28dd$var$defaultHighWaterMarkObjectMode","$88cf8bd7837b28dd$var$getDefaultHighWaterMark","duplexKey","hwm","setDefaultHighWaterMark","$e5c2a3f70c10f900$export$63a7aa211a91ed69","$e5c2a3f70c10f900$require$Buffer","$fx8YU","$e5c2a3f70c10f900$var$isEncoding","$e5c2a3f70c10f900$var$StringDecoder","nb","$e5c2a3f70c10f900$var$normalizeEncoding","nenc","$e5c2a3f70c10f900$var$_normalizeEncoding","retried","text","$e5c2a3f70c10f900$var$utf16Text","$e5c2a3f70c10f900$var$utf16End","fillLast","$e5c2a3f70c10f900$var$utf8FillLast","$e5c2a3f70c10f900$var$base64Text","$e5c2a3f70c10f900$var$base64End","$e5c2a3f70c10f900$var$simpleWrite","$e5c2a3f70c10f900$var$simpleEnd","lastNeed","lastTotal","lastChar","$e5c2a3f70c10f900$var$utf8CheckByte","byte","$e5c2a3f70c10f900$var$utf8CheckExtraBytes","total","$e5c2a3f70c10f900$var$utf8CheckIncomplete","$b4f0e7985342bd1b$var$Buffer","$b4f0e7985342bd1b$var$copyProps","$b4f0e7985342bd1b$var$SafeBuffer","SlowBuffer","$d7f6c6b749ec0909$require$PromisePrototypeThen","$d7f6c6b749ec0909$require$SymbolAsyncIterator","$d7f6c6b749ec0909$require$SymbolIterator","$d7f6c6b749ec0909$require$Buffer","$d7f6c6b749ec0909$var$ERR_INVALID_ARG_TYPE","ERR_STREAM_NULL_VALUES","$d7f6c6b749ec0909$var$ERR_STREAM_NULL_VALUES","Readable","hadError","hasThrow","throw","done","return","$69dfb24d6ccdeaaf$var$webStreamsAdapters","$69dfb24d6ccdeaaf$require$ArrayPrototypeSlice","$69dfb24d6ccdeaaf$require$Error","$69dfb24d6ccdeaaf$require$FunctionPrototypeSymbolHasInstance","$69dfb24d6ccdeaaf$require$ObjectDefineProperty","$69dfb24d6ccdeaaf$require$ObjectDefineProperties","$69dfb24d6ccdeaaf$require$ObjectSetPrototypeOf","$69dfb24d6ccdeaaf$require$StringPrototypeToLowerCase","$69dfb24d6ccdeaaf$require$Symbol","$69dfb24d6ccdeaaf$require$SymbolHasInstance","$69dfb24d6ccdeaaf$var$Writable","WritableState","$69dfb24d6ccdeaaf$var$WritableState","$69dfb24d6ccdeaaf$require$EE","$69dfb24d6ccdeaaf$require$Stream","$69dfb24d6ccdeaaf$require$Buffer","$69dfb24d6ccdeaaf$require$addAbortSignal","$69dfb24d6ccdeaaf$require$getHighWaterMark","$69dfb24d6ccdeaaf$require$getDefaultHighWaterMark","$69dfb24d6ccdeaaf$var$ERR_INVALID_ARG_TYPE","$69dfb24d6ccdeaaf$var$ERR_METHOD_NOT_IMPLEMENTED","$69dfb24d6ccdeaaf$var$ERR_MULTIPLE_CALLBACK","ERR_STREAM_CANNOT_PIPE","$69dfb24d6ccdeaaf$var$ERR_STREAM_CANNOT_PIPE","ERR_STREAM_DESTROYED","$69dfb24d6ccdeaaf$var$ERR_STREAM_DESTROYED","ERR_STREAM_ALREADY_FINISHED","$69dfb24d6ccdeaaf$var$ERR_STREAM_ALREADY_FINISHED","$69dfb24d6ccdeaaf$var$ERR_STREAM_NULL_VALUES","ERR_STREAM_WRITE_AFTER_END","$69dfb24d6ccdeaaf$var$ERR_STREAM_WRITE_AFTER_END","ERR_UNKNOWN_ENCODING","$69dfb24d6ccdeaaf$var$ERR_UNKNOWN_ENCODING","$69dfb24d6ccdeaaf$var$errorOrDestroy","$69dfb24d6ccdeaaf$var$nop","$69dfb24d6ccdeaaf$var$kOnFinished","noDecode","decodeStrings","writing","corked","bufferProcessing","onwrite","$69dfb24d6ccdeaaf$var$onwrite","writecb","writelen","afterWriteTickInfo","$69dfb24d6ccdeaaf$var$resetBuffer","pendingcb","buffered","bufferedIndex","allBuffers","allNoop","_write","writev","_writev","final","_final","$69dfb24d6ccdeaaf$var$clearBuffer","$69dfb24d6ccdeaaf$var$finishMaybe","$69dfb24d6ccdeaaf$var$_write","$69dfb24d6ccdeaaf$var$writeOrBuffer","$69dfb24d6ccdeaaf$var$doWrite","$69dfb24d6ccdeaaf$var$onwriteError","$69dfb24d6ccdeaaf$var$errorBuffer","$69dfb24d6ccdeaaf$var$afterWriteTick","$69dfb24d6ccdeaaf$var$afterWrite","_state$errored","_state$errored2","onfinishCallbacks","bufferedLength","chunks","$69dfb24d6ccdeaaf$var$needFinish","onFinish","$69dfb24d6ccdeaaf$var$finish","getBuffer","object","cork","uncork","setDefaultEncoding","writableAborted","$69dfb24d6ccdeaaf$var$destroy","$69dfb24d6ccdeaaf$var$lazyWebStreams","writableStream","newStreamWritableFromWritableStream","streamWritable","newWritableStreamFromStreamWritable","$f382eca2b5a16cc3$require$isReadable","$f382eca2b5a16cc3$require$isWritable","$f382eca2b5a16cc3$require$isIterable","$f382eca2b5a16cc3$require$isNodeStream","$f382eca2b5a16cc3$require$isReadableNodeStream","$f382eca2b5a16cc3$require$isWritableNodeStream","$f382eca2b5a16cc3$require$isDuplexNodeStream","$f382eca2b5a16cc3$require$isReadableStream","$f382eca2b5a16cc3$require$isWritableStream","$f382eca2b5a16cc3$var$AbortError","$f382eca2b5a16cc3$var$ERR_INVALID_ARG_TYPE","ERR_INVALID_RETURN_VALUE","$f382eca2b5a16cc3$var$ERR_INVALID_RETURN_VALUE","$f382eca2b5a16cc3$require$destroyer","$lyuEd","$f382eca2b5a16cc3$require$createDeferredPromise","$f382eca2b5a16cc3$var$Blob","$f382eca2b5a16cc3$var$isBlob","$f382eca2b5a16cc3$var$AbortController","$f382eca2b5a16cc3$require$FunctionPrototypeCall","$f382eca2b5a16cc3$var$Duplexify","$f382eca2b5a16cc3$var$_duplexify","onreadable","onfinished","duplexify","$f382eca2b5a16cc3$var$fromAsyncGen","_promise","_resolve","arrayBuffer","$f0c2d01a397db093$require$ObjectSetPrototypeOf","$f0c2d01a397db093$var$PassThrough","$eI51J","_transform","$ab59130290515076$require$ObjectSetPrototypeOf","$ab59130290515076$require$Symbol","$ab59130290515076$var$Transform","$ab59130290515076$var$ERR_METHOD_NOT_IMPLEMENTED","$ab59130290515076$require$getHighWaterMark","$ab59130290515076$var$kCallback","transform","flush","_flush","$ab59130290515076$var$prefinish","$ab59130290515076$var$final","$858c50017c7e043d$exports","$858c50017c7e043d$export$2e2bcd8739ae039","$ddaccca9a53aa58d$export$2e2bcd8739ae039","$bcb493474cb21cf3$export$2e2bcd8739ae039","$33fd654882eefc25$export$2e2bcd8739ae039","$36d531372a4b28ea$export$2e2bcd8739ae039","$4d0027ecfd24bd04$export$2e2bcd8739ae039","$36d531372a4b28ea$export$4e0df93146cafeaf","$10e0b72da560a634$export$2e2bcd8739ae039","$20ba4d3d17382691$export$2e2bcd8739ae039","$d6cb6627f0e6b6dd$exports","$def31a84d5beabde$export$2e2bcd8739ae039","$10447076e5190544$export$2e2bcd8739ae039","$7b385df8cba0e42c$export$2e2bcd8739ae039","$7b385df8cba0e42c$export$656c1e606ad06131","$7b385df8cba0e42c$export$e55689a56c4c92c2","$7b385df8cba0e42c$export$e175ae9e414693bc","$7b385df8cba0e42c$export$1a8019c085269883","$7b385df8cba0e42c$export$c867a5c9595a1350","$7b385df8cba0e42c$export$4383f89a7161b240","$7b385df8cba0e42c$export$7005c9eb6671414d","$7b385df8cba0e42c$export$85285e91bbd99cf","$7b385df8cba0e42c$export$fbf03d1179c9227e","$def31a84d5beabde$export$d4c7b9e4255161a","$09690bd0f6e8ba27$var$RDF","$09690bd0f6e8ba27$var$XSD","$09690bd0f6e8ba27$var$SWAP","$09690bd0f6e8ba27$export$2e2bcd8739ae039","xsd","decimal","boolean","double","integer","rdf","nil","rest","langString","owl","sameAs","forSome","forAll","implies","isImpliedBy","$ddaccca9a53aa58d$var$xsd","$ddaccca9a53aa58d$var$escapeSequence","$ddaccca9a53aa58d$var$escapeReplacements","$ddaccca9a53aa58d$var$illegalIriChars","$ddaccca9a53aa58d$var$lineModeRegExps","_iri","_unescapedIri","_simpleQuotedString","_langcode","_blank","_newline","_comment","_whitespace","_endOfFile","$ddaccca9a53aa58d$var$invalidRegExp","_simpleApostropheString","_prefix","_prefixed","_variable","_number","_boolean","_keyword","_sparqlKeyword","_shortPredicates","_isImpliedBy","_lineMode","lineMode","_n3Mode","RegExp","n3","comments","_literalClosingPos","_tokenizeToEnd","inputFinished","_input","currentLineLength","whiteSpaceMatch","comment","exec","emitToken","_line","line","firstChar","prefix","matchLength","inconclusive","_previousMarker","_unescape","reportSyntaxError","_parseLiteral","token","previousToken","_syntaxError","item","invalid","replaced","sequence","unicode4","unicode8","escapedChar","charCode","opening","openingLength","closingPos","backslashCount","raw","substring","lines","issue","_readStartingBom","startsWith","tokenize","tokens","t","_pendingBuffer","$7b385df8cba0e42c$var$rdf","$7b385df8cba0e42c$var$xsd","$7b385df8cba0e42c$var$_blankNodeCounter","$7b385df8cba0e42c$var$DataFactory","namedNode","$7b385df8cba0e42c$var$namedNode","blankNode","$7b385df8cba0e42c$var$blankNode","variable","$7b385df8cba0e42c$var$variable","literal","$7b385df8cba0e42c$var$literal","defaultGraph","quad","$7b385df8cba0e42c$var$quad","triple","fromTerm","$7b385df8cba0e42c$export$5f4f0fc25db47ca3","fromQuad","$7b385df8cba0e42c$export$10a0669b95c12803","termType","hashCode","language","atPos","datatype","datatypeString","dtPos","char","factory","nested","endPos","parse","term","subject","predicate","graph","_subject","_predicate","_object","_graph","iri","languageOrDataType","inQuad","$bcb493474cb21cf3$var$blankNodePrefix","_contextStack","_setBase","baseIRI","$bcb493474cb21cf3$var$initDataFactory","isTurtle","isTriG","isNTriples","isNQuads","isN3","isLineMode","_supportsNamedGraphs","_readPredicateOrNamedGraph","_readPredicate","_supportsQuads","_supportsRDFStar","_resolveRelativeIRI","_blankNodePrefix","blankNodePrefix","_lexer","lexer","_explicitQuantifiers","explicitQuantifiers","_resetBlankNodePrefix","fragmentPos","_base","_basePath","_baseRoot","_baseScheme","_saveContext","n3Mode","inverse","_inversePredicate","blankPrefix","_prefixes","quantified","_quantified","_restoreContext","_error","_readInTopContext","_callback","_sparqlStyle","_readPrefix","_readBaseIRI","_readSubject","_readNamedGraphLabel","_readEntity","quantifier","_resolveIRI","_factory","_readBlankNodeHead","RDF_NIL","_readListItem","_readPunctuation","N3_FORSOME","_quantifier","_readQuantifierList","N3_FORALL","_literalValue","_completeSubjectLiteral","_getPathReader","ABBREVIATIONS","_readBlankNodeTail","_readObject","_readDataTypeOrLang","_getContextEndReader","_readGraph","_readBlankNodePunctuation","_emit","empty","_readPredicateAfterBlank","previousList","parent","RDF_FIRST","_readListItemDataTypeOrLang","RDF_REST","_completeObjectLiteral","_completeLiteral","listItem","completed","_readCallback","_readFormulaTail","inversePredicate","DEFAULTGRAPH","_readQuadPunctuation","_readPrefixIRI","prefixNode","_prefixCallback","_readDeclarationPunctuation","_readNamedGraphBlankLabel","entity","QUANTIFIERS_GRAPH","_readQuantifierPunctuation","afterPath","_afterPath","_readPath","_readForwardPath","_readBackwardPath","_readRDFStarTailOrGraph","_readRDFStarTail","contextStack","$bcb493474cb21cf3$var$noop","_removeDotSegments","pathStart","segmentStart","quadCallback","prefixCallback","onQuad","onPrefix","onComment","quads","every","processNextToken","parser","$d6cb6627f0e6b6dd$export$10490ce738f72284","$d6cb6627f0e6b6dd$export$7b5b4967656acaac","$d6cb6627f0e6b6dd$export$899158ea22bb4609","$d6cb6627f0e6b6dd$export$670a0c046e2ed227","$d6cb6627f0e6b6dd$export$1a29e0fa6b36b0c8","$d6cb6627f0e6b6dd$export$be8c4434e9c7c90b","$d6cb6627f0e6b6dd$export$82e9f45cca5ba907","$d6cb6627f0e6b6dd$export$5d3c3f85c29a375","defaultPrefixes","prefixes","processPrefix","cache","local","$a6348d508b0956c5$export$104ed90cc1a13451","regex","$10447076e5190544$var$BASE_UNSUPPORTED","$10447076e5190544$var$SUFFIX_SUPPORTED","base","_baseLength","_baseMatcher","_pathReplacements","supports","_getBaseMatcher","scheme","regexHead","regexTail","segments","segmenter","segment","query","fragment","lastIndex","$10447076e5190544$var$PARENT","repeat","toRelative","parentPath","suffix","$33fd654882eefc25$var$DEFAULTGRAPH","$33fd654882eefc25$var$rdf","$33fd654882eefc25$var$xsd","$33fd654882eefc25$var$escape","$33fd654882eefc25$var$escapeAll","$33fd654882eefc25$var$escapedCharacters","$33fd654882eefc25$var$SerializedTerm","outputStream","_prefixRegex","_lists","lists","_outputStream","_endStream","_writeQuad","_writeQuadLine","_prefixIRIs","addPrefixes","_baseIri","_inDefaultGraph","_encodeIriOrBlank","_encodeObject","_encodePredicate","_encodeSubject","_prefixMatch","quadToString","quadsToString","quadsString","_encodeQuad","$33fd654882eefc25$var$characterReplacer","prefixMatch","_encodeLiteral","_blockedWrite","addQuad","addQuads","addPrefix","hasPrefixes","IRIlist","prefixList","prefixIRI","blank","children","child","contents","elements","singleDone","character","$3450dab365fe3575$exports","$ec1bbd7296755677$exports","$ec1bbd7296755677$require$Buffer","$ec1bbd7296755677$require$ObjectDefineProperty","$ec1bbd7296755677$require$ObjectKeys","$ec1bbd7296755677$require$ReflectApply","$ec1bbd7296755677$var$customPromisify","$4696c9d5bd46ecd2$var$AbortController","$4696c9d5bd46ecd2$var$ERR_INVALID_ARG_VALUE","$4696c9d5bd46ecd2$var$ERR_INVALID_ARG_TYPE","ERR_MISSING_ARGS","$4696c9d5bd46ecd2$var$ERR_MISSING_ARGS","$4696c9d5bd46ecd2$var$ERR_OUT_OF_RANGE","$4696c9d5bd46ecd2$var$AbortError","$4696c9d5bd46ecd2$require$validateAbortSignal","$4696c9d5bd46ecd2$require$validateInteger","$4696c9d5bd46ecd2$require$validateObject","$4696c9d5bd46ecd2$var$kWeakHandler","$4696c9d5bd46ecd2$var$kResistStopPropagation","$4696c9d5bd46ecd2$require$finished","$d16ccf556459ec6a$exports","$5501b248b6c40ce0$exports","$5501b248b6c40ce0$require$ArrayIsArray","$5501b248b6c40ce0$require$Promise","$5501b248b6c40ce0$require$SymbolAsyncIterator","$5501b248b6c40ce0$require$SymbolDispose","$5501b248b6c40ce0$require$once","$5501b248b6c40ce0$var$aggregateTwoErrors","$5501b248b6c40ce0$var$ERR_INVALID_ARG_TYPE","$5501b248b6c40ce0$var$ERR_INVALID_RETURN_VALUE","$5501b248b6c40ce0$var$ERR_MISSING_ARGS","$5501b248b6c40ce0$var$ERR_STREAM_DESTROYED","$5501b248b6c40ce0$var$ERR_STREAM_PREMATURE_CLOSE","$5501b248b6c40ce0$var$AbortError","$5501b248b6c40ce0$require$validateFunction","$5501b248b6c40ce0$require$validateAbortSignal","$5501b248b6c40ce0$require$isIterable","$5501b248b6c40ce0$require$isReadable","$5501b248b6c40ce0$require$isReadableNodeStream","$5501b248b6c40ce0$require$isNodeStream","$5501b248b6c40ce0$require$isTransformStream","$5501b248b6c40ce0$require$isWebStream","$5501b248b6c40ce0$require$isReadableStream","$5501b248b6c40ce0$require$isReadableFinished","$5501b248b6c40ce0$var$AbortController","$5501b248b6c40ce0$var$destroyer","$5501b248b6c40ce0$var$makeAsyncIterable","$5501b248b6c40ce0$var$fromReadable","$5501b248b6c40ce0$var$pumpToNode","finish","onresolve","wait","$5501b248b6c40ce0$var$pumpToWeb","writer","ready","$5501b248b6c40ce0$var$pipelineImpl","streams","outerSignal","lastStreamCleanup","finishImpl","destroys","finishCount","_disposable","isLastStream","onError","_ret","_ret2","pt","toRead","$5501b248b6c40ce0$var$pipe","$d16ccf556459ec6a$require$pipeline","pipelineImpl","pipeline","$d16ccf556459ec6a$require$destroyer","$d16ccf556459ec6a$require$isNodeStream","$d16ccf556459ec6a$require$isReadable","$d16ccf556459ec6a$require$isWritable","$d16ccf556459ec6a$require$isWebStream","$d16ccf556459ec6a$require$isTransformStream","$d16ccf556459ec6a$require$isWritableStream","$d16ccf556459ec6a$require$isReadableStream","$d16ccf556459ec6a$var$AbortError","$d16ccf556459ec6a$var$ERR_INVALID_ARG_VALUE","$d16ccf556459ec6a$var$ERR_MISSING_ARGS","orgStreams","idx","reader","$4696c9d5bd46ecd2$require$addAbortSignalNoValidate","addAbortSignalNoValidate","$4696c9d5bd46ecd2$require$isWritable","$4696c9d5bd46ecd2$require$isNodeStream","$4696c9d5bd46ecd2$require$deprecate","$4696c9d5bd46ecd2$require$ArrayPrototypePush","$4696c9d5bd46ecd2$require$Boolean","$4696c9d5bd46ecd2$require$MathFloor","$4696c9d5bd46ecd2$require$Number","$4696c9d5bd46ecd2$require$NumberIsNaN","$4696c9d5bd46ecd2$require$Promise","$4696c9d5bd46ecd2$require$PromiseReject","$4696c9d5bd46ecd2$require$PromiseResolve","$4696c9d5bd46ecd2$require$PromisePrototypeThen","$4696c9d5bd46ecd2$require$Symbol","$4696c9d5bd46ecd2$var$kEmpty","$4696c9d5bd46ecd2$var$kEof","$4696c9d5bd46ecd2$var$map","concurrency","filter","queue","signalOpt","cnt","onCatch","afterItemProcessed","maybeResume","pump","$4696c9d5bd46ecd2$var$some","unused","$4696c9d5bd46ecd2$var$filter","$4696c9d5bd46ecd2$var$every","$4696c9d5bd46ecd2$var$find","$4696c9d5bd46ecd2$var$forEach","forEachFn","filterFn","$4696c9d5bd46ecd2$var$ReduceAwareErrMissingArgs","$4696c9d5bd46ecd2$var$reduce","reducer","initialValue","_options$signal2","_options$signal3","hasInitialValue","gotAnyItemFromStream","$4696c9d5bd46ecd2$var$toArray","_options$signal4","$4696c9d5bd46ecd2$var$toIntegerOrInfinity","number","asIndexedPairs","_options$signal","drop","_options$signal5","_options$signal6","flatMap","values","take","_options$signal7","_options$signal8","compose","composedStream","$ec1bbd7296755677$require$promiseReturningOperators","reduce","toArray","some","find","ERR_ILLEGAL_CONSTRUCTOR","$ec1bbd7296755677$var$ERR_ILLEGAL_CONSTRUCTOR","$ec1bbd7296755677$require$setDefaultHighWaterMark","$ec1bbd7296755677$require$getDefaultHighWaterMark","$ec1bbd7296755677$require$pipeline","$ec1bbd7296755677$require$destroyer","$369d19b0ed0d12c8$exports","$369d19b0ed0d12c8$require$ArrayPrototypePop","$369d19b0ed0d12c8$require$Promise","$369d19b0ed0d12c8$require$isIterable","$369d19b0ed0d12c8$require$isNodeStream","$369d19b0ed0d12c8$require$isWebStream","$369d19b0ed0d12c8$require$pl","lastArg","$ec1bbd7296755677$var$Stream","op","$ec1bbd7296755677$require$streamReturningOperators","fn1","Writable","Duplex","Transform","PassThrough","$3450dab365fe3575$var$originalDestroy","$36d531372a4b28ea$var$ITERATOR","$36d531372a4b28ea$var$merge","assign","_id","_ids","_entities","_blankNodeIndex","_termFromId","entities","terms","_termToNumericId","g","o","_termToNewNumericId","createBlankNode","suggestedName","_size","_graphs","_entityIndex","entityIndex","addAll","subjects","graphs","graphKey","subjectKey","predicateKey","_addToIndex","index0","key0","key1","key2","index1","index2","existed","_removeFromIndex","_findInIndex","name0","name1","name2","graphId","entityKeys","value0","value1","l","_loop","_loopByKey0","_loopByKey1","_loopBy2Keys","_countInIndex","_getGraphs","_uniqueEntities","uniqueIds","graphItem","predicates","objects","removeQuad","has","subjectOrQuad","readQuads","import","removeQuads","remove","removeMatches","deleteGraph","getQuads","subjectId","predicateId","objectId","$36d531372a4b28ea$var$DatasetCoreAndReadableStream","countQuads","getSubjects","results","forSubjects","getPredicates","forPredicates","getObjects","forObjects","getGraphs","forGraphs","extractLists","ignoreErrors","node","tails","toRemove","tailQuad","headPos","items","malformed","current","objectQuads","subjectQuads","filtered","contains","s1","s2","p1","p2","o1","g1","g2","deleteMatches","difference","store","$36d531372a4b28ea$var$difference","diff","iteratee","intersection","$36d531372a4b28ea$var$intersect","accumulator","toCanonical","toStream","$36d531372a4b28ea$var$indexMatch","ids","ind","n3Store","_filtered","newStore","dataset","rules","premise","conclusion","_store","_add","_evaluatePremise","rule","v1","v2","val0","val1","val2","v0","_evaluateRules","_reasonGraphNaive","newRules","addRule","addConclusions","basePremise","v3","_createRule","varMapping","toId","variables","r1","r2","$def31a84d5beabde$var$termEq","$def31a84d5beabde$var$getIndex","t1","t2","onData","onEnd","callbacks","uri","_writer","Lexer","Parser","Writer","Store","StoreFactory","EntityIndex","StreamParser","StreamWriter","Util","Reasoner","BaseIRI","DataFactory","Term","NamedNode","Literal","BlankNode","Variable","DefaultGraph","Quad","Triple","termFromId","termToId","$8fdc4695a8dd62cf$require$fs","$8fdc4695a8dd62cf$var$DataFactory","$8fdc4695a8dd62cf$var$namedNode","$8fdc4695a8dd62cf$var$literal","$8fdc4695a8dd62cf$var$convertTtlToJson","inputFile","outputFile","shapes","ttlData","readFile","shape","shapeId","targetClass","properties","propertyId","path","minCount","nodeKind","class","orQuads","or","orList","orItem","orNode","orDetails","orProp","detail","jsonOutput","writeFile"],"version":3,"file":"convert_shacl.js.map"}